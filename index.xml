<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</title>
    <link>http://lsd.ucsc.edu/</link>
    <description>Recent content in Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Jan 2024 15:35:32 -0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2024)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2024sp/</link>
      <pubDate>Mon, 22 Jan 2024 15:35:32 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2024sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2024, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-5&#34;&gt;April 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Luke Geeson&lt;/td&gt;
&lt;td&gt;Compiler Testing with Relaxed Memory Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-12&#34;&gt;April 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dan Plyukhin&lt;/td&gt;
&lt;td&gt;Ozone: Fully Out-of-Order Choreographies&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-19&#34;&gt;April 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ismail Kuru&lt;/td&gt;
&lt;td&gt;Modal Abstractions for Virtualizing Memory Addresses&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-26&#34;&gt;April 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jennifer Switzer&lt;/td&gt;
&lt;td&gt;Hardware Repurposing to Reduce the Embodied Carbon of Computing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-3&#34;&gt;May 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Julian Haas&lt;/td&gt;
&lt;td&gt;LoRe: Reasoning about Safety and Consistency in Local-First Software&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-10&#34;&gt;May 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Robin Brown&lt;/td&gt;
&lt;td&gt;WebAssembly Components: The Modular Polyglot Ecosystem We Need&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-17&#34;&gt;May 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zach Sisco&lt;/td&gt;
&lt;td&gt;Hardware Decompilation: Recovering Abstraction in Digital Circuits&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;May 24&lt;/td&gt;
&lt;td&gt;Guannan Wei&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;May 31&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;June 7&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;april-5&#34;&gt;April 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Luke Geeson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compiler Testing with Relaxed Memory Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Finding bugs is key to the correctness of compilers in wide use today. If the behaviour of a compiled program, as allowed by its architecture memory model, is not a behaviour of the source program under its source model, then there is a bug. This holds for all programs, but we focus on concurrency bugs that occur only with two or more threads of execution. We focus on testing techniques that detect such bugs in C/C++ compilers.&lt;/p&gt;

&lt;p&gt;We seek a testing technique that automatically covers concurrency bugs up to fixed bounds on program sizes and that scales to find bugs in compiled programs with many lines of code. Otherwise, a testing technique can miss bugs. Unfortunately, the state-of-the-art techniques are yet to satisfy all of these properties.&lt;/p&gt;

&lt;p&gt;We present the T√©l√©chat compiler testing tool for concurrent programs. T√©l√©chat compiles a concurrent C/C++ program and compares source and compiled program behaviours using source and architecture memory models. We make three claims: T√©l√©chat improves the state-of-the-art at finding bugs in code generation for multi-threaded execution, it is the first public description of a compiler testing tool for concurrency that is deployed in industry, and it is the first tool that takes a significant step towards the desired properties. We provide experimental evidence suggesting T√©l√©chat finds bugs missed by other state-of-the-art techniques, case studies indicating that T√©l√©chat satisfies the properties, and reports of our experience deploying T√©l√©chat in industry regression testing.&lt;/p&gt;

&lt;p&gt;Based on work to appear in the International Symposium on Code Generation and Optimization (CGO) 2024:
&lt;a href=&#34;https://conf.researchr.org/info/cgo-2024/accepted-papers&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://conf.researchr.org/info/cgo-2024/accepted-papers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And recently presented work at The Future of Weak Memory Workshop (POPL) 2024:
&lt;a href=&#34;https://lukegeeson.com/talks/2024-01-15-POPL24/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://lukegeeson.com/talks/2024-01-15-POPL24/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Luke is a Computer Science PhD student at UCL, supervised by James Brotherston, Earl Barr, and Lee Smith. He is developing techniques to find concurrency bugs in C/C++ compilers using formal models of relaxed memory concurrency.&lt;/p&gt;

&lt;p&gt;He is based in the compiler teams at Arm in Cambridge where he assists engineers with finding bugs and deploying automated concurrency testing as part of an EPSRC grant. Luke&amp;rsquo;s opinions are his own and Arm does not endorse his work.&lt;/p&gt;

&lt;h2 id=&#34;april-12&#34;&gt;April 12&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Dan Plyukhin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Ozone: Fully Out-of-Order Choreographies&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a paradigm for writing distributed applications. It allows programmers to write a single program, called a choreography, that can be compiled to generate correct implementations of each process in the application. Although choreographies provide good static guarantees, they can exhibit high latency when messages or processes are delayed. This is because processes in a choreography typically execute in a fixed, deterministic order, and cannot adapt to the order that messages arrive at runtime. In non-choreographic code, programmers can address this problem by allowing processes to execute out of order &amp;ndash; for instance by using futures or reactive programming. However, in choreographic code, out-of-order process execution can lead to serious and subtle bugs, called communication integrity violations (CIVs).&lt;/p&gt;

&lt;p&gt;In this paper, we develop a model of choreographic programming for out-of-order processes that guarantees absence of CIVs and deadlocks. As an application of our approach, we also introduce an API for safe non-blocking communication via futures in the choreographic programming language Choral. The API allows processes to execute out of order, participate in multiple choreographies concurrently, and to handle unordered or dropped messages as in the UDP transport protocol. We provide an illustrative evaluation of our API, showing that out-of-order execution can reduce latency by overlapping communication with computation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dan works as a postdoc at the University of Southern Denmark and is receiving his PhD from the University of Illinois at Urbana-Champaign (UIUC). He is the author of the UIGC library for Akka, which provides fault-tolerant resource management for distributed actor systems. Dan‚Äôs research focuses on making distributed reactive applications easier to write and reason about.&lt;/p&gt;

&lt;h2 id=&#34;april-19&#34;&gt;April 19&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ismail Kuru&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modal Abstractions for Virtualizing Memory Addresses&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Virtual Memory Managers are critical pieces of general-purpose OS kernels. They enable virtualizing the addresses of memory regions by realizing the address translation mechanism using CPU&amp;rsquo;s memory management&amp;rsquo;s (MMU) kernel-controlled page tables. Operating systems manipulate these virtualized memory mappings to isolate untrusted processes, restrict which memory is accessible to different processes, hide memory limits from user programs, etc.&lt;/p&gt;

&lt;p&gt;Unfortunately, verifying them becomes challenging as they are interfaced by the complex hardware: the page tables are updated via writes to those memory locations, using addresses that are themselves virtualized!  Prior work on verification of VMM has either only handled a single address space, trusted significant pieces of assembly code, or resorted to direct reasoning over machine semantics rather than exposing a clean logical interface.&lt;/p&gt;

&lt;p&gt;In this talk, I will be explaining the logical abstractions, some of which are inspired by Hybrid Logic and allow us to mention resources (virtualized memory addresses) belonging to different address spaces within the same specification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am Ismail Kuru, a final year PhD student at Drexel University, and I am advised by Dr. Colin S. Gordon. Right before coming to Drexel, I was a senior software engineer at CRYTEK Gaming Company. Before then, I had finished my computer science masters courses at TU Munich and graduated with an M.S. degree from Koc University as a Microsoft Research EMEA scholar for graduate studies.&lt;/p&gt;

&lt;h2 id=&#34;april-26&#34;&gt;April 26&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jennifer Switzer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hardware Repurposing to Reduce the Embodied Carbon of Computing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Sustainable computing efforts have traditionally focused on runtime efficiency. However, a significant fraction of the carbon emissions associated with computing systems are incurred not during use, but rather manufacture. These embodied emissions are responsible for 40% of the lifetime carbon footprint for server-class hardware, and as much as 80% for consumer electronics like smartphones.
This work presents a new way of thinking about sustainable computing, in terms of both operational and embodied emissions. It explores one consequence of this thinking‚Äîthat reducing the demand for newly manufactured hardware is an important strategy for emissions reduction. To this end, we propose the repurposing of consumer-class hardware as general purpose computing or sensing hardware. This is explored through several real-world deployments of repurposed smartphones. We find that repurposed devices can provide a computing platform that is several times more carbon-efficient than the alternative of manufacturing new hardware, and explore the applications for which repurposed devices are best suited.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jennifer Switzer is a PhD candidate at UC San Diego. Her research interests lie at the intersection of sustainability and computing systems, and especially efforts to reduce the embodied carbon footprint of computing. She is supported by a Google Fellowship.&lt;/p&gt;

&lt;h2 id=&#34;may-3&#34;&gt;May 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Julian Haas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; LoRe: Reasoning about Safety and Consistency in Local-First Software&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The &amp;ldquo;Local-First Software&amp;rdquo; movement calls for distributed applications that move data processing from the cloud back to local user devices. This allows for applications that work offline and preserve user privacy while still enabling collaboration and data synchronization. Unfortunately, the distributed and asynchronous nature of such applications makes them hard to reason about and existing programming models provide little to no support for verification.&lt;/p&gt;

&lt;p&gt;We propose LoRe, a programming language and compiler that automatically verifies developer-supplied safety properties for local-first applications. LoRe combines the declarative data flow of reactive programming with static analysis and verification techniques to precisely determine concurrent interactions that violate safety invariants and to selectively employ strong consistency through coordination where required. We introduce a formalized proof principle and demonstrate how to automate the process in a prototype implementation that outputs verified executable code.&lt;/p&gt;

&lt;p&gt;The talk will be based on work that appeared in the ACM Transactions on Programming Languages and Systems (TOPLAS) 2024: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3633769&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3633769&lt;/a&gt;
And at ECOOP 2023: &lt;a href=&#34;https://doi.org/10.4230/LIPIcs.ECOOP.2023.12&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://doi.org/10.4230/LIPIcs.ECOOP.2023.12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Julian is a third-year PhD student at TU Darmstadt in Germany, supervised by Mira Mezini and co-supervised by Annette Bieniusa at TU Kaiserslautern. In his research, he is working on programming languages and verification tools for distributed systems, with a focus on privacy-preserving decentralized applications. When not in front of a screen, he enjoys hiking and playing board games.&lt;/p&gt;

&lt;h2 id=&#34;may-10&#34;&gt;May 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Robin Brown&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; WebAssembly Components: The Modular Polyglot Ecosystem We Need&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; With the release of &lt;a href=&#34;https://bytecodealliance.org/articles/WASI-0.2&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WASI 0.2&lt;/a&gt; and the &lt;a href=&#34;https://component-model.bytecodealliance.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Component Model&lt;/a&gt;, WebAssembly (Wasm) has facilities for high-level interop between Wasm guests and hosts, as well as other guests. While some of this was possible with various project-bespoke ABIs, having a shared standards-track canonical ABI and Component Model enables the creation of a broader ecosystem without fragmentation.&lt;/p&gt;

&lt;p&gt;An increasing number of programming languages are able to produce components which implement the standard WASI &amp;ldquo;worlds&amp;rdquo; for &lt;a href=&#34;https://github.com/WebAssembly/wasi-http&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;servers&lt;/a&gt; and &lt;a href=&#34;https://github.com/WebAssembly/wasi-cli&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;CLI&lt;/a&gt; applications as well as an infinite variety of custom interfaces. There&amp;rsquo;s also been innovation in tools like &lt;a href=&#34;https://github.com/bytecodealliance/wac&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WAC&lt;/a&gt; that make it possible to compose arbitrary components statically with strong static type checking. This makes Wasm incredibly powerful as a way to build modular composable polyglot systems.&lt;/p&gt;

&lt;p&gt;The ecosystem being built around Wasm and the Component Model make it a very promising target for new programming languages especially if they build Component-native toolchains and take the most advantage of WASI, the &lt;a href=&#34;https://github.com/bytecodealliance/registry/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Warg&lt;/a&gt; registry protocol, Wasm-to-Wasm optimizers like &lt;a href=&#34;https://github.com/WebAssembly/binaryen&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Binaryen&lt;/a&gt;, and Wasm-based dev tools like &lt;a href=&#34;https://github.com/esoterra/wow&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wow&lt;/a&gt;. I created a new language called &lt;a href=&#34;https://github.com/esoterra/claw-lang&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Claw&lt;/a&gt; recently to demonstrate this and also provide an ideal &amp;ldquo;glue code&amp;rdquo; language for augmenting and testing existing Components.&lt;/p&gt;

&lt;p&gt;In this talk, I will
* explain what Wasm and Components are,
* summarize the state of the Wasm ecosystem,
* argue that language designers and developers should consider targetting Wasm,
* and give a live demo of Claw and Wow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Robin Brown is a co-chair of a Bytecode Alliance group that brings together programming language ecosystems and helps them create Wasm component tooling that feels native to their ecosystem, which is called the Guest Languages SIG. She is also the creator of the compile-to-component programming language Claw and the co-creator of the Warg protocol, which is an open source Wasm registry protocol with a focus on supply chain security, federation, and offline mirroring.&lt;/p&gt;

&lt;h2 id=&#34;may-17&#34;&gt;May 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zach Sisco&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hardware Decompilation: Recovering Abstraction in Digital Circuits&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; My research introduces the problem of &amp;ldquo;hardware decompilation&amp;rdquo;. Analogous to software decompilation, hardware decompilation is about analyzing a low-level artifact&amp;mdash;in this case a netlist, i.e., a graph of wires and logical gates representing a digital circuit&amp;mdash;in order to recover higher-level programming abstractions, and using those abstractions to generate code written in a hardware description language (HDL). The overall problem of hardware decompilation requires a number of pieces. In my initial paper, published at PLDI 2023, I focus on one specific piece of the puzzle: a technique called &amp;ldquo;hardware loop rerolling&amp;rdquo;. Hardware loop rerolling leverages clone detection and program synthesis techniques to identify repeated logic in netlists (such as would be synthesized from loops in the original HDL code) and reroll them into syntactic loops in the recovered HDL code. In this talk, I will introduce what hardware decompilation is, and why you would want to use a hardware decompiler. Then, I will describe my solution to the hardware loop rerolling problem, and give a preview of in-progress work tackling more aspects of hardware decompilation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zach Sisco is a PhD candidate at UC Santa Barbara. He is advised by Professors Jonathan Balkind and Ben Hardekopf. Zach&amp;rsquo;s research is about applying solver-aided programming techniques to problems in hardware design. His website is: &lt;a href=&#34;https://zsisco.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://zsisco.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2024)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2024wi/</link>
      <pubDate>Thu, 07 Dec 2023 18:02:29 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2024wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2024, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-12&#34;&gt;Jan. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Beta Ziliani&lt;/td&gt;
&lt;td&gt;Making monkeys and ducks behave with Crystal Lang&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-19&#34;&gt;Jan. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Talk rescheduled for &lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-26&#34;&gt;Jan. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Devashish Purandare&lt;/td&gt;
&lt;td&gt;Shimmer: Supercharging Adoption of Modern SSD Interfaces&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-2&#34;&gt;Feb. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Joe Cutler&lt;/td&gt;
&lt;td&gt;delta: ordered types for stream processing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Katherine Philip&lt;/td&gt;
&lt;td&gt;Formalizing Type-Directed Specialization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-16&#34;&gt;Feb. 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Laura Israel&lt;/td&gt;
&lt;td&gt;The Persistence of Past: A Demand Semantics for Mechanized Cost Analysis of Lazy Programs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-23&#34;&gt;Feb. 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;Don&amp;rsquo;t Let APIs Constrain Your Distributed Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-1&#34;&gt;March 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Karuna Grewal&lt;/td&gt;
&lt;td&gt;Expressive Policies for Microservice Networks&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-8&#34;&gt;March 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Abhiroop Sarkar&lt;/td&gt;
&lt;td&gt;HasTEE+ - Confidential Computing with Haskell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-15&#34;&gt;March 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Matthew C. Davis&lt;/td&gt;
&lt;td&gt;NaNofuzz to TestLoop: A Journey from Empirical to Theoretical Research (and back again)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;jan-12&#34;&gt;Jan. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Beta Ziliani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Making monkeys and ducks behave with Crystal Lang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In the zoo of programming languages there are two cute yet rather misbehaved animals, typically found in the Dynamic Languages section: the Duck Typing and the Monkey Patching.&lt;/p&gt;

&lt;p&gt;The Duck Typing is hardly seen.  You hear a ‚Äúquack!‚Äú, but you can‚Äôt easily tell if it‚Äôs coming from an actual duck, a parrot, or a recording.  Monkey Patching, like the name suggests, patches any existing creature to change their behavior.  It can even make a dog quack!&lt;/p&gt;

&lt;p&gt;While these two animals bring lots of joy, they are also quite dangerous when used in the wild, as they can bring unexpected behavior to the rest of the creatures.&lt;/p&gt;

&lt;p&gt;Crystal is a rarity in the Static Languages section that has Duck Typing and Monkey Patching.  Given the strong &amp;ndash; yet barely visible &amp;ndash; fences of types, it manages to properly contain these beasts.  In this talk I will present Crystal and provide a glimpse at how it manages to feel so dynamic while being safe and efficient.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Beta leads the development of the Crystal Programming Language and teaches about programming languages at Universidad Nacional de C√≥rdoba in Argentina.  With a recent past as a researcher in programming languages, he developed tools and theories for two very different languages: Coq and Lua.  He has no ducks nor monkeys, despite them being effective weapons against C√≥rdoba&amp;rsquo;s venomous scorpions.&lt;/p&gt;

&lt;h1 id=&#34;jan-19&#34;&gt;Jan. 19&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Rescheduled for &lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;jan-26&#34;&gt;Jan. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Devashish Purandare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Shimmer: Supercharging Adoption of Modern SSD Interfaces&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; While the demand for NAND-flash-based storage keeps growing, capacity increase comes at the cost of degradation in performance and device lifetime. Traditional storage abstractions exacerbate such degradation, increasing garbage collection overhead due to in-place updates. Even flash-optimized append-only systems suffer the overhead of interleaving unrelated data streams. Host-device coordination techniques allow the host to provide the device with hints, which help the SSD to ensure performance isolation across write streams and reduce garbage collection overhead by grouping data related by lifetime. However, such devices have seen limited adoption due to the difficulty of rewriting applications and filesystems and the impact on their stability, security, and portability in the face of changing interfaces.&lt;/p&gt;

&lt;p&gt;We present Shimmer, an all-userspace shim layer that enables host-device coordination with no change to the system or the application. Shimmer utilizes application insights to provide intelligent placement hints to any capable storage backend and can shield applications and filesystems from changing interfaces. We demonstrate Shimmer&amp;rsquo;s ease of adoption by enabling host-device coordination for popular IO intensive applications: RocksDB, WiredTiger and Cachelib. Shimmer improves write throughput by 20-90%, depending on the application over modern filesystems like f2fs and can match application-specific backends like ZenFs, offering up to 14√ó lower tail latency and reduced write amplification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dev is a PhD candidate researching storage systems, SSDs, and data management at the Center for Research in Storage and Systems, UC Santa Cruz. He works on systems that enable easier host-device coordination for performance and reliability improvements. His latest project, Shimmer, allows easy shim layers to generate and provide lifetime hints that improve the performance of log-structured systems on top of SSDs with no change to applications or operating systems.He will be graduating in March and is actively seeking full time opportunities.&lt;/p&gt;

&lt;h1 id=&#34;feb-2&#34;&gt;Feb. 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Joe Cutler&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; delta: ordered types for stream processing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present delta, a new language for building stream processing programs. Unlike other streaming languages which restrict the programmer to a small set of combinators, programs in delta are written as standard functional list programs, written as if they transform the entire input at once.  However, delta is equipped with a semantics which runs these list programs as stream programs, producing their outputs incrementally as inputs arrive.  To accomplish this, delta uses a novel ‚Äúordered‚Äù substructural type system to ensure that all well-typed programs can be executed incrementally. The type system also enforces further guarantees, ensuring that the programs are monotone ‚Äî they never ‚Äúretract‚Äù a previous output ‚Äî and that they are deterministic, even in the presence of parallel inputs. In the talk, I‚Äôll discuss the design of the delta type system, how it guarantees the above properties, and how it enables a radical new programming model for stream processing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Joe Cutler is a 3rd year PhD Student at The University of Pennsylvania, where he works with Benjamin Pierce on all things type systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-9&#34;&gt;Feb. 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Katherine Philip&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Formalizing Type-Directed Specialization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present a formal study of type-directed specialization, an implementation and optimization technique for implementing parametric polymorphism in programming languages. Type-directed specialization (also known as monomorphization) systematically eliminates polymorphic code by generating monomorphic copies, each specialized for a particular type. We focus on the full specialization of parametric polymorphic expressions in an ML-like language that uses the Hindley-Milner type system. We formalize this with a family of representation transformation functions that translate source language programs into a novel target language that is capable of binding the potentially infinite families of specialized functions generated by full specialization. A key contribution of this paper is to prove that these functions preserve typing for all well-typed source programs. Finally, we lay the groundwork for future study of semantics preservation and for the formalization of other kinds of specialization and representation transformations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Katherine is a PhD student at Portland State University, advised by Mark P. Jones. They are interested in the design and implementation of efficient languages for low-level systems development. Currently, they are working on the Habit programming language (&lt;a href=&#34;https://www.habit-lang.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.habit-lang.org/&lt;/a&gt;).&lt;/p&gt;

&lt;h1 id=&#34;feb-16&#34;&gt;Feb. 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Laura Israel&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The Persistence of Past: A Demand Semantics for Mechanized Cost Analysis of Lazy Programs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Lazy evaluation is a powerful tool that enables better compositionality and potentially better performance in functional programming, but it is challenging to analyze its computation cost. Existing works either require manually annotating sharing, or rely on separation logic to reason about heaps of mutable cells. In this paper, we propose a bidirectional demand semantics that allows for reasoning about the computation cost of lazy programs without relying on special program logics. To show the effectiveness of our approach, we apply the demand semantics to formally prove that Okasaki&amp;rsquo;s banker&amp;rsquo;s queue is both amortized and persistent using the Coq theorem prover. We also propose the reverse physicist&amp;rsquo;s method, a novel variant of the classical physicist&amp;rsquo;s method, which enables mechanized, modular and compositional reasoning about amortization and persistence with the demand semantics.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Laura Israel is a first-year doctoral student at Portland State University studying formal verification with Yao Li. She has a particular interest in complexity theory and its formalization in proof assistants. Laura developed a passing interest in theoretical CS while getting her BA in Psychology at Reed College, resulting in a stint in the tech industry, then culminating in her current research at PSU. When she&amp;rsquo;s not doing math thinly-veiled as computer science, you can find her hanging out with her cat Socks, running Dungeons and Dragons, or writing (and occasionally publishing) short stories.&lt;/p&gt;

&lt;h1 id=&#34;feb-23&#34;&gt;Feb. 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title&lt;/strong&gt;: Don&amp;rsquo;t Let APIs Constrain Your Distributed Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;: Large scale distributed applications frequently consist of compositions of independent systems communicating over RPC-like interfaces. Despite the familiar model they offer, RPCs constitute a low-level programming interface; just like an application programmer needs to be aware of how a computer executes their program when writing in something like C, they need to become distributed systems experts to correctly implement complex distributed application logic. Additionally, the shared-nothing model that underpins these systems as well as the hard boundaries established by the remote service interfaces introduce overheads in the hot path of applications and preclude end-to-end optimizations. As distribution becomes more pervasive, and as our understanding of the limitations of attempting to scale out computation over the network deepens, it is time to reimagine the role of infrastructure in orchestrating distribution and empowering domain experts with big data problems but not necessarily the distributed systems expertise to implement a bespoke system for their needs.&lt;/p&gt;

&lt;p&gt;We introduce Magpie, a distributed single-level store and runtime. Magpie, like Distributed Shared Memory systems before it, organizes application data in a unified global address space. Unlike previous systems, Magpie always co-locates a computation with its set of data dependencies, avoiding the coherence overheads that made DSM untenable. We accomplish this co-location through fine-grained data and code mobility, enabled by a programming model that allows users to write programs as compositions of local, location-independent functions, which the runtime is free to schedule anywhere in the cluster their data dependencies can be met. In this talk I will go over Magpie‚Äôs design, its programming model, and our experience using it to build distributed infrastructure and applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio&lt;/strong&gt;: Achilles is a third year PhD candidate at UCSC, working at the intersection of distributed systems, databases, and programming languages with Peter Alvaro. He &lt;a href=&#34;https://lsd.ucsc.edu/lsd-seminar/2021sp/#april-16&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;still cooks&lt;/a&gt; when he gets too frustrated by computers.&lt;/p&gt;

&lt;h1 id=&#34;march-1&#34;&gt;March 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Karuna Grewal&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Expressive Policies for Microservice Networks&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Microservice-based application deployments need to administer safety
properties while serving requests. However, today such properties can
be specified only in limited ways that can lead to overly permissive
policies and the potential for illegitimate flow of information across
microservices, or ad hoc policy implementations.&lt;/p&gt;

&lt;p&gt;We argue that a range of use cases require safety properties for the
flow of requests across the whole microservice network, rather than
only between adjacent hops. To begin specifying such expressive
policies, we propose a system for declaring and deploying service tree
policies. These policies are compiled down into declarative filters
that are inserted into microservice deployment manifests. We use a
light-weight dynamic monitor based enforcement mechanism, using ideas
from automata theory. Experiments with our preliminary prototype show
that we can capture a wide class of policies that we describe as case
studies.&lt;/p&gt;

&lt;p&gt;(This is a joint work with Brighten Godfrey from UIUC and Justin Hsu
from Cornell University that appeared at HotNets&amp;rsquo;23.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Karuna Grewal is a third year Ph.D. student in the Computer Science
department at Cornell University advised by Prof. Justin Hsu. Her
current research focus is to apply techniques from programming
languages and formal methods to distributed and networked systems with
a focus on security properties.&lt;/p&gt;

&lt;h1 id=&#34;march-8&#34;&gt;March 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Abhiroop Sarkar&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HasTEE+ - Confidential Computing with Haskell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This talk presents HasTEE+, a Domain-Specific Language in Haskell designed for seamless programming of Trusted Execution Environments (TEEs). HasTEE+ offers a high-level programming model that uses the Haskell-type system to compartmentalise confidential portions of a program within the TEE unit. It then allows the specification of Information Flow Control (IFC) policies and incorporates a dynamic mechanism for enforcing them. HasTEE+ also includes built-in support for remote attestation using the Intel RA-TLS protocol. The practicality of HasTEE+ was demonstrated through various practical case studies including a Federated Learning system and a Data Clean Room. I will conclude the talk by discussing potential research avenues for enhancing the security guarantees provided by HasTEE+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Abhiroop Sarkar is a final year PhD student at Chalmers University, Sweden. Defending his thesis at the end of March, his research involves improving systems security for both cloud and embedded environments using programming language techniques, particularly functional programming.&lt;/p&gt;

&lt;h1 id=&#34;march-15&#34;&gt;March 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Matthew C. Davis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; NaNofuzz to TestLoop: A Journey from Empirical to Theoretical Research (and back again)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software testing labor cost in the United States exceeded an estimated $47 billion in 2021. For 50 years, Automatic Test sUite Generators (ATUGs) have intended to help developers generate test suites. The vast majority of ATUGs have focused on effectiveness measures such as code coverage, mutants killed, and bugs elicited. But few ATUGs have focused on the developer&amp;rsquo;s experience. In this talk we discuss NaNofuzz, an ATUG that focuses on the developer&amp;rsquo;s experience, as well as TestLoop, a theoretical model of the developer&amp;rsquo;s test suite generation process. We describe ways in which our empirical ATUG research informs and refines our theoretical research &amp;ndash; and vice-versa.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Matthew C. Davis is a Software Engineering PhD student at Carnegie Mellon University‚Äôs School of Computer Science and is advised by Dr. Brad A. Myers and Dr. Joshua Sunshine. Matthew&amp;rsquo;s research focuses on interventions that improve the human ability to build and test useful software and is motivated by twenty years of experience as a software engineer and as a global technology director in industry, where he observed first-hand many ways in which developers encounter barriers to efficiently and effectively using various types of common software engineering tools.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023fa/</link>
      <pubDate>Fri, 11 Aug 2023 19:47:53 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-29&#34;&gt;Sept. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vikram Narayanan&lt;/td&gt;
&lt;td&gt;Towards fine-grained compartmentalization of operating system kernels&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-6&#34;&gt;Oct. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Nick Rioux&lt;/td&gt;
&lt;td&gt;Compositional &amp;amp; Scalable Programming in Granite&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-13&#34;&gt;Oct. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Harrison Goldstein&lt;/td&gt;
&lt;td&gt;Advancing Property-Based Testing in Theory and Practice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-20&#34;&gt;Oct. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Adrian Lehmann&lt;/td&gt;
&lt;td&gt;VyZX: Formal Verification of a Graphical Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-27&#34;&gt;Oct. 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Elaine Li&lt;/td&gt;
&lt;td&gt;Multiparty Session Type Projection and Subtyping with Automata&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-3&#34;&gt;Nov. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Karine Even-Mendoza&lt;/td&gt;
&lt;td&gt;GrayC: Greybox Fuzzing of Compilers and Analysers for C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-17&#34;&gt;Nov. 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Suha S. Hussain&lt;/td&gt;
&lt;td&gt;MLFiles: Using Input-Handling Bugs to Inject Backdoors Into Machine Learning Pipelines&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-1&#34;&gt;Dec. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kelly Kaoudis&lt;/td&gt;
&lt;td&gt;Systems security in practice: threat modelling at Trail of Bits&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-8&#34;&gt;Dec. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Susan Tan&lt;/td&gt;
&lt;td&gt;TULIPüå∑ : Transcompilation Undergoes LLVM-IR for Interactive Parallelization&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-29&#34;&gt;Sept. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  Vikram Narayanan&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Towards fine-grained compartmentalization of operating system kernels&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Commodity operating systems execute core kernel subsystems in a single
address space along with hundreds of dynamically loaded extensions and
device drivers. Lack of isolation within the kernel implies that a
vulnerability in any of the kernel subsystems or device drivers opens
a way to mount a successful attack on the entire kernel. Historically,
isolation within the kernel remained prohibitive due to the high cost
of hardware isolation primitives. Recent CPUs, however, bring a new
set of mechanisms. Extended page-table (EPT) switching with VM
functions and memory protection keys (MPKs) provide memory isolation
and invocations across boundaries of protection domains with overheads
comparable to system calls.&lt;/p&gt;

&lt;p&gt;I will talk about how we developed a collection of techniques for
lightweight isolation of privileged kernel code(LXDs and LVDs) that
demonstrates near-native performance of two (network, block)
high-performance device drivers. I will present KSplit, a framework
for isolating unmodified device drivers in a modern, full featured
kernel that performs automated analyses on the unmodified source code
of the kernel and the driver to identify shared state and
synchronization requirements for efficient isolation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vikram recently graduated with a PhD from the University of
Utah. His research interests are building secure operating system
kernels, and heterogeneous systems.&lt;/p&gt;

&lt;h1 id=&#34;oct-6&#34;&gt;Oct. 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Nick Rioux&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compositional &amp;amp; Scalable Programming in Granite&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Granite is a strict and untyped programming language under development with the
goal of enhancing functional programming along a number of axes.
It aims to provide a basis for general-purpose programming that is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compositional: It is easy to extend (mutually) recursive functions to
support new cases.&lt;/li&gt;
&lt;li&gt;Expressive: Programmers can work with both the rich data structures common
in functional programming as well as cyclic data more naturally supported by
Datalog.&lt;/li&gt;
&lt;li&gt;Scalable: Programs naturally incorporate parallelism in a manner reminiscent
of LVars. This should also extend to eventually consistent-by-design distributed
computation a la CRDTs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps surprisingly, these three aspects of language design are related:
Granite&amp;rsquo;s design is emerging from the observation that the key to achieving each
of the above-mentioned goals is a join-semilattice. Granite makes semilattice
structure a first-class language feature; we&amp;rsquo;ll see what this means by example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Nick is a PhD student at the University of Pennsylvania. He applies mathematical
concepts from abstract algebra to make it more practical for programmers to
break their code into smaller reusable components while also scaling their
programs across a distributed system.&lt;/p&gt;

&lt;h1 id=&#34;oct-13&#34;&gt;Oct. 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Harrison Goldstein&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Advancing Property-Based Testing in Theory and Practice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Property-based testing (PBT) is a testing methodology that allows users to write executable
specifications of programs and test those specifications with automatically generated program
inputs. PBT is well-documented as a power-tool for bug-finding, with success stories at companies
like DropBox, Volvo, and Amazon, but we think it has still not reached its full potential. Our group
has taken a user-centered approach to advancing PBT, talking to real developers and discovering the
challenges that they face when using it.&lt;/p&gt;

&lt;p&gt;I present two new abstractions for random data generators&amp;mdash;free generators and reflective
generators&amp;mdash;that help address some of these challenges. Free generators re-imagine generators as
&amp;ldquo;parsers of randomness.&amp;rdquo; They show that a generator is really a parser for sequences of random
choices, and this perspective suggests new generation techniques. Reflective generators build on
free generators, adding support for &amp;ldquo;backward&amp;rdquo; execution in which a generated value can be turned
back into the sequence of choices that produced it. Backward generator execution is the foundation
for a wealth of new algorithms, including ones for test-case &amp;ldquo;shrinking,&amp;rdquo; test-case mutation, and
example-based generator tuning.&lt;/p&gt;

&lt;p&gt;Moving forward, we plan to focus on usability: free and reflective generators should be easy for
developers to write, and they should make other parts of the PBT process easier as well. I discuss
future work in this direction.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Harry Goldstein is a Ph.D. candidate at the University of Pennsylvania, advised by professor
Benjamin Pierce. His work leverages techniques from both programming languages and human-computer
interaction to make tools for software testing more powerful and usable. You can find his
publication list, blog, and other information at &lt;a href=&#34;https://harrisongoldste.in&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://harrisongoldste.in&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;oct-20&#34;&gt;Oct. 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Adrian Lehmann&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; VyZX: Formal Verification of a Graphical Language&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Mathematical representations of graphs often resemble adjacency matrices or lists, representations that facilitate whiteboard reasoning and algorithm design. In the realm of proof assistants, inductive representations effectively define semantics for formal reasoning. This highlights a gap where algorithm design and proof assistants require a fundamentally different structure of graphs. To address this gap, we present VyZX, a verified library for reasoning about inductively defined graphical languages. These inductive constructs arise naturally from category theory definitions. A key goal for VyZX is to verify the ZX calculus, a graphical language for reasoning about categorical quantum mechanics. Used as a more general model than the standard quantum circuit model, the ZX calculus equips its construction ‚ÄúZX-diagrams‚Äù with a collection of diagrammatic rewrite rules that preserve the graph&amp;rsquo;s semantic interpretation. The ZX calculus has been shown to be useful for building quantum error correction, quantum compilers, and for general graphical reasoning. In VyZX using an initial set of rules proven through their semantics, we proceed to prove facts about the ZX calculus by only appealing to statements about the ZX calculus using standard proof assistant techniques. VyZX integrates easily with the proof engineer&amp;rsquo;s workflow through visualization, automation and verified conversion of quantum circuits to ZX diagrams.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Adrian Lehmann is a PhD student at the University of Chicago adivsed by John Reppy working with Robert Rand. His interests lie in programming languages: compilation, verification, and using PL for better software engineering. He‚Äôs currently exploring applying these techniques to quantum computing.&lt;/p&gt;

&lt;h1 id=&#34;oct-27&#34;&gt;Oct. 27&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Elaine Li&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Multiparty Session Type Projection and Subtyping with Automata&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Multiparty session types (MSTs) are a type-based approach to verifying communication protocols. Central to MSTs is a projection operator: a partial function that maps protocols represented as global types to correct-by-construction implementations for each participant, represented as a communicating state machine (CSM). Existing projection operators are syntactic in nature, and trade efficiency for completeness. In the first part of the talk, I will present the first projection operator that is sound and complete. I will highlight the automata-theoretic nature of our projection operator, which separates synthesis from checking implementability. For synthesis, we use a simple subset construction; for checking implementability, we present succinct conditions that summarize insights into the property of implementability. We use these conditions to show that MST implementability is PSPACE-complete.&lt;/p&gt;

&lt;p&gt;While our projection operator always computes a candidate implementation if one exists, it may not always be the best candidate. In the second part of the talk, I motivate the subtyping problem for MSTs through a series of examples. I then demonstrate how we can use our conditions from before to obtain decidability results for MST subtyping with unrestricted CSMs as implementation model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Elaine Li is a fourth year PhD student at New York University, working with Thomas Wies. She is interested in both the theory and practice of protocol verification, and her PhD research focuses on the theory of multiparty session types.&lt;/p&gt;

&lt;h1 id=&#34;nov-3&#34;&gt;Nov. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Karine Even-Mendoza&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; GrayC: Greybox Fuzzing of Compilers and Analysers for C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Fuzzing of compilers and code analysers has led to a large number of bugs being found and fixed in widely-used frameworks such as LLVM, GCC and Frama-C. Most such fuzzing techniques have taken a blackbox approach, with compilers and code analysers starting to become relatively immune to such fuzzers.&lt;/p&gt;

&lt;p&gt;In this talk, I will introduce a novel coverage-directed, mutation-based approach for fuzzing C compilers and code analysers inspired by the success of greybox fuzzing in other application domains. I will discuss the main challenge of applying mutation-based fuzzing in this context and present our solution: GrayC, a novel Greybox fuzzer for C compilers and analysers.&lt;/p&gt;

&lt;p&gt;Naive mutations often result in non-compilable programs, which hinders their ability to discover critical bugs affecting optimisation, analysis, and code generation routines. To address this, we have designed a novel greybox fuzzer for C compilers and analysers by developing a new set of mutations to target common C constructs, transforming fuzzed programs so that they produce meaningful output, allowing differential testing used as a test oracle, and paving the way for integrating fuzzer-generated programs into compiler and code analyser&amp;rsquo;s regression test suites.&lt;/p&gt;

&lt;p&gt;We have implemented our approach in GrayC, an open-source LibFuzzer-based tool. Our experiments demonstrate its superior coverage, particularly in compilers and analysers&amp;rsquo; middle and back-end stages, outperforming Clang-Fuzzer, PolyGlot, and similar LangFuzz techniques. Through GrayC, we have identified 30 confirmed bugs in compilers and code analysers and enriched the Clang/LLVM test suite with 24 simplified, coverage-enhancing the Clang/LLVM test suite, targeting 78 previously uncovered functions in the LLVM codebase.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Karine Even-Mendoza is a Lecturer in Systems and Programming Languages (CS) at King&amp;rsquo;s College London with a PhD in Computer Science from King&amp;rsquo;s College London. Before joining as a lecturer, she was a Research Associate in the Department of Computing at Imperial College London, where she worked in the Software Reliability Group (SRG) and Multicore Programming Group on compiler testing and software testing in general. Her PhD at King&amp;rsquo;s College London, in the SSY group, focused on model checking, SMT solving, and incremental verification for software. Before her PhD studies, she worked in several local and international software companies.&lt;/p&gt;

&lt;h1 id=&#34;nov-17&#34;&gt;Nov. 17&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Suha S. Hussain&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; MLFiles: Using Input-Handling Bugs to Inject Backdoors Into Machine Learning Pipelines&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The widespread use of machine learning (ML), especially in safety-critical applications,
necessitates robust security measures for ML pipelines. Prior research has demonstrated the
existence of model vulnerabilities, including model backdoors that can compromise the integrity
of ML pipelines. Although many backdoor attacks limit the attack surface to the model, ML
models are not standalone objects. These models are embedded in ML pipelines that involve
multiple interacting components and are built using a wide range of ML tools.
In this talk, I will discuss our investigation of input-handling bugs in ML tools as a vector for
injecting backdoors into ML pipelines. Input-handling bugs are central to the field of
language-theoretic security (LangSec), which advocates for the treatment of inputs as a formal
language in order to develop precise, minimalist input-handling code. Drawing from a LangSec
taxonomy of input-handling bugs, we systematically identified and exploited vulnerabilities with
ML model serialization in popular tools. This process enabled us to construct ML backdoors,
substantiating our claim. In the process, we engineered malicious artifacts, including polyglot
and ambiguous files, using ML model files; contributed to the fickling library; and formulated a
series of guidelines to provide actionable steps to ameliorate this issue. Our investigation brings
to light the risks posed by input-handling bugs in tools to the overall security of ML pipelines,
arguing for an approach that concurrently addresses software security issues in tools and model
vulnerabilities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Suha S. Hussain is a security engineer on the machine learning assurance team at Trail of Bits.
She has worked on projects such as the safetensors security audit and fickling. She received
her BS in Computer Science (with threads in people and theory) from Georgia Tech where she
also conducted research at the Institute for Information Security and Privacy. She previously
worked at the NYU Center for Cybersecurity and Vengo Labs.&lt;/p&gt;

&lt;h1 id=&#34;dec-1&#34;&gt;Dec. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kelly Kaoudis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Systems security in practice: threat modelling at Trail of Bits&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Every system user and engineer has a different threat model, and a different understanding of the systems and applications they use or work on. Failure to unify these bodies of knowledge leads to not sufficiently considering weaknesses of the system and threats to it; this leads to surprise when an attacker exploits these weaknesses, which leads to incident response (and sometimes also sadness). Holistic threat modelling informs and enables making good system-level security decisions to minimize potential attack vectors. During a threat modelling engagement, Trail of Bits aims to methodically enumerate as many in-scope, system-level risks and weaknesses as possible. &amp;ldquo;System-level&amp;rdquo; here means architectural, design-level, or operational gaps in the client&amp;rsquo;s security posture. We use concrete examples in the form of threat scenarios and findings to show the client (rather than tell them) the insufficiently applied security controls we have identified, and to illustrate the risk implications of the lack of those security controls.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some of the interesting findings we&amp;rsquo;ve uncovered during previous (published) threat modelling engagements. Using examples from engagement reports to motivate each step, I will walk through the threat modelling process at Trail of Bits, and also talk about how our process can be useful in academic security work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kelly Kaoudis is a senior security engineer in the Research practice at Trail of Bits. She is a tech lead for threat modelling engagements, and contributes to Trail&amp;rsquo;s academic and industry research projects including open source parser and file formats analysis tooling. Prior to Trail of Bits, Kelly was the tech lead for Twitter&amp;rsquo;s application security team, and a graduate student in the Networking and Security (NSR) group at University of Colorado Boulder with Prof. Eric Keller. She received an MS in computer science from University of Colorado - Boulder in 2015.&lt;/p&gt;

&lt;h1 id=&#34;dec-8&#34;&gt;Dec. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Susan Tan&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TULIPüå∑ : Transcompilation Undergoes LLVM-IR for Interactive Parallelization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The exploration of heterogeneous systems has given rise to various parallel programming models (PPMs). However, the preference of hardware vendors for specific PPMs requires developers to manage multiple implementations for the same kernels. This not only consumes additional time but also impedes the seamless integration of new features and algorithm optimizations. This can be mitigated by a transcompiler. As it focuses its optimizations on the Abstract Syntax Tree (AST) level, a traditional transcompile falls short due to the preservation of syntax and semantics, limiting the compiler&amp;rsquo;s ability to reason about dependences. To address this, we introduce TULIP, a framework that transcompiles CUDA programs into OpenMP code‚Äîtwo widely adopted PPMs for prevalent heterogeneous CPU+GPU systems. Operating at the Intermediate Representation (IR) level instead, TULIP opens up opportunities to use state-of-the-art automatic parallelization frameworks for enhanced code performance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a fifth-year Ph.D. student in the Liberty Research Group at Princeton University, working under the supervision of Prof. David I. August. My research focuses on automatic parallelization, with a particular interest in exploring how tools such as decompilers and transcompilers can derive benefits from and contribute to state-of-the-art parallelization frameworks. In my spare time, I engage in reading and photography, capturing moments for friends&amp;rsquo; special occasions.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023sp/</link>
      <pubDate>Tue, 28 Mar 2023 10:41:50 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-7&#34;&gt;April 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tomas Petricek&lt;/td&gt;
&lt;td&gt;Programming Systems Deserve a Theory Too!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-14&#34;&gt;April 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://people.ucsc.edu/~kymiller/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kyle Miller&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Informalizing formalized mathematics using the Lean theorem prover&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-21&#34;&gt;April 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yanwen Xu&lt;/td&gt;
&lt;td&gt;Using all the processors in your heterogeneous system: a case study for tree-based applications&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-28&#34;&gt;April 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tim Goodwin&lt;/td&gt;
&lt;td&gt;What goes wrong in serverless runtimes?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-5&#34;&gt;May 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yuka Ikarashi&lt;/td&gt;
&lt;td&gt;Exocompilation for productive programming of hardware accelerators&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-12&#34;&gt;May 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Graydon Hoare&lt;/td&gt;
&lt;td&gt;Vectorized Interpreters: MRT for PL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-19&#34;&gt;May 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Thomas Dickerson&lt;/td&gt;
&lt;td&gt;Fangorn: Making Immutable Trees Mutable and Wait-Free&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-26&#34;&gt;May 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;cancelled&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-2&#34;&gt;June 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Lovro Lugoviƒá&lt;/td&gt;
&lt;td&gt;Real-World Choreographic Programming&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-9&#34;&gt;June 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Priyanka Mondal&lt;/td&gt;
&lt;td&gt;Asynchrony and Choreographies&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;april-7&#34;&gt;April 7&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tomas Petricek&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming Systems Deserve a Theory Too!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What do Commodore 64 BASIC, Jupyter Notebooks and Flash have in common? They all include an uninteresting programming language, but are interesting when we view them as programming systems and think about how programmers interact with them to construct programs. We know very well how to study the theory of programming languages, but what can we say about programming systems?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tomas Petricek is an assistant professor Charles University. He is interested in stateful, interactive and graphical programming systems, new ways of thinking about programming that make it easier and more accessible, as well as history and philosophy of computing. Previously, he developed novel tools for data exploration and visualization, contributed to the F# language and type providers at Microsoft Research and obtained PhD from University of Cambridge for his work on coeffects, a theory of context-aware programming languages.&lt;/p&gt;

&lt;h2 id=&#34;april-14&#34;&gt;April 14&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://people.ucsc.edu/~kymiller/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kyle Miller&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Informalizing formalized mathematics using the Lean theorem prover&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; One of the applications of interactive theorem provers in pure mathematics is being able to produce machine-verified formal proofs. I will talk about a less-obvious application, which is using formalized mathematics to author interactive informal expositions. I will demonstrate a prototype of an &amp;ldquo;auto-informalization&amp;rdquo; system written in Lean that presents the reader with an interface to view proofs at a desired level of detail.  I will also discuss thoughts on the impact of such tools in mathematics. This is joint work with Patrick Massot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kyle Miller is a postdoc in the mathematics department at UCSC. His primary research interests are in knot theory and graph theory, and he is currently on leave to work with Patrick Massot at Universit√© Paris-Saclay in Orsay, France to pursue research in computer-formalized mathematics. Kyle is a contributor and maintainer for mathlib, the mathematical library for the Lean interactive theorem prover. In his spare time, he enjoys dreaming about PL designs and tinkering with compilers.&lt;/p&gt;

&lt;h2 id=&#34;april-21&#34;&gt;April 21&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yanwen Xu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Using all the processors in your heterogeneous system: a case study for tree-based applications&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Specialized processing units such as GPU/FPGA are widely adopted in heterogenous systems, e.g., in data centers and supercomputers.
However, another type of heterogeneous system - shared memory heterogeneous systems - often found in mobile SoCs, has received less attention, despite more and more die area consists of accelerators on these devices. In this talk, I will present a framework for accelerating tree-based applications in shared memory heterogeneous systems, such as those used in computer graphics and statistical learning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yanwen Xu is a third-year Ph.D. student in the computer science &amp;amp; engineering department at UCSC, advised by Professor Tyler Sorensen. His primary research interest is in heterogenous computing in edge devices, particularly developing novel compiler techinques to optimize the use of computing resources in these systems. Yanwen has collaborated with Princeton&amp;rsquo;s team on a DARPA-funded project, where he explored mapping heterogeneous workloads to emerging architectures.&lt;/p&gt;

&lt;h2 id=&#34;april-28&#34;&gt;April 28&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tim Goodwin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What goes wrong in serverless runtimes?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Serverless computing promises to drastically simplify the process of deploying and manging applications in the cloud. The paradigm involves dynamic autoscaling and &amp;ldquo;scale-to-zero&amp;rdquo; functionality, ensuring that applications consume only the compute resources they need to complete their work. Supporting these features reliably, however, requires a high level of complexity at the runtime level. In this talk, I will discuss some of the essential challenges in serverless platform design through a presentation of a recent bug study conducted on Knative, a popular, industrial-strength open-source serverless platform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tim Goodwin is a first-year Ph.D. student in the CSE department at UCSC, advised by Lindsey Kuper and Andrew Quinn. His research interests are in distributed systems and the abstractions used to build them. Recently, he has been exploring the programming challenges associated with emerging cloud-native technologies like serverless programming and Kubernetes.&lt;/p&gt;

&lt;h2 id=&#34;may-5&#34;&gt;May 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yuka Ikarashi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Exocompilation for productive programming of hardware accelerators&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; High-performance kernel libraries are critical to exploiting accelerators and specialized instructions in many applications. Because compilers are difficult to extend to support diverse and rapidly-evolving hardware targets, and automatic optimization is often insufficient to guarantee state-of-the-art performance, these libraries are commonly still coded and optimized by hand, at great expense, in low-level C and assembly. To better support development of high-performance libraries for specialized hardware, we propose a new programming language, Exo, based on the principle of exocompilation: externalizing target-specific code generation support and optimization policies to user-level code. Exo allows custom hardware instructions, specialized memories, and accelerator configuration state to be defined in user libraries. It builds on the idea of user scheduling to externalize hardware mapping and optimization decisions. Schedules are defined as composable rewrites within the language, and we develop a set of effect analyses which guarantee program equivalence and memory safety through these transformations. We show that Exo enables rapid development of state-of-the-art matrix-matrix multiply and convolutional neural network kernels, for both an embedded neural accelerator and x86 with AVX-512 extensions, in a few dozen lines of code each.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yuka Ikarashi is a PhD candidate at MIT CSAIL, advised by Jonathan Ragan-Kelley. She is interested in creating compiler systems and programming languages for real-world applications. She is a co-creator of the Exo programming language and has been a developer for other compiler frameworks such as Clang/LLVM and ROOT. She previously worked at Apple, Amazon, and CERN. She received Masason Foundation Fellowship and Funai Foundation Fellowship awards.&lt;/p&gt;

&lt;h2 id=&#34;may-12&#34;&gt;May 12&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Graydon Hoare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Vectorized Interpreters: MRT for PL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Conventional interpreters and compilers are two different
techniques for implementing programming languages. They each make
specific sets of compromises on various key pragmatic concerns. A
third, often-overlooked implementation technique exists called a
&amp;ldquo;vectorized interpreter&amp;rdquo; with a different and compelling set of
compromises. This talk will examine the technique in some depth,
making an &amp;ldquo;MRT&amp;rdquo; analogy that is hopefully illuminating (or at least an
amusing surprise).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Graydon Hoare is a systems programmer with a focus on programming
language design and implementation. He was the initial developer of
Rust, and has worked on numerous language toolchains, runtimes,
debuggers, profilers and other development tools over 25 years of
industrial work including Red Hat, Mozilla and Apple.&lt;/p&gt;

&lt;h2 id=&#34;may-19&#34;&gt;May 19&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Thomas Dickerson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Fangorn: Making Immutable Trees Mutable and Wait-Free&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We show how to implement a large class of wait-free operations on mutable trees by applying type-level rewrite rules to specifications for immutable versions of the same ADT.
Among the supported operations are efficient, linearizable, copy-on-write snapshots; thereby supporting consistent iteration and speculative updates.&lt;/p&gt;

&lt;p&gt;The transformation is achieved by executing each recursive step using the LLX and SCX primitives of Brown et al. (2013) and suspending each tail call into the structure of the tree itself (rather than relying on the mechanisms of the host programming language).
We bootstrap our operations on the root of the tree using a wait-free universal construction based on LLX/SCX.&lt;/p&gt;

&lt;p&gt;We also show how to extend the LLX/SCX primitives to allow control-flow operations to propagate correctly across thread boundaries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Thomas Dickerson is the Chief Science Officer (and a co-founder) at Geopipe, in Burlington, Vermont. Geopipe is a deep-tech startup using ML to parse the planet&amp;rsquo;s geospatial data and create simulation-ready environments from real-world locations. Previously, he did his PhD at Brown University where he was advised by Maurice Herlihy. His research interests are, broadly, applying a computational lens to interdisciplinary problems.&lt;/p&gt;

&lt;h2 id=&#34;may-26&#34;&gt;May 26&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;cancelled&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;june-2&#34;&gt;June 2&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Lovro Lugoviƒá&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Real-World Choreographic Programming&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a recent programming paradigm where the overall behaviour of a distributed system is programmed from a global viewpoint&amp;mdash;as a choreography between different participants (roles).
The choreography can then be automatically compiled (projected) to a correct implementation for each role.
This relieves the programmer from manually writing the separate send and receive actions performed by the roles, which simplifies development and avoids communication mismatches.&lt;/p&gt;

&lt;p&gt;However, the applicability of choreographic programming in the real world is still largely unexplored.
We carry out the first development of a widespread real-world protocol using choreographic programming, the Internet Relay Chat (IRC).
We show how we have dealt with IRC&amp;rsquo;s complex interaction patterns and the issue of interoperability with third-party software.
The development is based on Choral, an object-oriented higher-order choreographic programming language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Lovro Lugoviƒá is a computer science PhD student in the IMADA department at the University of Southern Denmark (SDU), advised by Fabrizio Montesi. His research interests are in distributed systems, concurrency theory, choreographic programming and programming languages.&lt;/p&gt;

&lt;h2 id=&#34;june-9&#34;&gt;June 9&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Priyanka Mondal&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Asynchrony and Choreographies&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically. It enables the programmers to write a centralized program (choreography) and compile it via endpoint projection into programs for each participating node in a distributed system. However, choreographic languages are typically synchronous, whereas most real-world systems have asynchronous communications. In this talk we will discuss how we can make a choreographic programming language support asynchronous communication by adding extra semantics to it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Priyanka Mondal is a PhD student in the Department of Computer Science &amp;amp; Engineering at UCSC. She is advised by Owen Arden and Ioannis Demertzis. Her research interests include language-based security, cryptography, and distributed systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023wi/</link>
      <pubDate>Tue, 20 Sep 2022 15:10:12 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-6&#34;&gt;Jan. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://msurbatovich.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Milijana Surbatovich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Designing Formally Correct Intermittent Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-13&#34;&gt;Jan. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;POPL SRC lightning talks (&lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt;, &lt;a href=&#34;https://nliittsc.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Nathan Liittschwager&lt;/a&gt;, &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-20&#34;&gt;Jan. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;cancelled&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-27&#34;&gt;Jan. 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://ducky64.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Richard Lin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Usable Programming for Building Things (with a focus on electronics)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-3&#34;&gt;Feb. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.nassi.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ike Nassi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The Practical Advantages of Distributed Virtual Machines and How They Work&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-10&#34;&gt;Feb. 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.dustinrichmond.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dustin Richmond&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;bPentimento: Data Remanence in Cloud FPGAs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-17&#34;&gt;Feb. 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://dslab.epfl.ch/people/iyer/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rishabh Iyer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Performance interfaces for Network Functions and beyond&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-24&#34;&gt;Feb. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://wintered.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dominik Winterer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Finding 1,700+ Bugs in the SMT Solvers Z3 and CVC5 in Three Years&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-3&#34;&gt;March 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Andrew Osterhout&lt;/td&gt;
&lt;td&gt;ROMP: A Random-walk Based Parallel Explicit-State Stateless Model Checker&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-10&#34;&gt;March 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jos√© Renau&lt;/td&gt;
&lt;td&gt;Live Hardware Development at UCSC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-17&#34;&gt;March 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://pl.cs.uni-kl.de/homepage/en/staff/AlbertSchimpf/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Albert Schimpf&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Set-Theoretic Types for Erlang&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;jan-6&#34;&gt;Jan. 6&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://msurbatovich.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Milijana Surbatovich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Designing Formally Correct Intermittent Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Batteryless, energy-harvesting devices (EHDs) are an emerging platform that
enables computing in remote, inaccessible environments. Instead of using a
battery, an EHD harvests energy from its environment into a buffer and operates
intermittently, only as energy is available. This operational cycle causes the
device to experience frequent, arbitrary power failures that make correct
programming difficult. To make progress, an intermittent system typically saves
execution state before power failure and restores it after the device reboots.
Incorrectly determining which state must be saved and where a save point should
be made causes software to exhibit memory and timing bugs that would not occur
on continuously powered program executions. As EHDs are envisioned to be
remotely-deployed, low-maintenance devices, programs must execute reliably,
without memory consistency or timing violations. Unfortunately, existing systems
rely on informal, undefined correctness notions, providing few correctness guarantees.&lt;/p&gt;

&lt;p&gt;In this talk, I present my work in designing formally correct intermittent
systems. I show how existing correctness notions are insufficient, leading to
unaddressed bugs. I then define formal correctness conditions for memory
consistency and timing properties on intermittent systems, using these
definitions to design enforcement mechanisms and abstractions programmers
can use to specify their desired properties. This work allows the development
of intermittent systems that meet specified guarantees of time and memory consistency,
improving reliability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Milijana Surbatovich is a final year PhD Candidate in the Electrical and Computer Engineering
Department at Carnegie Mellon University, co-advised by Professors Brandon Lucia and
Limin Jia. Her research interests are in applied formal methods, programming languages,
and systems for intermittent computing.
She is excited by research problems that require reasoning about correctness and
security across the architecture, system, and language stack.
Previously, she received an MS in ECE from CMU in 2020 while doing her PhD
and a BS in Computer Science from University of Rochester in 2017.&lt;/p&gt;

&lt;h2 id=&#34;jan-13&#34;&gt;Jan. 13&lt;/h2&gt;

&lt;p&gt;POPL SRC lightning talks (&lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt;, &lt;a href=&#34;https://nliittsc.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Nathan Liittschwager&lt;/a&gt;, &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;jan-20&#34;&gt;Jan. 20&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;cancelled&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;jan-27&#34;&gt;Jan. 27&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://ducky64.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Richard Lin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Usable Programming for Building Things (with a focus on electronics)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; While modern programming languages and development practices have made programming powerful yet still accessible to novices, the underlying mechanisms - high level of abstraction, encapsulation and re-use of expert knowledge, and automated correctness checks - can also be hugely beneficial to fields beyond software. For example, structuring board-level electronic circuit designs as code enables designers to write and re-use subcircuits that automate common calculations, while the expert knowledge that these encapsulate helps make design accessible to those with less in-depth knowledge.&lt;/p&gt;

&lt;p&gt;Yet, it&amp;rsquo;s not as simple as &amp;ldquo;boards&amp;hellip; but in code&amp;rdquo;: new tools must also be useful to, and usable by, existing designers. In this talk, I present my work on developing a hardware description language (HDL) system for electronics that simultaneously aims to be powerful for experts yet usable by all. I&amp;rsquo;ll go over the entire process, from understanding user needs through initial interview studies, to designing the core language and its abstractions, to building supporting tools that bridge this powerful textual design interface with the familiar graphical tools that are used by today&amp;rsquo;s engineers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I&amp;rsquo;m currently a postdoc at UC Los Angeles, and before that I received my PhD from UC Berkeley. My research interests focus on building open-source tools that bring the power of software engineering to electronics design, ultimately making custom device design possible for more people. In the past, I&amp;rsquo;ve worked on the Chisel HDL project, which brings modern software engineering practices to chip-level digital design and similarly focuses on open-source, usability, and practical adoption.&lt;/p&gt;

&lt;h2 id=&#34;feb-3&#34;&gt;Feb. 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.nassi.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ike Nassi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The Practical Advantages of Distributed Virtual Machines and How They Work&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I&amp;rsquo;ll describe a distributed virtual machine architecture.   The virtual machine aggregates multiple physical servers and runs them as if they were a single physical server running a single unmodified standard operating system which manages all the resources as if it were a single machine.  No changes to applications are required.&lt;/p&gt;

&lt;p&gt;The talk explains why creating this was difficult, but also why it&amp;rsquo;s not as difficult as many might perceive. It explains the concept of non-disruptive automatic dynamic adaptive computing using machine learning and introspection.  Particular emphasis is given to auto-scaling, automatic optimization, simplicity of adoption, and hardware evolution.  Along the way, some elegant solutions to new problems we hadn&amp;rsquo;t anticipated were addressed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Ike was the founder of TidalScale.  The team and the IP is now part of HPE.  Ike Nassi is an Adjunct Professor of Computer Science at UC Santa Cruz, and a Founding Trustee at the Computer History Museum. Previously, he was an Executive Vice President and Chief Scientist at SAP. Before TidalScale, Ike helped start three companies: Encore Computer Corporation building hierarchical strongly coherent shared memory symmetric multiprocessors (1984); InfoGear Technology, which developed both Internet appliances (including the first iPhone) and associated backend services (1996); and Firetide, an early  wireless mesh networking company (2000).&lt;/p&gt;

&lt;p&gt;He worked at Apple Computer where he was SVP for all software and a Corporate Officer, Visual Technology, and Digital Equipment Corporation. Dr. Nassi has been a Visiting Scholar at Stanford University, twice a Research Scientist at MIT, and a Visiting Scholar at University of California, Berkeley. He has served on the board of the Anita Borg Institute for Women and Technology, and the IEEE Computer Society Industry Advisory Board. He holds a PhD in Computer Science from Stony Brook University.&lt;/p&gt;

&lt;p&gt;He was awarded two certificates for Distinguished Service from the Department of Defense, one for his work on the design of the programming language Ada and one for his work on DARPA ISAT.  He is a Life Fellow of IEEE and a Life member of ACM.  He is named on 35 patents.&lt;/p&gt;

&lt;h2 id=&#34;feb-10&#34;&gt;Feb. 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.dustinrichmond.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dustin Richmond&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; bPentimento: Data Remanence in Cloud FPGAs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Cloud FPGAs strike an alluring balance between computational efficiency, energy efficiency, and cost. It is the flexibility of the FPGA architecture that enables these benefits, but that very same flexibility that exposes new security vulnerabilities. We show that a remote attacker can recover ‚ÄúFPGA pentimenti‚Äù ‚Äì long-removed secret data belonging to a prior user of a cloud FPGA. The sensitive data constituting an FPGA pentimento is an analog imprint from bias temperature instability (BTI) effects on the underlying transistors. We demonstrate how this slight degradation can be measured using a time-to-digital (TDC) converter when an adversary programs one into the target cloud FPGA. This technique allows an attacker to ascertain previously safe information on cloud FPGAs, even after it is no longer explicitly present. Notably, it can allow an attacker to (1) extract proprietary details from an encrypted FPGA design image available on the cloud marketplace and (2) recover information from a previous user of a cloud FPGA. We demonstrate the ability to extract design details and recover previous cloud FPGA user information on the cloud platform. Our experiments show that BTI degradation (burn-in) and recovery are measurable and constitute a security threat to commercial cloud FPGAs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dustin Richmond is an Assistant Professor of Computer Science and Engineering in the Baskin School of Engineering at UC Santa Cruz. Dustin completed his postdoc in the Bespoke Silicon Group at the Paul Allen School of Computer Science at the University of Washington, and earned his Ph.D. from the University of California, San Diego. His research interests are in the design of flexible and secure architectures that can generalize across applications, evolve with software, and dynamically adapt to changes in data. His prior work includes HammerBlade, a flexible supercomputer funded by DARPA; RIFFA: A Reconfigurable Interface for FPGA Accelerators, which won a Community Best Paper Award at the 2013 International Conference on Field-Programmable Logic; and contributions to the PYNQ project at Xilinx. He is an NSF Graduate Research Fellow and an ARCS Fellow. He won the Outstanding Community Leader Award from the UC San Diego Graduate Student Association, and the Excellence in Service and Leadership Award from the UC San Diego Computer Science and Engineering Department. Last, but not least, he also won the Best Social Hour Theme Award for teaching other students the basics of lock picking by locking all the Friday afternoon event food in metal boxes.&lt;/p&gt;

&lt;h2 id=&#34;feb-17&#34;&gt;Feb. 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://dslab.epfl.ch/people/iyer/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rishabh Iyer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Performance interfaces for Network Functions and beyond&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Modern programmers routinely use third-party code, and infrastructure operators deploy software they did not write. This would not be possible without semantic interfaces&amp;mdash;documentation, header files, specifications&amp;mdash;that succinctly describe what that third-party code does.&lt;/p&gt;

&lt;p&gt;In this talk, I will propose performance interfaces as a way to describe a system‚Äôs performance, akin to how a semantic interface describes its functionality. I will concretize this idea in the domain of network functions (NFs) and describe a tool (PIX) that automatically extracts simple, yet precise performance interfaces from NF implementations. Finally, I will show how developers and operators can use PIX-extracted  interfaces to identify performance regressions, diagnose and fix performance bugs and identify the latency impact of NIC offloads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Rishabh Iyer is a sixth year PhD student at EPFL working with George Candea and Katerina Argyraki. His research interests are centred around computer systems and networking although he can often be found dabbling with formal verification tools. Prior to joining EPFL, he received his bachelor&amp;rsquo;s degree from IIT Bombay in 2017.&lt;/p&gt;

&lt;h2 id=&#34;feb-24&#34;&gt;Feb. 24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://wintered.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dominik Winterer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Finding 1,700+ Bugs in the SMT Solvers Z3 and CVC5 in Three Years&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Satisfiability Modulo Theory (SMT) solvers are important tools for many
advances in programming languages, e.g., symbolic execution engines,
software model checkers, and program verifiers. SMT solvers&amp;rsquo; robustness
is crucial&amp;mdash;Incorrect results from SMT solvers can invalidate client
applications&amp;rsquo; results and lead to disasters in safety-critical domains.
Hence, the SMT community has undertaken great efforts to make SMT
solvers reliable. Despite this, SMT solvers are complex software and
still have latent bugs. Although various fuzzing campaigns have targeted
SMT solvers, most known critical bugs were exposed by client
applications of the solvers and not by fuzzers.&lt;/p&gt;

&lt;p&gt;We devised several general methods for stress-testing SMT solvers [&lt;a href=&#34;http://dl.acm.org/doi/abs/10.1145/3385412.3385985&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3428261&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;]. We
have been &lt;a href=&#34;http://testsmt.github.io&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;extensively stress-testing the two state-of-the-art SMT
solvers Z3 and CVC4&lt;/a&gt;. So far, we have found 1,700+ unique bugs in Z3
and CVC4&amp;mdash;1,200+ have already been fixed by the developers and 500+ are
critical soundness bugs. Our detected bugs are diverse, distributing
over almost every SMT-LIB logic and theory: Perhaps surprisingly, our
tools detected soundness bugs in linear arithmetic, bit vectors, and
uninterpreted functions, decidable logics widely believed to be stable.
The developers appreciated our effort by comments such as &amp;ldquo;great find&amp;rdquo;,
&amp;ldquo;excellent find&amp;rdquo; and &amp;ldquo;nice catch&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dominik Winterer is a fifth-year Ph.D. student advised by Prof.
Zhendong Su at ETH Zurich and a member of the AST lab. He is interested
in formal methods problems in Programming Languages and Software
Engineering. Dominik&amp;rsquo;s vision is to robustify modern formal methods
software through devising novel testing approaches. Dominik has been
awarded the PLDI distinguished paper award.&lt;/p&gt;

&lt;h2 id=&#34;march-3&#34;&gt;March 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Andrew Osterhout&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ROMP: A Random-walk Based Parallel Explicit-State Stateless Model Checker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Model checking via parallelized random walks is a way to
  get fast way to find bugs in models with huge statespaces.  This is
  largely due to not having to use a global has to monitor the
  progress of a normal BFS or DFS traversal of a statespace.  There
  however other ways to improve this performance even further with the
  use of heuristics statespace reductions, and figuring out when to
  cut your losses on a poor performing walks.  We take the first few
  steps into refining such methodologies by utilizing the Murphi model
  checking language and a simple multithreaded random walking
  generated model checker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Hello, I am Andrew Osterhout, I am a graduate of the
  University of Utah, currently working as a research assistant /
  research programmer under Ganesh Gopalakrishnan,  where I
  primarily work on verification systems for data race detection in
  GPUs and Model Checking based verification projects.  I currently
  live in Santa Cruz with my partner and work remotely.  I am
  currently working on a LLNL contract via the University of Utah for
  GPU race detection on AMD unified memory architectures, as well as
  shepherding the romp project form the side lines while I juggle grad
  school applications.&lt;/p&gt;

&lt;h2 id=&#34;march-10&#34;&gt;March 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jos√© Renau&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Live Hardware Development at UCSC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Prof. Renau will present the research effort by his team at UCSC. The talk focuses on open-source Live CHIP design flows to improve hardware design productivity. With a focus on 2 main areas: LiveHD and Pyrope.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LiveHD (&lt;a href=&#34;https://github.com/masc-ucsc/livehd&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/masc-ucsc/livehd&lt;/a&gt;) is hardware compiler with Verilog, Chisel, and Pyrope front-ends. The latest effort is compiler speed around fast structures and parallelization.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pyrope (&lt;a href=&#34;https://masc-ucsc.github.io/docs/pyrope/00-hwdesign/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://masc-ucsc.github.io/docs/pyrope/00-hwdesign/&lt;/a&gt;) is a new hardware description language. It has a modern syntax designed to be efficient and more approachable to non-hardware designers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jose Renau (&lt;a href=&#34;http://www.soe.ucsc.edu/~renau&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.soe.ucsc.edu/~renau&lt;/a&gt;) is a CSE department professor at University of California, Santa Cruz. His area of research is computer architecture, focusing on productive hardware design flows (Live Hardware Design Flow or LiveHD, architectural simulators like ESESC, new hardware description language like Pyrope, new design methodologies like Fluid Pipelines), out-of-order cores, and RISC-V verification. Past projects with Thread Level Speculation, infrared thermal measurements, power modeling, and design effort metrics/models. Prof. Renau has a Ph.D. in Computer Science from the University of Illinois at Urbana-Champaign. He is currently the IEEE TCMM Chair.&lt;/p&gt;

&lt;h2 id=&#34;march-17&#34;&gt;March 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://pl.cs.uni-kl.de/homepage/en/staff/AlbertSchimpf/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Albert Schimpf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Set-Theoretic Types for Erlang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Erlang is a functional programming language with dynamic typing. The
language offers great flexibility for destructing values through pattern
matching and dynamic type tests. Erlang also comes with a type language
supporting parametric polymorphism, equi-recursive types, as well as
union and a limited form of intersection types. However, type signatures
only serve as documentation, there is no check that a function body
conforms to its signature.&lt;/p&gt;

&lt;p&gt;Set-theoretic types and semantic subtyping fit Erlang&amp;rsquo;s feature set
very well. They allow expressing nearly all constructs of its type
language and provide means for statically checking type signatures.
This talk will give a brief overview of the history and capabilities of
set-theoretic types and how to apply it to an existing dynamically typed
language without or with only minor modifications to the code and the
challenges involved.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I‚Äôm a PhD student at the Department of Computer Science of the
University of Kaiserslautern, in the AG Softwaretechnik.&lt;/p&gt;

&lt;p&gt;My current research topic is applying Set-Theoretic Type Theory to a
currently dynamically-typed language called Erlang, which includes
defining an operational semantics for that language and designing and
implementing an efficient type checker.&lt;/p&gt;

&lt;p&gt;My previous work includes building efficient tools for verification,
mainly propositional satisfiablility and regular language inclusion
solvers, working on replicated distributed data stores and language
design for workflows.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022fa/</link>
      <pubDate>Fri, 09 Sep 2022 15:47:17 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2022, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Sept. 23&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Lab social event and introductions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-30&#34;&gt;Sept. 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://arquinn.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Andrew Quinn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Debugging the OmniTable Way&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-7&#34;&gt;Oct. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://people.cs.vt.edu/~litinghu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Liting Hu&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Stream Processing Systems for Emerging Trends&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-14&#34;&gt;Oct. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modeling and Testing for MicroBus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-21&#34;&gt;Oct. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.linkedin.com/in/tloridobotran/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tania Lorido Botran&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Powering data centers the smart way&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-28&#34;&gt;Oct. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://users.soe.ucsc.edu/~pmondal/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Priyanka Mondal&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Applying consensus and replication securely with FLAQR&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-4&#34;&gt;Nov. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~yahuis/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Yahui Song&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Automated Temporal Verification with Extended Regular Expressions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nov. 11&lt;/td&gt;
&lt;td&gt;No meeting (Veterans Day)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-18&#34;&gt;Nov. 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://abeln.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Abel Nieto&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modular Verification of Op-Based CRDTs in Separation Logic&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nov. 25&lt;/td&gt;
&lt;td&gt;No meeting (Thanksgiving)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-2&#34;&gt;Dec. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~ishitac/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ishita Chaturvedi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;GhOST: a GPU Out-of-Order Scheduling Technique&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-30&#34;&gt;Sept. 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://arquinn.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Andrew Quinn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Debugging the OmniTable way&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Debugging is time-consuming, accounting for roughly 50% of a developer&amp;rsquo;s time. To identify the cause of a failure, a developer usually tracks the state of their program as it executes on a failing input. Unfortunately, most debugging tools make it difficult for a developer to specify the program state that they wish to observe and computationally expensive to observe execution state. Moreover, existing work to improve our debugging tools often restrict the state that a developer can track by either exposing incomplete execution state or requiring manual instrumentation.&lt;/p&gt;

&lt;p&gt;In this talk, I will describe our new debugging approach based on the OmniTable abstraction, which captures all state reached during an execution as a large queryable data table. Our query model built around the OmniTable abstraction supports SQL to simplify debugging without restricting the state that a developer can observe: I‚Äôll show that OmniTable debugging queries are more succinct than equivalent logic specified using existing tools.&lt;/p&gt;

&lt;p&gt;Then, I‚Äôll describe how our prototype, SteamDrill, accelerates debugging by taking advantage of how an OmniTable decouples debugging logic from the original execution. Namely, the system employs lazy materialization: it uses deterministic record/replay to store the execution associated with each OmniTable and resolves queries by inspecting replay executions. It employs a novel multi-replay strategy that partitions query resolution across multiple replays and a parallel resolution strategy that simultaneously observes state at multiple points-in-time. I‚Äôll show that SteamDrill queries are an order-of-magnitude faster than existing debugging tools.&lt;/p&gt;

&lt;h1 id=&#34;oct-7&#34;&gt;Oct. 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://people.cs.vt.edu/~litinghu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Liting Hu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Stream Processing Systems for Emerging Trends&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Stream processing is proposed and popularized as a ‚Äútechnology like Hadoop but can give you results faster‚Äù, which lets users query a continuous data stream and quickly get results within a very short time period from the time of receiving the data. For that reason, stream processing technology has become a critical building block of many applications, such as making business decisions from marketing streams, identifying spam campaigns from social network streams, predicting tornados and storms from radar streams, and analyzing genomes in different labs and countries to track the sources of a potential epidemic. However, state-of-art solutions have dominantly centered around stateless stream processing, leaving another urgent trend‚Äîstateful stream processing‚Äîmuch less explored. A driving need is that the future stream applications need to store and update state along with their processing, and process live data streams in a timely fashion from massive and geo-distributed data sets. In this talk, I will present a next-generation geo-distributed scalable stateful stream processing system. (1) At the architecture layer, I will introduce a decentralized ‚Äúmany masters/many workers‚Äù architecture that improves the scalability of stream processing systems. (2) At the mechanism layer, I will present a fragment-based parallel recovery mechanism that recovers large distributed states by leveraging erasure codes. Finally, I will outline the emerging trends for developing stream processing systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Liting Hu received her Ph.D. degree in computer science from Georgia Institute of Technology in 2016. She served as assistant professor of computer science at Virginia Tech in the 2021‚Äì22 academic year. Before that, she served as assistant professor in the school of computing and information sciences at Florida International University from 2017 to 2021. Liting conducts research on experimental computer systems, including stream processing systems, cloud and edge computing, distributed systems, and operating systems virtualization. Liting has received an NSF CAREER Award, an NSF SPX Award, an NSF OAC Award, a Meta Faculty Research Award, and a Cyber Florida Seed Award.&lt;/p&gt;

&lt;h1 id=&#34;oct-14&#34;&gt;Oct. 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modeling and Testing for MicroBus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; MicroBus is a newly developed replication service at AWS that provides consistency, durability, and fault tolerance guarantees. Both modeling and testing have been employed to ensure its correctness and have shown some success. Nevertheless, they all have shortcomings, with modeling not connected with the implementation and testing only covering limited scenarios. To solve this, we propose model-based testing as a hybrid approach that combines the best of the two worlds.&lt;/p&gt;

&lt;p&gt;In this talk, I will first give a gentle introduction to the MicroBus protocol/implementation and the pros and cons of modeling and testing. Then I will explain the model-based testing approach and the benefits it brings on to the table.&lt;/p&gt;

&lt;p&gt;(This project was done during my internship in the Automated Reasoning Group at AWS summer 2022)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Gan Shen is a 3rd-year PhD student at UC Santa Cruz, working with Prof. Lindsey Kuper in the LSD lab. His research area is programming language theory, in particular, how to design new programming tools/abstractions that facilitate software development.&lt;/p&gt;

&lt;h1 id=&#34;oct-21&#34;&gt;Oct. 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.linkedin.com/in/tloridobotran/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tania Lorido Botran&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Powering data centers the smart way&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Infrastructure powering current workloads is very
  heterogeneous: central data centers with various hardware
  accelerators, edge data centers with constraint resources and a
  variety of client devices with different capabilities. Orchestrating
  all these players can be a challenge and this talk will touch on how
  ML (or DL) can actually help. First, we will deep-dive into two
  projects: we will explore the use of Reinforcement learning for
  optimal container placement in edge data centers, and also visit an
  unsupervised approach for anomaly detection in containers, in
  particular, the noisy neighbor effect. After that, we will briefly
  learn about some on-going projects around autoscaling for ML
  pipelines, performance degradation detection in serverless
  functions, bottleneck detection with GANs and high-level
  sustainability scores for latency sensitive/critical tasks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dr. Tania Lorido-Botran is a Research Scientist at
  Roblox. Prior to that, she worked at Microsoft and the Pacific
  Northwest National Laboratory. During her PhD, she had the
  opportunity to spend one year at Rice University and also did two
  internships at VMware and HP Labs. Dr. Lorido Botran received her
  PhD from the University of Deusto in Spain with a Cum Laude
  distinction, and her master‚Äôs degree in Distributed systems from
  University of the Basque Country with a highest marks
  distinction. Her current research interests span across ML for
  systems, data center sustainability and fault-tolerance.&lt;/p&gt;

&lt;h1 id=&#34;oct-28&#34;&gt;Oct. 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://users.soe.ucsc.edu/~pmondal/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Priyanka Mondal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Applying consensus and replication securely with FLAQR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Availability is crucial to the security of distributed systems, but guaranteeing availability is hard, especially when
participants in the system may act maliciously. Quorum replication protocols provide both integrity and availability: data and computation
is replicated at multiple independent hosts, and a quorum of these hosts must agree on the output of all operations applied to the data.
Unfortunately, these protocols have high overhead and can be difficult to calibrate for a specific application‚Äôs needs. Ideally, developers could
use highlevel abstractions for consensus and replication to write fault tolerant code that is secure by construction. This paper presents
Flow-Limited Authorization for Quorum Replication (FLAQR), a core calculus for building distributed applications with heterogeneous
quorum replication protocols while enforcing end-to-end information security. Our type system ensures that well-typed FLAQR programs cannot
fail (experience an unrecoverable error) in ways that violate their typelevel specifications. We present noninterference theorems that characterize
FLAQR‚Äôs confidentiality, integrity, and availability in the presence of consensus, replication, and failures, as well as a liveness theorem for the class of majority quorum protocols under a bounded number of faults.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Priyanka Mondal is a PhD student at the University of California Santa Cruz, where she is supervised by Professor Owen Arden and Professor Ioannis Demertzis. Her research areas include Applied Cryptography, Programming Languages and Security in Distributed Systems. Prior to joining UCSC she worked as a software engineer at Citrix R&amp;amp;D Bangalore.&lt;/p&gt;

&lt;h1 id=&#34;nov-4&#34;&gt;Nov. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.comp.nus.edu.sg/~yahuis/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Yahui Song&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Automated Temporal Verification with Extended Regular Expressions&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Existing approaches to temporal verification have either sacrificed modularity in favor of achieving automation or vice-versa. To exploit the best of both worlds, we present a new framework to ensure temporal properties via Hoare-style verifiers and term rewriting systems (TRSs).&lt;/p&gt;

&lt;p&gt;The leading technique of temporal verification is automata-based model checking, which has possible insufficiencies: (i) it requires a manual modeling stage and needs to be bounded when encountering non-terminating traces; (ii) to conveniently deploy existing inclusion-checkers for automata, the expressiveness power is limited by the finite-state automata; and (iii) there is always a gap between the verified logic and the actual implementation from the program.&lt;/p&gt;

&lt;p&gt;To tackle these issues, we propose a framework that conducts local temporal verification, which leads to a modular and compositional verification strategy, where temporal reasoning can be combined to reason about the overall program. Meanwhile, we propose various effect logics to be the temporal specification languages, which are essentially extended regular expressions (REs), pushing the expressiveness boundary of the most deployed linear temporal logic (LTL). Furthermore, the proposed framework devises purely algebraic TRS to check the inclusions for the novel logics, avoiding the complex translation into automata.&lt;/p&gt;

&lt;p&gt;We demonstrate the applicability of the proposed framework and various REs-based temporal logics in different domains; presents the corresponding prototype systems, case studies, experimental results, and necessary proofs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yahui Song is a 5th year PhD Student at the National University of Singapore (NUS), supervised by Associate Professor Chin Wei Ngan. Her interests are automated program verification and programming language design. Her current works are dedicated to more expressive and efficient temporal verification.&lt;/p&gt;

&lt;h1 id=&#34;nov-18&#34;&gt;Nov. 18&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://abeln.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Abel Nieto&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular Verification of Op-Based CRDTs in Separation Logic&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Commutative Replicated Data Types (CRDTs) are a family of distributed data structures where all operations are designed to commute, so that replica states eventually converge. Additionally, CRDTs require that operations be propagated between replicas in causal order. This talk presents a framework for verifying safety properties of OCaml CRDT implementations using separation logic. The framework consists of two libraries. One implements a Reliable Causal Broadcast (RCB) protocol so that replicas can exchange messages in causal order. A second OpLib library then uses RCB to export a CRDT builder interface that simplifies the creation (and correctness proofs) of new CRDTs. OpLib allows clients to implement new CRDTs as purely-functional data structures, without having to reason about network operations, concurrency control and mutable state, and without having to re-implement causal broadcast each time. Using OpLib, we have implemented 12 sample CRDTs from the literature, including multiple versions of replicated registers and sets, as well as two CRDT combinators for products and maps. Our proofs are conducted in the Aneris distributed separation logic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I&amp;rsquo;m a 3rd (and final) year PhD student at Aarhus University, working with Lars Birkedal on verification of distributed systems using the Aneris distributed separation logic.  In particular, my work focuses on reasoning about systems that are highly-available but weakly consistent.&lt;/p&gt;

&lt;h1 id=&#34;dec-2&#34;&gt;Dec. 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ishita Chaturvedi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; GhOST: a GPU Out-of-Order Scheduling Technique&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Despite supporting fast context switching among many available threads to hide latency, GPU applications still suffer from stalls. To reduce these stalls, researchers have proposed several out-of-order (OoO) execution methods for GPUs. While these techniques improve performance, they use complex hardware to support register renaming, memory instruction reordering, or make invasive changes to the ISA to enable the compiler to provide hints to the hardware. In this talk, I will present GhOST, the first cost-effective OoO technique for GPUs. In an in-order GPU, a warp scheduler selects a single instruction to issue by considering only the oldest instruction from each context. GhOST introduces OoO execution by having the warp scheduler instead consider the instruction from each context‚Äôs instruction buffer deemed most likely to issue, while preserving sequential semantics. The architecture of GhOST allows it to elide register renaming and reordering memory instructions in the instruction buffer, without sacrificing performance. Thus, GhOST executes memory instructions sequentially, removing any need for dependence analysis. Since GhOST is a hardware only technique, which makes no modifications to the ISA, it can run binaries directly compiled using CUDA for all benchmarks. On the Nvidia Titan V (T) and RTX 2060 Super &amp;reg; GPUs, GhOST delivers 20.0% (T) and 21.8% &amp;reg; geomean speedup across 30 benchmarks, with a 0.05% increase in area. As future work, we will look at using the compiler to reorder instructions to further boost the OoO performance of GhOST.~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Ishita Chaturvedi is a third-year Ph.D. student at Princeton University, working with Prof. David August in the Liberty Research group. Her research interests lie in computer architecture and high-performance computing. More specifically, she is working on efficient out-of-order execution on GPUs.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022sp/</link>
      <pubDate>Wed, 23 Mar 2022 10:27:25 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-1&#34;&gt;April 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Olivia Hsu&lt;/td&gt;
&lt;td&gt;Compilation of Sparse Array Programming Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-8&#34;&gt;April 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Suyash Gupta&lt;/td&gt;
&lt;td&gt;Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-15&#34;&gt;April 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Amanda Liu&lt;/td&gt;
&lt;td&gt;Verified Tensor-Program Optimization Via High-Level Scheduling Rewrites&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-22&#34;&gt;April 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Will Crichton&lt;/td&gt;
&lt;td&gt;Modular Information Flow Through Ownership&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-29&#34;&gt;April 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Slim Lim and Geoffrey Litt&lt;/td&gt;
&lt;td&gt;Peritext: A CRDT for Collaborative Rich Text Editing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-6&#34;&gt;May 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Asta Halkj√¶r From&lt;/td&gt;
&lt;td&gt;A Naive Prover for First-Order Logic Formalized in Isabelle/HOL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-13&#34;&gt;May 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Farid Zakaria&lt;/td&gt;
&lt;td&gt;Reproducibility is hard: Insights and improvements at the bottom of the stack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-20&#34;&gt;May 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Michael Coblenz&lt;/td&gt;
&lt;td&gt;Squashing Bugs and Empowering Programmers with User-Centered Programming Language Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-27&#34;&gt;May 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Douglas Creager&lt;/td&gt;
&lt;td&gt;Incremental, zero-config Code Navigation using stack graphs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-3&#34;&gt;June 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yao Li&lt;/td&gt;
&lt;td&gt;Program Adverbs and Tl√∂n Embeddings&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;april-1&#34;&gt;April 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Olivia Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compilation of Sparse Array Programming Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This talk explains how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. This talk describes our compiler strategy, which generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions. We then show how to compile these iteration spaces to efficient code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Olivia is a computer science PhD student at Stanford University advised by Professor Kunle Olukotun and Professor Fredrik Kjolstad. She currently works on mapping sparse applications to domain-specific architectures, reconfigurable dataflow hardware, and accelerators through the TACO compiler. Her research interests broadly include computer architecture, computer and programming systems, compilers, programming models and languages, and digital circuits/VLSI.&lt;/p&gt;

&lt;h1 id=&#34;april-8&#34;&gt;April 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Suyash Gupta&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Since the introduction of Bitcoin‚Äîthe first widespread application driven by blockchains‚Äîthe interest in the design of blockchain-based applications has increased tremendously. At the core of these blockchain applications are consensus protocols that aim at securely replicating a client request among all replicas, even if some replicas are Byzantine faulty. Unfortunately, modern consensus protocols either yield low throughput or face design limitations.
In this work, we present the design of three consensus protocols that facilitate efficient consensus among the replicas. Our protocols help to scale consensus through the principles of phase-reduction, parallelization, and geo-scale clustering while ensuring no compromise in fault-tolerance. Further, we believe that the focus on consensus protocols is only one-side of the story. Specifically, we present the design of a well-crafted permissioned blockchain fabric (ResilientDB) that can help even a slow consensus protocol outperform a faster protocol. Our results indicate that it is easy to scale BFT protocols to hundreds of replicas and achieve throughputs of the order 350K txns/s.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Suyash Gupta is a postdoctoral researcher at the RISELab, University of California, Berkeley. He is also the Lead Architect of ResilientDB fabric. Prior to joining RISELab, he received his Ph.D. degree from University of California, Davis. He also holds two Master of Science degrees; one from Purdue University and another from Indian Institute of Technology Madras. His current research focuses on attaining safe and efficient, fault tolerant distributed consensus and communication. He has also co-authored a book on fault-tolerant distributed transaction processing at Morgan &amp;amp; Claypool. In his free time, Suyash likes to code and has won awards at several hackathons.&lt;/p&gt;

&lt;h1 id=&#34;april-15&#34;&gt;April 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Amanda Liu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Verified Tensor-Program Optimization Via High-Level Scheduling Rewrites&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present a lightweight Coq framework for optimizing tensor kernels written in a pure, functional array language. Optimizations rely on user scheduling using a series of verified, semantics-preserving rewrites. Unusually for compilation targeting imperative code with arrays and nested loops, all rewrites are source-to-source within a purely functional language. Our language comprises a set of core constructs for expressing high-level computation detail and a set of what we call reshape operators, which can be derived from core constructs but trigger low-level decisions about storage patterns and ordering. We demonstrate that not only is this system capable of deriving the optimizations of existing state-of-the-art languages like Halide and generating comparably performant code, it is also able to schedule a family of useful program transformations beyond what is reachable in Halide.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Amanda Liu is a second year PhD student working with Prof. Adam Chlipala and Prof. Jonathan Ragan-Kelley. Her interests are using formal methods and programming languages to develop verified, principled methods for writing high-performance systems.&lt;/p&gt;

&lt;h1 id=&#34;april-22&#34;&gt;April 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Will Crichton&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular Information Flow Through Ownership&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Statically analyzing information flow, or how data influences other data within a program, is a challenging task in imperative languages. Analyzing pointers and mutations requires access to a program&amp;rsquo;s complete source. However, programs often use pre-compiled dependencies where only type signatures are available. We demonstrate that ownership types can be used to soundly and precisely analyze information flow through function calls given only their type signature. From this insight, we built Flowistry, a system for analyzing information flow in Rust, an ownership-based language. In this talk, I will describe how Flowistry works, how we prove its soundness, and how we show that the ownership-based modular approximation does not lose much precision versus a whole-program analysis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Will Crichton is a 6th year PhD student at Stanford University advised by Profs. Pat Hanrahan and Maneesh Agrawala. His research combines cognitive psychology and programming language theory to understand how people program, and to design better tools for programmers.&lt;/p&gt;

&lt;h1 id=&#34;april-29&#34;&gt;April 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speakers:&lt;/strong&gt; Slim Lim and Geoffrey Litt&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Peritext: A CRDT for Collaborative Rich Text Editing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Conflict-Free Replicated Data Types (CRDTs) support decentralized collaborative editing of shared data, enabling peer-to-peer sharing and flexible branching and merging workflows. While there is extensive work on CRDTs for plain text, much less is known about CRDTs for rich text with formatting. No algorithms have been published, and existing open-source implementations do not always preserve user intent. In this talk, we describe a model of intent preservation in rich text editing, developed through a series of concurrent editing scenarios. We then describe Peritext, a CRDT algorithm for rich text that satisfies the criteria of our model. The key idea is to store formatting spans alongside the plaintext character sequence, linked to a stable identifier for the first and last character of each span, and then to derive the final formatted text from these spans in a deterministic way that ensures concurrent operations commute.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bios:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Slim Lim is a first-year PhD student at UC Berkeley studying the intersection of programming languages and human-computer interaction. She is particularly interested in type systems for UI programming and UI programming for type systems. Previously she worked as a software engineer developing collaborative text editing features. Even more previously, she researched semantic tooling for Cascading Style Sheets, culminating in the Inactive CSS inspection feature in Firefox 70.&lt;/p&gt;

&lt;p&gt;Geoffrey Litt is a third-year PhD student at MIT in HCI, researching end-user programming and local-first collaboration. His recent research interests include powering UIs with a malleable client-side database, and managing schema evolution in distributed systems&lt;/p&gt;

&lt;h1 id=&#34;may-6&#34;&gt;May 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Asta Halkj√¶r From&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Naive Prover for First-Order Logic Formalized in Isabelle/HOL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When using sequent calculus to prove a formula in classical first-order logic by hand, we may rely on our
intuition to pick the right sequence of rule applications, choose the most useful instantiations of variables
and so on. In implementing a prover to do so, we must very carefully ensure that the mechanical process
always finds a proof for a provable formula. This can be intricate and proving that the crafted algorithm
lives up to expectations can be even more challenging, especially in a formalized setting. To mitigate all
this, we may instead rely on a fair stream of all possible rule applications to all possible formulas. Such a
stream works as an oracle, telling us exactly which rule to apply to which formula, resulting in a very
simple prover. In this talk, I present a prover based on this technique, with formalized soundness and
completeness proofs in the proof assistant Isabelle/HOL.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Asta is a 3rd and final year PhD student in computer science and logic at the Technical University of Denmark where she is advised by J√∏rgen Villadsen and Nina Gierasimczuk.  She works on using proof assistants, especially Isabelle/HOL, to develop and formalize results in logic and is also interested in the pedagogical benefits of using interactive theorem provers in teaching.  She is the author of multiple entries in the Archive of Formal Proofs.&lt;/p&gt;

&lt;h1 id=&#34;may-13&#34;&gt;May 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Farid Zakaria&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Reproducibility is hard: Insights and improvements at the bottom of the stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; One of the fundamental data management units within a
Linux system are shared object files with which processes dynamically
link to at startup. The mechanism and approach to dynamic linking is
becoming increasingly inadequate for complex systems because of the
lack of data management principles. Novel software packaging models,
such as Nix, have emerged and are becoming increasingly popular to try
to tame the chaos induced by the Filesystem Hierarchy Standard but
suffer from limitations of a simplistic schema. Restricted to a
minimal schema that only allows modification of a list of directory
paths to modify the search query, the resolution of needed
dependencies can quickly become prohibitively costly. Shrinkwrap is a
tool that when used within hermetic packaging models such as Nix,
embosses the required dependencies to fixed locations avoid repetitive
lookups by storing the absolute paths of the needed dependencies. This
ability to have queries cached is currently missing from these
increasingly popular store-based distributions and has meaningful
improvements on startup times by up to 35x.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Farid Zakaria is a 2nd year PhD student at University of California
Santa Cruz and is advised by Dr. Carlos Maltzhan. He is currently
looking into opportunities to improve reproducibility of software,
especially deeper in the software stack. He is an active member of the
NixOS community and his research areas include linkers, build systems
and operating systems.&lt;/p&gt;

&lt;h1 id=&#34;may-20&#34;&gt;May 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Michael Coblenz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Squashing Bugs and Empowering Programmers with User-Centered Programming Language Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Programming languages are simultaneously formal systems and user interfaces with which programmers work. Unfortunately, programmers have a hard time writing safe software: serious bugs and security vulnerabilities are common. In many cases, however, languages with strong safety guarantees have been hard to use. In this talk, I‚Äôll discuss user-centered design methods I developed to help language designers create languages that are easier to use. I‚Äôll show how I created and evaluated Obsidian, a new smart contract language that uses a linear type system, and Bronze, a new garbage collector for Rust. I found that programmers are more effective when using the resulting languages than when using prior languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Michael Coblenz is a Basili Postdoctoral Fellow at the University of Maryland. Michael developed the PLIERS method, which integrates user-centered methods into the design process for safe programming languages. He created Glacier, an immutability system for Java; Obsidian, a strongly-typed language for smart contracts; and Bronze, a garbage collector that improves usability of Rust. He holds a Ph.D. in computer science from Carnegie Mellon University. Previously, he was a Senior Software Engineer at Apple. His work, which is at the intersection of programming languages, software engineering, and human-computer interaction research, has been published at OOPSLA, TOPLAS, ICSE, and TOCHI.&lt;/p&gt;

&lt;h1 id=&#34;may-27&#34;&gt;May 27&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Douglas Creager&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Incremental, zero-config Code Navigation using stack graphs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Exploring a large or unfamiliar codebase can be tricky. Code Navigation features like ‚Äújump to definition‚Äù and ‚Äúfind all references‚Äù let you discover how different pieces of code relate to each other. To power these features, we need to extract lists of symbols from the code, and describe the language-specific rules for how those symbols relate to each other.&lt;/p&gt;

&lt;p&gt;It‚Äôs difficult to add Code Nav to a large hosted service like GitHub, where we must support hundreds of programming languages, hundreds of millions of repositories, and petabytes of history. At this scale, we have a different set of design constraints than a local IDE. We need our data extraction to be incremental, so that we can reuse previous results for files that haven‚Äôt changed in a newly pushed commit, saving both compute and storage costs. And to support cross-repo lookups, it should require zero configuration ‚Äî repo owners should not have to set up anything manually to activate the feature.&lt;/p&gt;

&lt;p&gt;In this talk I‚Äôll describe stack graphs, which use a graphical notation to define the name binding rules for a programming language. They work equally well for dynamic languages like Python and JavaScript, and for static languages like Go and Java. Our solution is fast ‚Äî processing most commits within seconds of us receiving your push. It does not require setting up a CI job, or tapping into a project-specific build process. And it is open-source, building on the tree-sitter project‚Äôs existing ecosystem of language tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Douglas Creager manages the Semantic Code team at GitHub. We apply academic programming language research to build productivity tools that can operate on &lt;em&gt;all&lt;/em&gt; of the code hosted on GitHub. Our goal is to make it easier for developers and maintainers to understand what their code does, and how other developers use it.&lt;/p&gt;

&lt;h1 id=&#34;june-3&#34;&gt;June 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yao Li&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Program Adverbs and Tl√∂n Embeddings&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This will be a two-part talk. In the first part, I&amp;rsquo;d like to present you the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward ‚Äúone client at a time‚Äù style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.
In the second part, I&amp;rsquo;ll dive into a question to the first part: &amp;ldquo;why interaction trees&amp;rdquo;? I&amp;rsquo;d like to show you that, inspired by applicative functors, selective functors, and other structures, we can define a collection of data structures and theories, which we call program adverbs, that capture a variety of computational patterns. Program adverbs are themselves composable, allowing them to be used to specify the semantics of languages with multiple computation patterns. We use program adverbs as the basis for a new class of semantic embeddings called Tl√∂n embeddings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yao Li is a Ph.D. candidate at the University of Pennsylvania (advised by Stephanie Weirich) and an incoming assistant professor at Portland State University (Fall 2022). His main research interests are programming languages and formal verification. His research aims to (1) advance the state of the art of verification on real-world software and (2) make verification easier to use from a programming languages perspective. Previously, Yao Li obtained his bachelor‚Äôs and master‚Äôs degrees in Software Engineering from Shanghai Jiao Tong University. He was a research intern at Microsoft Research in 2018 and a visiting researcher at Universit√† della Svizzera italiana in 2015. He also served as a mentor in Research Experience for Undergraduates at the University of Pennsylvania in 2021 and in Google Summer of Code for Scala in 2016.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022wi/</link>
      <pubDate>Mon, 03 Jan 2022 14:46:51 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-7&#34;&gt;Jan. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dev Purandare&lt;/td&gt;
&lt;td&gt;Append is Near: Log-based Data Management on ZNS SSDs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-14&#34;&gt;Jan. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Max Willsey&lt;/td&gt;
&lt;td&gt;What&amp;rsquo;s up with E-Graphs?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-21&#34;&gt;Jan. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jonathan Castello&lt;/td&gt;
&lt;td&gt;Simulating spacecraft: Not exactly rocket science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-28&#34;&gt;Jan. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Reese Levine&lt;/td&gt;
&lt;td&gt;A Strong Approach to Testing Weak Memory Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-4&#34;&gt;Feb. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kostis Kaffes&lt;/td&gt;
&lt;td&gt;Syrup: User-Defined Scheduling across the Stack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-11&#34;&gt;Feb. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tzu-Han Hsu&lt;/td&gt;
&lt;td&gt;Bounded Model Checking for Hyperproperties&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-18&#34;&gt;Feb. 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Matthew Weidner&lt;/td&gt;
&lt;td&gt;Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-25&#34;&gt;Feb. 25&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jocelyn Chen&lt;/td&gt;
&lt;td&gt;Web question answering with neurosymbolic program synthesis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-4&#34;&gt;March 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jie Zhou&lt;/td&gt;
&lt;td&gt;Fat Pointers for Temporal Memory Safety of C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-11&#34;&gt;March 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sorawee Porncharoenwase&lt;/td&gt;
&lt;td&gt;An Expressive and Optimal Pretty Printer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-7&#34;&gt;Jan. 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Dev Purandare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Append is Near: Log-based Data Management on ZNS SSDs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Log-based data management systems use storage as if it was an append-only medium in order to transform random writes into sequential writes, delivering a major advantage when logs were persisted on hard disks. Although solid-state drives (SSDs) offer improved random write capabilities, sequential writes continue to be advantageous due to locality and space efficiency. However, the inherent properties of flash-based SSDs induce significant disadvantages when utilizing a random write block interface, causing write amplification, uneven wear, log stacking, and garbage collection overheads. To eliminate these disadvantages, Zoned Namespace (ZNS) SSDs have recently been introduced. They offer increased capacity, reduced write amplification, and higher performance but require the host to participate in data placement through zones, which have sequential-write semantics and must be explicitly reset. In ZNS, the Zone Append primitive allows the host to push down fine-grained data placement onto the device, supporting appends to a zone without knowing the location of the tail. Full zones become immutable, greatly simplifying disaggregated storage and operations like replication.&lt;/p&gt;

&lt;p&gt;We propose another pushdown technique, Group Append, which allows appends of data that is smaller (or possibly larger) than a block, offloading data buffering to the controller. We explore how ZNS SSDs with Zone Append, Group Append, and computational storage can benefit four log-based data management areas: (i) log-based file systems, (ii) LSM trees such as RocksDB, (iii) database systems, and (iv) event logs/shared logs. We also propose research directions for all four log-based data management using ZNS SSDs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dev is a PhD candidate in the Computer Science department at University of California Santa Cruz. His research interests lie in storage systems, operating systems and distributed systems, and programming languages. Dev completed his Bachelor&amp;rsquo;s in Computer Engineering at Savitribai Phule Pune University (SPPU) in India. At UCSC he has been working on improving the lifetime of low cost, low reliability SSDs and evolving systems for Zoned Namespace SSDs. Dev has been an Engineering Intern at Riverbed Networks (2017), and an Architecture Enabling Intern at SK Hynix America Ltd. (2019). He can be found on twitter (@dev14e), LinkedIn (devashishp), and email (devashish@ucsc.edu).&lt;/p&gt;

&lt;h1 id=&#34;jan-14&#34;&gt;Jan. 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Max Willsey&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What&amp;rsquo;s up with E-Graphs?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; E-graphs are an important data structure inside SMT solvers, but recently they have been used for a whole lot more, including optimization, program synthesis, and verification!&lt;/p&gt;

&lt;p&gt;This talk will give a whirlwind introduction to e-graphs and equality saturation, as well as some new algorithms that make them faster. I&amp;rsquo;ll also introduce &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, a toolchain that packages all this up into a generic, reusable library. Then, we&amp;rsquo;ll move on to some applications of these new techniques, including floating point accuracy, 3D CAD, deep learning, and more. Finally, I&amp;rsquo;ll talk about some of the current work folks are using egg for, including a teaser for our &lt;a href=&#34;https://arxiv.org/abs/2108.02290&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;upcoming POPL paper&lt;/a&gt; that connects e-graphs to databases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.mwillsey.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Max&lt;/a&gt; is a postdoc at the University of Washington in the &lt;a href=&#34;http://uwplse.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;PLSE&lt;/a&gt; group, where he also did his PhD. His main line of work is on &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, an e-graph and equality saturation toolkit.&lt;/p&gt;

&lt;h1 id=&#34;jan-21&#34;&gt;Jan. 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jonathan Castello&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Simulating spacecraft: Not exactly rocket science&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Caltech&amp;rsquo;s Jet Propulsion Laboratory (JPL) operates a fleet of autonomous spacecraft across our solar system. For more than thirty years, operators have validated planned activities against a simulated model of their spacecraft in order to preserve these valuable resources. These models are typically implemented in a domain-specific language (a DSL), which is then interpreted for an execution plan by reusable simulation systems.&lt;/p&gt;

&lt;p&gt;As we make our spacecraft even more intelligent, our spacecraft models become correspondingly more complex. Existing simulation systems were designed with a minimal DSL and limited scope, and have been significantly expanded under a constant flow of feature requests. Unfortunately, this has led to simulation systems and models that are difficult to understand and maintain without relying on global reasoning and deep expertise.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NASA-AMMOS/aerie/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Merlin&lt;/a&gt; is a newly open-sourced simulation system under development at JPL. Merlin models are written in plain Java, which we try to make as &amp;ldquo;uninteresting&amp;rdquo; as possible for modelers. Instead, we spend our &amp;ldquo;novelty budget&amp;rdquo; mostly under the hood. This talk will showcase the concurrency semantics supporting local reasoning in Merlin, and some of the techniques we take to keep Merlin out of the way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt; is a software engineer most recently with Caltech&amp;rsquo;s Jet Propulsion Laboratory, where he worked on both modern and legacy ground software for spacecraft operations. His research interests sit at the nexus of modular design, concurrency, and monotonic state.&lt;/p&gt;

&lt;h1 id=&#34;jan-28&#34;&gt;Jan. 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Reese Levine&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Strong Approach to Testing Weak Memory Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; GPUs are increasingly being used for compute workloads that require interactions between threads using shared memory. Like many CPUs, GPUs expose weak memory models that allow for more aggressive compiler and hardware optimizations at the expense of a more complex programming model. Testing these memory models is an ongoing line of research.&lt;/p&gt;

&lt;p&gt;This talk will detail our ongoing project on testing GPU memory models. First, we will show a motivating example from an optimized renderer and illustrate how we can reason about the synchronization in the renderer using classic weak memory model litmus tests. Next, we will overview recent work on testing GPU memory models, including complex heuristics necessary to reveal weak behaviors in testing. Our new work builds on this existing work in several ways: (1) we provide a simple DSL and a compiler for expressing litmus tests and testing heuristics; we currently have backends for Vulkan and WebGPU. (2) A new parallel execution model for litmus tests, which allows tests to be executed an order of magnitude faster than in prior works. (3) A web application interface for running litmus tests through WebGPU. We will conclude with a discussion on how these contributions might lead to more robust testing methodologies and hope to facilitate discussions on how they relate to conformance testing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Reese Levine is a second year PhD student at UC Santa Cruz advised by Tyler Sorensen. He is interested in research in parallel, concurrent, and distributed systems, and his work currently focuses on testing weak memory models in GPUs.&lt;/p&gt;

&lt;h1 id=&#34;feb-4&#34;&gt;Feb. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kostis Kaffes&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Syrup: User-Defined Scheduling across the Stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Suboptimal scheduling decisions in operating systems, networking stacks, and application runtimes are often responsible for poor application performance, including higher latency and lower throughput. These poor decisions stem from a lack of insight into the applications and requests the scheduler is handling and a lack of coherence and coordination between the various layers of the stack, including NICs, kernels, and applications. We propose Syrup, a framework for user-defined scheduling. Syrup enables untrusted application developers to express application-specific scheduling policies across these system layers without being burdened with the low-level system mechanisms that implement them. Application developers write a scheduling policy with Syrup as a set of matching functions between inputs (threads, network packets, network connections) and executors (cores, network sockets, NIC queues) and then deploy it across system layers without modifying their code. Syrup supports multi-tenancy as multiple co-located applications can each safely and securely specify a custom policy. We present several examples of uses of Syrup to define application and workload-specific scheduling policies in a few lines of code, deploy them across the stack, and improve performance up to 8x compared with default policies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kostis Kaffes is a final-year Ph.D. candidate in Electrical Engineering at Stanford University, advised by Christos Kozyrakis. He is broadly interested in computer systems, cloud computing, and scheduling. His thesis focuses on end-host, rack-scale, and cluster-scale scheduling for microsecond-scale tail latency. Recently, he has been looking for ways to make it easier to implement and deploy custom scheduling policies across different layers of the stack. Kostis&amp;rsquo;s research has been supported by a Facebook Research Award and various scholarships and fellowships from Stanford, A.G. Leventis Foundation, and Gerondelis Foundation. Prior to Stanford, he received his undergraduate degree in Electrical and Computer Engineering from the National Technical University of Athens in Greece.&lt;/p&gt;

&lt;h1 id=&#34;feb-11&#34;&gt;Feb. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tzu-Han Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bounded Model Checking for Hyperproperties&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Hyperproperties is a powerful framework for specifying and reasoning about important classes of requirements that were not possible with trace-based languages such as the classic temporal logics. This talk will introduce a novel bounded model checking (BMC) algorithm for hyperproperties expressed in HyperLTL. Just as the classic BMC technique for LTL primarily aims at finding bugs, our approach also targets identifying counterexamples. Followed by the reduction of BMC for LTL to SAT solving, our BMC approach naturally reduces to QBF solving, as HyperLTL allows explicit and simultaneous quantification over multiple traces. Our algorithm is sound based on our theory of bounded semantics, which guarantees correct BMC results under finite exploration. We will also present our implemented tool HyperQube, a push-button QBF-based bounded model checker for hyperproperties, and demonstrate the effectiveness and efficiency of our approach via a rich set of practical applications, including security, concurrent data structures, path planning for multi-agent systems, and secrecy-preserving refinement mapping synthesis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tzu-Han Hsu is a second-year Ph.D. student in Computer Science and Engineering department at Michigan State University, advised by Dr. Borzoo Bonakdarpour. Her research areas include formal methods, model checking, verification, and synthesis for security/privacy policies. She is recently working on the topic of hyperproperties, a framework that can reason about multiple traces simultaneously, which has rich applications in formal analysis especially for multi-threaded and concurrent programs.&lt;/p&gt;

&lt;p&gt;Before MSU, Tzu-Han received her bachelor‚Äôs degrees in Computer Science and Music-Piano Performance from Iowa State University in 2020. Tzu-Han can be reached on Twitter (@TzuHanH), LinkedIn (tzuhanhsu), email (tzuhan@msu.edu), and her personal website (&lt;a href=&#34;https://tzuhancs.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://tzuhancs.github.io/&lt;/a&gt;).&lt;/p&gt;

&lt;h1 id=&#34;feb-18&#34;&gt;Feb. 18&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Matthew Weidner&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many distributed systems allow a group of devices to edit some shared state. Examples include collaborative apps, such as Google Docs and Figma, and distributed key-value stores. Often, these systems are highly available: each device can edit its own replica of the state immediately, then sync up with other devices in the background. Eventual consistency requires that once this syncing completes, all devices agree on the new state.&lt;/p&gt;

&lt;p&gt;Eventual consistency is challenging because devices might make conflicting concurrent edits. For example, two users might type at the same time in a Google Doc, or one user might add entries to a spreadsheet while another alters the layout and formatting. Somehow, we must combine all these edits in a way that is consistent across devices and hopefully also makes sense to users. Conflict-free Replicated Data Types (CRDTs) provide one solution to this challenge, by giving programmers data structures with built-in replication and eventual consistency. However, they tend to be hard to understand or customize.&lt;/p&gt;

&lt;p&gt;In this talk, I will propose a way of creating CRDTs by composing simple, easy-to-understand pieces. Ideally, this could let programmers design eventually consistent systems while maintaining complete control over the system&amp;rsquo;s behavior. A &lt;a href=&#34;https://mattweidner.com/2022/02/10/collaborative-data-design.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt; describes the proposal in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://mattweidner.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthew&lt;/a&gt; is a third year PhD student at Carnegie Mellon University, advised by Heather Miller. His research focuses on tools for decentralized systems, with a particular interest in enabling open-source, local-first collaborative apps. Previously, he completed an MPhil at Cambridge University as a Churchill Scholar, where he studied decentralized secure group messaging protocols for the &lt;a href=&#34;https://www.cl.cam.ac.uk/research/dtg/trve/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;TRVE Data&lt;/a&gt; project.&lt;/p&gt;

&lt;h1 id=&#34;feb-25&#34;&gt;Feb. 25&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jocelyn Chen&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Web question answering with neurosymbolic program synthesis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the amount of information available on the web proliferates, there is a growing need for tools that can extract relevant information from the website. Due to the importance of the problem, there has been a flurry of research activity on information extraction and wrapper induction by using powerful neural models and program synthesis. While wrapper induction tools based on program synthesis work well when the target webpages have a shared global schemes, they are not as effective on structurally heterogeneous websites such as faculty webpages. On the other hand, ML-based techniques from the NLP community are, in principal, applicable to heterogeneous websites; however, by treating the entire webpage as unstructured texts, they fail to take advantage of the inherent tree structure of the HTML documents.&lt;/p&gt;

&lt;p&gt;In this talk, we propose a new information extraction approach based on neurosymbolic program synthesis that combines the relative strengths of wrapper induction techniques for webpages with the flexibility of neural models for unstructured documents. Our approach targets structurally heterogeneous websites with no shared global schema and can be used to automate many different types of information extraction tasks. The key idea of our approach is to employ a neurosymbolic DSL that incorporates both neural NLP models as well as standard language constructs for tree navigation and string manipulation. We also propose an optimal synthesis algorithm that generates all DSL programs that achieve optimal F1 score on the training examples. We have implemented these ideas in a new tool called WebQA and evaluate it on 25 different tasks across multiple domains. Our experiments show that WebQA significantly outperforms existing tools such as state-of-the-art question answering models and wrapper induction systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jocelyn Chen is a fourth-year graduate student at the University of Texas at Austin working with Isil Dillig. She is mainly interested in research at the intersection of program synthesis and natural language processing.&lt;/p&gt;

&lt;h1 id=&#34;march-4&#34;&gt;March 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jie Zhou&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Fat Pointers for Temporal Memory Safety of C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The past decade has seen an increasing trend of real-world exploits against temporal memory safety bugs in C/C++ programs, i.e., use-after-free (UAF), double free, and invalid free. These bugs are profoundly dangerous in that they can lead to data corruption, information leaking, or even arbitrary code execution.  Many solutions were proposed, but they suffer one or more severe limitations such as high performance/memory overhead and missing bugs.&lt;/p&gt;

&lt;p&gt;In this talk, I will describe how we solve this problem for C efficiently and comprehensively. We combine two existing techniques: fat pointers (in-place metadata) and ID-based dynamic pointer validation. We build our solution based on Checked C‚Äìa promising safe dialect of C which provides spatial memory safety but currently lacks temporal memory safety. We show that our solution significantly improves the performance and memory consumption compared to using disjoint metadata for pointer validation. Additionally, we also show that our solution is practical in terms of backward compatibility‚Äìone of the major concerns about fat pointers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/jzhou41/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jie Zhou&lt;/a&gt; is a fifth-year PhD student at the University of Rochester. Jie works on systems and software security, with a focus on memory safety. He is most interested in improving systems programming languages and their toolchains for security as he believes that language-based techniques can solve problems in a more fundamental way. He is also interested in developing program analysis and transformation techniques to enforce security policies on low-level software.&lt;/p&gt;

&lt;h1 id=&#34;march-11&#34;&gt;March 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Sorawee Porncharoenwase&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An Expressive and Optimal Pretty Printer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Pretty printers transform structured data into &amp;ldquo;pretty&amp;rdquo; text. In this talk, I will present a pretty printing algorithm that (1) is strictly more expressive than current state-of-the-art algorithms; (2) guarantees optimality; and (3) has better time complexity than many state-of-the-art pretty printers. To distinguish our pretty printer from others, I will also give a brief survey of the existing pretty printing algorithms and dispel various myths about traditional pretty printers that turn out to be inaccurate. This is a joint work with Justin Pombrio and Emina Torlak.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sorawee (Oak) is a fourth year PhD student at the University of Washington, advised by Emina Torlak. His research interest is improving usability of symbolic evaluation.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021fa/</link>
      <pubDate>Tue, 31 Aug 2021 19:47:53 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2021, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-24&#34;&gt;Sept. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Welcome!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-1&#34;&gt;Oct. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-8&#34;&gt;Oct. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Rescuing Data Center Processors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-15&#34;&gt;Oct. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Data Driven Program Merge&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-22&#34;&gt;Oct. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-29&#34;&gt;Oct. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Gradual Verification of Recursive Heap Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-5&#34;&gt;Nov. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-12&#34;&gt;Nov. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sparse Matrices and High-Performance Computing Meet Biology&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-19&#34;&gt;Nov. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-3&#34;&gt;Dec. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-24&#34;&gt;Sept. 24&lt;/h1&gt;

&lt;p&gt;Welcome!&lt;/p&gt;

&lt;h1 id=&#34;oct-1&#34;&gt;Oct. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We will explore how we can make it cheaper to run blockchain protocols and programs&amp;mdash;while guaranteeing correctness!&lt;/p&gt;

&lt;p&gt;For cheaper protocols, we move from a block&lt;em&gt;chain&lt;/em&gt; to a block&lt;em&gt;graph&lt;/em&gt;. Such a blockgraph, which we show to be a reliable point-to-point link, is built together by a set of servers. Thereby, the servers embed many parallel runs of a deterministic protocol into it. And because the protocol is deterministic, every server can locally replay the protocol&amp;mdash;and no more messages need to be sent [1]!&lt;/p&gt;

&lt;p&gt;For cheaper programs, we super-optimize bytecode of the Ethereum Virtual Machine, which runs on many servers to execute programs on the blockchain. Now, to avoid the halting problem, every executed bytecode costs money. So we have a clear optimization target&amp;mdash;money&amp;mdash;and we use an automated theorem prover to synthesize cheaper, observationally equivalent, programs [2].&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria A Schett&lt;/a&gt; is currently finishing her PhD on &amp;ldquo;Cost Reduction With Guarantees: Formal Reasoning Applied To Blockchain Technologies&amp;rdquo; at University College London. She loves living in London and talking about blockchains, distributed systems, and compilers. She is conversational in term rewriting and qualitative research (from a previous life) and in Esperanto.&lt;/p&gt;

&lt;p&gt;[1] &amp;ldquo;Embedding a Deterministic BFT Protocol in a Block DAG&amp;rdquo;, Maria A Schett and George Danezis, Proc. of the 2021 ACM Symposium on Principles of Distributed Computing (PODC) 2021&lt;/p&gt;

&lt;p&gt;[2] &amp;ldquo;Synthesis of Super-Optimized Smart Contracts using Max-SMT&amp;rdquo;, Elvira Albert, Pablo Gordillo, Albert Rubio and Maria A Schett, Proc. of 32nd International Conference on Computer-Aided Verification (CAV) 2020&lt;/p&gt;

&lt;h1 id=&#34;oct-8&#34;&gt;Oct. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Rescuing Data Center Processors&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; To serve billions of users around the world, modern web applications that run across data centers access huge datasets and perform complex application logic. As a result, data center applications face two major challenges: (1) poor data access behavior and (2) poor instruction access behavior. In my research, I demonstrate that novel hardware-software codesign effectively solves both challenges. Specifically, I observe that both data and instruction accesses in data center applications follow a deeply repetitive pattern that can be efficiently optimized by profiling the application‚Äôs program flow behavior. In this talk, I will first present an overview of my techniques to improve data and instruction accesses. I will then describe two of my techniques in detail, showing how these techniques outperform prior proposals from Google.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tanvir Ahmed Khan is a fifth-year Ph.D. candidate at the University of Michigan. His research interests lie at the intersection of computer architecture, compilers, and operating systems. He is interested in designing techniques at the boundary of hardware and software that enable software to better leverage hardware resources. He was a Facebook Fellowship (2020) finalist. His research on data center applications‚Äô performance optimizations has appeared in top computer architecture and systems venues like ISCA, MICRO, PLDI, and OSDI. His work is being used by Intel and ARM to design the next-generation CPU architectures. Tanvir expects to graduate soon and after graduation, he is interested in tenure-track faculty positions.&lt;/p&gt;

&lt;h1 id=&#34;oct-15&#34;&gt;Oct. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Data Driven Program Merge&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In collaborative software development, &lt;em&gt;program merging&lt;/em&gt; is the mechanism to integrate changes from multiple programmers. The most widespread merge algorithm, employed in modern version control systems, is an &lt;em&gt;unstructured&lt;/em&gt; merge. Unstructured merge treats input programs as a sequence of characters and reports a conflict when changes interfere textually. On the other hand, &lt;em&gt;structured&lt;/em&gt; approaches leverage knowledge of the underlying language to perform ‚Äúintelligent‚Äù merges over the program‚Äôs AST. These approaches have shown significant advancements in automatic merging for Java. However, these methods have not found their way into modern version control systems as they are typically language dependent and do not generalize to dynamic languages such as JavaScript.&lt;/p&gt;

&lt;p&gt;In a 1991 seminal paper on program merge [1], Westfechtel voiced: ‚ÄúA tool is &lt;em&gt;urgently&lt;/em&gt; needed which automates the process of merging as much as possible.‚Äù  Thirty years later, and there have not been significant advances in the prevailing merge algorithm - unstructured merge.&lt;/p&gt;

&lt;p&gt;In this work, we take a &lt;em&gt;fresh data-driven&lt;/em&gt; look at the problem of merge resolution. Guided by a multilingual dataset of over 200,000 merges, we explore deep learning techniques to resolve unstructured merge conflicts. Our key innovation is an edit-aware embedding of merge inputs.&lt;/p&gt;

&lt;p&gt;Our resulting model achieves 63&amp;ndash;68% accuracy of merge resolution synthesis, yielding nearly a 3x performance improvement over existing structured merge tools. Finally, we demonstrate that our approach is sufficiently flexible to work with source code files in Java, JavaScript, TypeScript, and C# programming languages, and can generalize zero-shot to unseen languages.&lt;/p&gt;

&lt;p&gt;[1] Bernhard Westfechtel. 1991. Structure-oriented merging of revisions of software documents. In &lt;em&gt;Proceedings of the 3rd international workshop on Software configuration management&lt;/em&gt; (SCM &amp;lsquo;91).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Elizabeth Dinella is a fourth-year PhD student at the University of Pennsylvania. Her research interests can be broadly described as ‚Äúdata-driven program reasoning.‚Äù Most recently, Elizabeth has worked on data-driven bug finding (&lt;a href=&#34;https://openreview.net/pdf?id=SJeqs6EFvB&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hoppity&lt;/a&gt;), program merge, and test oracle inference. She is an admirer of coffee and her chow chow puppy Cinnabon.&lt;/p&gt;

&lt;h1 id=&#34;oct-22&#34;&gt;Oct. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; A large part of our lives is spent online, creating, sharing, and consuming data in various forms. We use a profusion of security protocols to handle this more-often-than-not sensitive data, and connect to the internet and to the world at large. How secure are these communications? How private? These are fundamental questions to which we demand definitive answers. Even with highly sophisticated methods of testing, one cannot get unconditional answers, and this is where formal verification steps in. One can use logic or automata or similar formal methods to conclusively tell us if there are security flaws in these protocols. In this talk, we will provide a quick and dirty introduction to the world of symbolic verification, with a focus on security protocols. We will then look at a few ways in which the protocols of today‚Äôs day and age are modelled and verified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vaishnavi Sundararajan is a postdoc at UCSC. She completed her PhD at Chennai Mathematical Institute, with a thesis on formal aspects of certification in security protocols. She is interested in the areas of logic, security, proof theory and verification. Before UCSC, she was a postdoc at IRISA, Rennes, and a Research Associate at Ericsson Research, Bengaluru.&lt;/p&gt;

&lt;h1 id=&#34;oct-29&#34;&gt;Oct. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Gradual Verification of Recursive Heap Data Structures&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. Our OOPSLA‚Äô20 paper [1] extended gradual verification to programs that manipulate recursive, mutable data structures on the heap. This talk outlines our extension and discusses technical challenges addressed during its development, such as ensuring consistency between static and dynamic checking. I also present the design of a gradual verifier that we built as follow-up work to our OOPSLA paper. It is implemented on top of the Viper static verifier and supports the C0 programming language. The C0 language is a safer, smaller subset of C taught in introductory CS courses at CMU. Finally, I conclude the talk with my short-term plans to evaluate our tool&amp;mdash;which includes a case study on web browser JIT code&amp;mdash;and my long-term vision for the field of gradual verification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a fifth year PhD student in the Institute for Software Research at Carnegie Mellon University, and I am co-advised by Jonathan Aldrich and Joshua Sunshine. My research interests lie at the intersection of programming languages, software verification, and software engineering. In general, I intend to make verification technology, like formal verification and program analysis, more usable in practice. Towards this end, my thesis is dedicated to work in gradual verification, which supports incremental formal verification through the use of both static and dynamic techniques. I have also used ideas from gradual verification to produce a gradual null pointer analysis [2] that reduces false positives compared to state-of-the-art tools. It systematically deploys run-time checks wherever the underlying static analysis is imprecise. Further, I previously contributed to the language design of Penrose &amp;mdash; which generates diagrams from mathematical prose &amp;mdash; and Obsidian &amp;mdash; a programming language that facilitates the development of secure blockchain applications. Outside of work, I enjoy playing video games, such as League of Legends and Final Fantasy XIV Online. I also enjoy bowling and often average more than 170 points per game!&lt;/p&gt;

&lt;p&gt;[1] Wise, J., Bader, J., Wong, C., Aldrich, J., Tanter, √â., Sunshine, J., &amp;ldquo;Gradual Verification of Recursive Heap Data Structures&amp;rdquo;, The ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH20), OOPSLA, November 15-20, 2020, Online&lt;/p&gt;

&lt;p&gt;[2] Estep, S., Wise, J., Aldrich, J., Tanter, √â., Bader, J., and Sunshine, J., &amp;ldquo;Gradual Program Analysis for Null Pointers&amp;rdquo;, The 35th European Conference on Object-Oriented Programming (ECOOP21), July 11-17, 2021, Online&lt;/p&gt;

&lt;h1 id=&#34;nov-5&#34;&gt;Nov. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Domain-specific optimizing compilers such as Halide
enable programs to be expressed at a convenient high-level, while
generating high-performance code for parallel architectures. As
domains of interest expand towards deep learning, probabilistic
programming and beyond, it becomes increasingly clear that it is
unsustainable to redesign domain specific compilers for each new
domain. In addition, the rapid growth of hardware architectures to
optimize for poses great challenges for designing these compilers.&lt;/p&gt;

&lt;p&gt;In this talk, I will show how to extend a unifying domain-extensible
compiler with domain-specific as well as hardware-specific
optimizations.  Optimizations are not hard-coded into the compiler but
are expressed as user-defined rewrite rules that are composed into
strategies controlling the optimization process. On four mobile ARM
multi-core CPUs, the code generated for the Harris image processing
pipeline outperforms the image processing library OpenCV by up to 16x
and achieves performance close to - or even up to 1.4x better than -
the state-of-the-art image processing compiler Halide.&lt;/p&gt;

&lt;p&gt;However, optimization strategies are difficult to write because they
need to decide how to apply rewrite rules.  I will finish this talk by
presenting a technique we call &amp;ldquo;guided equality saturation via
sketching&amp;rdquo; to abstract over individual rewrites.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a PhD student in computer science at the University of Glasgow in
Scotland, where I work closely with my supervisor Michel Steuwer. I am
the lead developer of the &lt;a href=&#34;https://rise-lang.org&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rise project&lt;/a&gt;, which
combines a high-level functional language with a system of rewrite rules
to encode optimization choices. It provides a domain-extensible way to
generate high performance code for diverse hardware architectures.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Personal website&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-12&#34;&gt;Nov. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Sparse Matrices and High-Performance Computing Meet Biology&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In computational and data sciences, the need for scalable computing and data systems has recently increased due to the flood of data in areas such as genomics. Yet, scalable parallel programming in distributed memory is difficult, and high-performance computing (HPC) systems are typically allocated to specific research communities and have long user wait times, limiting access to resources and scientific discoveries.&lt;/p&gt;

&lt;p&gt;In this context, we have developed a novel set of genomics algorithms for de novo genome assembly (i.e., reconstruction of an unknown genome from redundant, erroneous genomic sequences) that are integrated into the diBELLA 2D software package and are based on sparse matrix multiplication supporting general semiring abstraction. This enables the creation and easy modification of powerful genomics pipelines that take advantage of massively parallel hardware without exposing low-level architecture. diBELLA 2D is up to 2x faster on 100s nodes than a 1D algorithm based on distributed hash tables, which are more difficult to parallelize. diBELLA 2D integrates GPU support in the most compute-intensive stages of the pipeline to take advantage of today&amp;rsquo;s heterogeneous HPC hardware.&lt;/p&gt;

&lt;p&gt;To ensure that the genomics research community and others in general, can benefit from HPC, the development of distributed algorithms such as diBELLA 2D must be coupled with efforts to make distributed computing more accessible. To this end, we have shown that we are on the cusp of a paradigm shift in high-performance computing (HPC) away from purely institutional or agency-wide HPC systems to cloud computing, as the latter has made significant advances in networking technology and HPC system software.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Giulia is a Ph.D. candidate in Computer Science at UC Berkeley and a graduate research assistant at the Computational Research Division of Lawrence Berkeley National Laboratory advised by Aydƒ±n Bulu√ß and Kathy Yelick. Giulia is a 2020 SIGHPC Computational &amp;amp; Data Science Fellow and received her M.Sc. and B.Sc. in Biomedical Engineering from Politecnico di Milano. Her work is in the area of computer systems research, including cloud and parallel computing, and she is interested in building a collaborative interdisciplinary research program. Giulia is currently working on the challenges of large-scale computational biology, as well as the algorithms and software infrastructures that meet the usability and performance demand of this community. Currently, she is developing a novel algorithm for de novo assembly of genomes in distributed memory using long-read sequencing data and sparse matrix abstraction as part of the ExaBiome project. Giulia is also working on how to make cloud computing more accessible for high-performance scientific computing.&lt;/p&gt;

&lt;h1 id=&#34;nov-19&#34;&gt;Nov. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Persistent memory (PM) is a new storage technology that combines the speed and byte-addressability of DRAM with the durability of hard disks and solid state drives. Recent research has explored using PM in a number of different applications like databases and file systems. However, programming PM applications correctly is difficult; in order for data to be guaranteed durable on PM, developers must understand and use a set of assembly instructions to manage persistence. In particular, PM applications are prone to crash consistency bugs, where buggy data management leads to incorrect behavior after a crash.&lt;/p&gt;

&lt;p&gt;PM file systems are a growing subset of PM applications, but there are currently no testing tools that target crash consistency bugs in these file systems. In this talk, I will describe my work on building a crash consistency testing framework designed specifically for PM file systems. I will present an overview of our testing approach and the bugs that the tool has found, and discuss the implications of these bugs on the development of PM file systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Hayley LeBlanc is a second year PhD student at the University of Texas at Austin. She is interested in developing techniques and tools to make sure that storage systems are reliable and correct. She also enjoys fencing and volunteering at her local animal shelter.&lt;/p&gt;

&lt;h1 id=&#34;dec-3&#34;&gt;Dec. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Formal proofs are often employed to show correctness of cryptographic routines at the assembly level, especially in instances where architecture-optimized performance is desirable or where compilers do not exist for the target ISA. While common cryptographic routines are often implemented in many different ISAs, the current cost of verification scales poorly with the number of architectures. In this talk, we explore solutions for writing correctness proofs for cryptographic routines which are generic across different architectures.&lt;/p&gt;

&lt;p&gt;Specifically, we will look at assembly implementations of an RSA signature verification routine in RISC-V and in the OpenTitan BigNumber Accelerator (OTBN) ISA. Despite dramatic differences in these two ISAs, we find that the high-level control flow structure of the RSA routine is quite similar across implementations. We use this observation to construct a framework for writing partial architecture-generic assembly-level proofs which are abstracted over hardware details (e.g., register width). We will discuss how this framework can be used to reduce the overhead of proving the correctness of common cryptographic routines on different architectures, and look to future possibilities for further reducing this overhead.~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sydney is a second-year Ph.D. student in the Computer Science Department of Carnegie Mellon, advised by Bryan Parno. She is interested in formal techniques for verifying safety and security properties of low-level, high-performance systems at scale. Sydney received her B.S. and M.Eng. from MIT, where she worked on verification techniques for concurrent, crash-safe systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021sp/</link>
      <pubDate>Sun, 21 Feb 2021 12:27:37 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For spring 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-2&#34;&gt;April 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Running the Trails of Data Management&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-9&#34;&gt;April 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PL design and programming by voice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-16&#34;&gt;April 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-23&#34;&gt;April 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Konstantinos Kallas&lt;/td&gt;
&lt;td&gt;PaSh: A parallelizing shell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-30&#34;&gt;April 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Eric Atkinson&lt;/td&gt;
&lt;td&gt;Programming and Reasoning with Partial Observability&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-7&#34;&gt;May 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vadim Zaliva&lt;/td&gt;
&lt;td&gt;HELIX: From Math to Verified Code&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-14&#34;&gt;May 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-21&#34;&gt;May 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zeeshan Lakhani&lt;/td&gt;
&lt;td&gt;Polarized Functional Programming v0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-28&#34;&gt;May 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Philippa Cowderoy&lt;/td&gt;
&lt;td&gt;Information Aware Type Systems and Telescopic Constraint Trees&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-4&#34;&gt;June 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ranysha Ware&lt;/td&gt;
&lt;td&gt;Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;april-2&#34;&gt;April 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Running the Trails of Data Management&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The demise of Moore&amp;rsquo;s law and Dennard scaling have swung a pendulum back towards computational storage&amp;ndash;disk drives equipped with modest processors and working memory. As was the case when the earliest ``active drives&amp;rdquo; were developed over three decades ago, moving computational kernels closer to where the data is stored presents an opportunity to improve data processing and retrieval performance by alleviating bottlenecks at CPUs that can no longer promise exponential increases in performance over time. We explore this opportunity in a 3-way collaboration between industry and academia with the goal of showing the benefits provided by computational storage devices for scientific analysis workloads. The analysis workloads are based on use cases for the Human Cell Atlas (HCA) and the UCSC Genomics Institute, the computational storage devices are architected and designed by Seagate, and the system that brings these together is architected by our declarative programmable storage research group at UCSC. This talk uses trail running as a fun metaphor to detail the context and directions of our collaboration that spans data management, single-cell RNA sequencing, and a storage system that leverages computational storage devices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aldrin is a 3rd year PhD student at UC Santa Cruz advised by Peter Alvaro, but works extensively with Carlos Maltzahn (UCSC), Jeff LeFevre (UCSC), and Philip Kufeldt (Seagate). Aldrin received his B.S. and M.S. in computer science from Cal Poly, San Luis Obispo working with Alex Dekhtyar on a collaborative, microbial source tracking project with professors and students in the biology and biochemistry departments. Before joining UCSC‚Äôs PhD program, Aldrin has worked on data management of genomic variants at a biotech company, Personalis, Inc. His research interests are primarily in data management systems and bioinformatics, but also span programming languages, storage systems, and software engineering.&lt;/p&gt;

&lt;h1 id=&#34;april-9&#34;&gt;April 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PL design and programming by voice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers and other computer users suffer from repetitive strain injuries (RSI) of the hand that make using a keyboard for extended periods painful. For some kinds of RSI, therapy or surgery may resolve the problem, but in recalcitrant cases sometimes the only option is to reduce or cease typing. So what does a programmer do if they can&amp;rsquo;t type?One option is to use your voice. Speech recognition technology has advanced by leaps and bounds over the past decade, but most people&amp;rsquo;s ideas about voice-driven UI are based on convenient but limited voice assistants like Siri or Alexa, or at best dictation or prose-writing tools. What does a voice interface for expert users look like? A small but growing community of programmers, many affected by RSI, have been developing and using tools that explore this question.I suffer from RSI and use a voice control tool called Talon to program, control my computer, and write my thesis; but I&amp;rsquo;m also a programming languages researcher, and so I find it natural to wonder: how might PL research intersect with voice control? In this talk, I&amp;rsquo;ll try my best to answer that question, as well as a few others:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is voice coding like?  What unique challenges does it present compared with keyboard coding?&lt;/li&gt;
&lt;li&gt;What can we learn from this about designing voice interfaces for expert users?  Specifically, how can programming languages better support voice coding?&lt;/li&gt;
&lt;li&gt;How does a voice control system work?  What does it have in common with PL implementation?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Depending on how you count, Michael Arntzenius is somewhere between a 4th- and a 9th-year PhD student. He works with Neel Krishnaswami on Datafun, an attempt to combine the bottom-up deductive query language Datalog with higher-order typed functional programming. He is interested in monotonicity as a unifying and simplifying theme in incremental, concurrent, and distributed computation; and generally in the theory, design, and implementation of programming systems.&lt;/p&gt;

&lt;h1 id=&#34;april-16&#34;&gt;April 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software supply-chain attacks are becoming an important security concern. These attacks focus on a dependency of the target rather than the target itself and often affect the target as well as other consumers of that dependency. We propose active library learning and regeneration (ALR) techniques for inferring and reconstructing the core functionality of a black-box software dependency. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the dependency, and observes the dependency‚Äôs outputs and interactions to infer a model of the dependency‚Äôs behavior captured in a domain-specific language. We present HARP, an ALR system for string processing dependencies. We apply HARP to successfully regenerate string-processing libraries in JavaScript, Python, and C/C++. In the majority of cases, HARP completes the regeneration in less than a minute, remains fully compatible with the original library, and achieves performance indistinguishable from the original library. We also demonstrate that HARP can eliminate vulnerabilities associated with libraries targeted in a number of highly visible security incidents of the JavaScript ecosystem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Achilles Benetopoulos is a backend software engineer at Plum Fintech. He received a Masters degree in Engineering from the National Technical University of Athens. He is interested in exploring better ways of building robust and performant distributed systems. Starting in the fall, he will be joining UC Santa Cruz as a graduate student advised by Peter Alvaro, to work towards this goal. When he gets too frustrated by computers, he cooks.&lt;/p&gt;

&lt;h1 id=&#34;april-23&#34;&gt;April 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Konstantinos Kallas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PaSh: A parallelizing shell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk I will present PaSh, a new shell that exposes data parallelism in POSIX shell scripts. To achieve that, PaSh proposes: (i) an order-aware dataflow model that captures a fragment of the shell, (ii) a set of dataflow transformations that extract parallelism and have been proven to be correct, (iii) a lightweight framework that captures the correspondence of shell commands and order-aware dataflow nodes, and (iv) a just-in-time compilation framework that allows for effective compilation despite the dynamic nature of the shell. PaSh is open-source and you can try it out today here: &lt;a href=&#34;https://github.com/andromeda/pash&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/andromeda/pash&lt;/a&gt;. If you want to learn more about it you can read our paper that will appear in EuroSys 2021 (next week) here: &lt;a href=&#34;https://arxiv.org/abs/2007.09436&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2007.09436&lt;/a&gt; and if you want to learn more about the dataflow model you can read the paper that introduces it and proves the correctness of the transformations here: &lt;a href=&#34;https://arxiv.org/abs/2012.15422&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2012.15422&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Konstantinos Kallas is a 3rd year PhD student at the University of Pennsylvania working with Rajeev Alur. They are broadly interested in all things PL, distributed systems, and greek folk mountain music. Recently, together with Nikos Vasilakis and several other amazing people they have been working on invigorating the research on the shell. They are also working on partial order semantics for distributed stream processing and programming models for serverless. You can find more information about them here: &lt;a href=&#34;https://angelhof.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://angelhof.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;april-30&#34;&gt;April 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Eric Atkinson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming and Reasoning with Partial Observability&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Computer programs are increasingly being deployed in partially-observable environments. A partially-observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a &lt;em&gt;state estimator&lt;/em&gt; that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an &lt;em&gt;environment model&lt;/em&gt;. The model captures the relationship between observations and hidden states and is used to prove the software correct.&lt;/p&gt;

&lt;p&gt;In my talk, I will present a new methodology for writing and verifying programs in partially observable environments. I will present &lt;em&gt;belief programming&lt;/em&gt;, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, I will present &lt;em&gt;Epistemic Hoare Logic&lt;/em&gt;, which reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. I will develop these concepts by explaining a semantics and a program logic for a simple core language called BLIMP. I will also discuss a case study in which we used BLIMP to implement a verified controller for the Mars Polar Lander, and I will evaluate the performance of a C implementation of BLIMP.&lt;/p&gt;

&lt;p&gt;Paper link: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3428268&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3428268&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Eric Atkinson is a 6th year PhD student at MIT advised by Michael Carbin. His primary research interests involve using programming language tools to help developers manage both probabilistic and nondeterministic uncertainty.&lt;/p&gt;

&lt;h1 id=&#34;may-7&#34;&gt;May 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vadim Zaliva&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HELIX: From Math to Verified Code&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk we will presents HELIX, a code generation and formal
verification system with a focus on the intersection of
high-performance and high-assurance numerical computing. This allowed
us to build a system that could be fine-tuned to generate efficient
code for a broad set of computer architectures while providing formal
guarantees of such generated code&amp;rsquo;s correctness.&lt;/p&gt;

&lt;p&gt;The method we used for high-performance code synthesis is the
algebraic transformation of vector and matrix computations into a
dataflow optimized for parallel or vectorized processing on target
hardware. The abstraction used to formalize and verify this technique
is an operator language used with semantics-preserving
term-rewriting. We use sparse vector abstraction to represent partial
computations, enabling us to use algebraic reasoning to prove parallel
decomposition properties.&lt;/p&gt;

&lt;p&gt;HELIX provides a formal verification foundation for rewriting-based
algebraic code synthesis optimizations, driven by an external
oracle. Presently HELIX uses SPIRAL as an oracle deriving the rule
application order. The SPIRAL system was developed over the years and
successfully applied to generate code for various numeric
algorithms. Building on its sound algebraic foundation, we generalize
and extend it in the direction of non-linear operators, towards a new
theory of partial computations, applying formal language theory and
formal verification techniques.&lt;/p&gt;

&lt;p&gt;HELIX is developed and proven in Coq proof assistant and demonstrated
on a real-life example of verified high-performance code generation of
the dynamic window safety monitor for a cyber-physical robot system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vadim Zaliva works on formal verifications of computer programs,
presently as a Senior Research Associate at Cambridge University and
previously as part of his Ph.D. at Carnegie Mellon University. His
diverse academic interests in addition to formal methods range from
computer security to machine learning and gesture recognition. With
20+ years of experience in the design and implementation of commercial
software, he has worked through the ranks of the software industry
from software engineer to CTO, CEO, and company founder.&lt;/p&gt;

&lt;h1 id=&#34;may-14&#34;&gt;May 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this work, we specify a formal semantics of NVIDIA&amp;rsquo;s SASS instruction set, the ISA that is actually executed by NVIDIA GPUs.  We introduce the ROCetta approach for discovering the semantics of a target language that requires the semantics a source language, and the ability to obtain a translation from the source to the target language.   Using this approach, we have discovered and verified the semantics of 421 SASS instructions.  In addition, our verification effort was able to uncover 18 bugs in the CUDA compiler&amp;rsquo;s translation of single-instruction PTX programs.  In some cases, bugs were only caught during verification and were missed by the testing framework, which lacked a test for inputs that trigger the bug. Furthermore, verification of 3,581 programs took 14 minutes when run in parallel, while running the full test suite against hardware took upwards of 30 minutes.  The low cost of verification, along with its superior ability to detect bugs, makes it an invaluable tool to detect bugs that occur in the translation of small programs.&lt;/p&gt;

&lt;h1 id=&#34;may-21&#34;&gt;May 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zeeshan Lakhani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Polarized Functional Programming v0.1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When designing a new, real-world type system, where would you start? Looking for
examples, you may notice that a language like Typescript has a myriad of
advanced typing features, though they&amp;rsquo;re oriented toward trying to
capture JavaScript&amp;rsquo;s many dynamic idioms and (now) lengthy history of existing
programs. Furthermore, even with these advanced features, the language is not
sound, i.e. certain operations cannot be known to be type-safe at compile-time.
Looking elsewhere, like in the ML family of languages, you&amp;rsquo;ll see a powerful
type inference mechanism helping to free programmers from the burden of
numerous, explicit type annotations. Yet, as new research-driven type extensions
have been incorporated, the need for explicit annotations or pre-processing
steps has increased in certain situations. As the complexity of our programs and
the properties about them that we&amp;rsquo;d like to statically guarantee grow, how far
can just typechecking take us while remaining sound and without us having to
associate proofs with our programs?&lt;/p&gt;

&lt;p&gt;The answer is pretty far. Lightweight verification through refinement types is
catching on. Most &lt;em&gt;modern&lt;/em&gt; languages, e.g. Rust, OCaml, Dotty/Scala, come out of
the box with sum types or enumerated variants and integrations for extended
static code analysis. Our answer to these questions lies in the powerful
relationship between static analysis and type theory and how to treat evaluation
(essentially, eager versus lazy) as first-class.&lt;/p&gt;

&lt;p&gt;In this talk, I will present our work-in-progress research on a polarized
functional programming language based on the call-by-push-value (CBPV)
Œª-calculus, which allows for the mixing of both call-by-name and call-by-value
evaluation inside of a single program via a kind-like operator, shifting between
positive and negative types. We extend this polarized calculus further with a
transparent and equirecursive interpretation of mixed-inductive-and-coinductive datatypes,
allowing us to leverage strong structural subtyping and datasort refinements over sums and
intersections. Additionally, typechecking works bidirectionally in our system,
meaning that terms can be checked to a certain type or synthesized as a
certain type, which scales well for adding various expressive type features to
our language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zeeshan is the founder of Papers We Love and PWLConf, as well as an organizer. He&amp;rsquo;s also
the Director of Research and Development at BlockFi working on various data and program
analysis projects. And, he&amp;rsquo;s a PhD student at Carnegie Mellon University&amp;rsquo;s School of
Computer Science, studying Programming Languages under Frank Pfenning.&lt;/p&gt;

&lt;h1 id=&#34;may-28&#34;&gt;May 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Philippa Cowderoy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Information Aware Type Systems and Telescopic Constraint Trees&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What does conservation of information have to do with type systems? Are type checkers specialised operating systems? Can we understand dataflow in type systems or are we doomed to drown in it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll present a highly familiar type system in pursuit of an `Information Aware&amp;rsquo; style, using information effects to reveal data flow and help in implementing a checker. I also calculate a general, scoped, constraint-based representation of typechecking problems from the typing rules.&lt;/p&gt;

&lt;p&gt;And then, because why not? Let&amp;rsquo;s toy with substructural systems and maybe even incremental checking!&lt;/p&gt;

&lt;p&gt;Warning: talk may contain willfully creative use of long-standing concepts&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Philippa Cowderoy is a professional procrastinator and amateur computer scientist, having dropped out of the University of Nottingham as an undergraduate in 2007.&lt;/p&gt;

&lt;p&gt;Somehow this still hasn&amp;rsquo;t put her off being frustrated with her tools on a increasingly deeper level. When she is bored enough, she is now mining particularly meta veins of frustration shared by others in the PL community.&lt;/p&gt;

&lt;p&gt;In her copious free (if not high-quality) time she plays too many games and spends too little time around cats.&lt;/p&gt;

&lt;h1 id=&#34;june-4&#34;&gt;June 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ranysha Ware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The stability of the Internet relies on congestion control algorithms (CCAs) to efficiently and fairly share limited network resources. Dozens of congestion control algorithms have been proposed in the past 30 years, however, we still lack a good way to decide whether a new algorithm is reasonable to deploy on the Internet. As we will show in this talk, new algorithms can be dramatically unfair to widely-deployed legacy algorithms. For example, we prove that Google&amp;rsquo;s new CCA, BBR, will always consume a fixed fraction of the link when competing with any number of Cubic flows.&lt;/p&gt;

&lt;p&gt;Given the threat of poor performance due to competing heterogeneous CCAs, in this talk we discuss considerations for deploying new CCAs on the Internet. While past efforts have focused on achieving fairness or friendliness between new algorithms and legacy algorithms, we instead advocate for an approach centered on quantifying and limiting harm caused by the new algorithm on the status quo. We argue that a harm-based approach is more practical, more future proof, and handles a wider range of quality metrics than traditional notions of fairness and friendliness.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;  Ranysha Ware is a PhD student in Carnegie Mellon University‚Äôs Computer Science Department, co-advised by Professor Justine Sherry and Professor Srinivasan Seshan. Her bailiwick is computer networking. Her current research focuses on challenges arising from the deployment of new transport protocols and congestion control algorithms in the Internet. Ranysha earned her M.S. (2015) from UMass Amherst and B.S (2013) from SUNY New Paltz. She is a recipient of the IRTF Applied Networking Research Prize, Facebook Emerging Scholar Award, and National GEM Consortium Fellowship.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021wi/</link>
      <pubDate>Sat, 02 Jan 2021 21:45:29 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For winter 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-8&#34;&gt;Jan. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Introductions and social time&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-15&#34;&gt;Jan. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-22&#34;&gt;Jan. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-29&#34;&gt;Jan. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;On the Design, Implementation, and Use of Laziness in R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-5&#34;&gt;Feb. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-12&#34;&gt;Feb. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-19&#34;&gt;Feb. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kamala Ramasubramanian&lt;/td&gt;
&lt;td&gt;ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-26&#34;&gt;Feb. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-5&#34;&gt;March 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vinujoseph.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vinu Joseph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Programmable Neural Network Compression with Correctness Emphasis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-12&#34;&gt;March 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Daniel Bittman&lt;/td&gt;
&lt;td&gt;Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-8&#34;&gt;Jan. 8&lt;/h1&gt;

&lt;p&gt;Introductions and social time&lt;/p&gt;

&lt;h1 id=&#34;jan-15&#34;&gt;Jan. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Session types have long promised the ability to enforce complex temporal invariants about message ordering in distributed systems, guaranteeing that a well-session-typed program always correctly follows a messaging protocol to its end. Despite their potential, these type systems have seen relatively little adoption in the mainstream. In part, this is due to their inherent reliance on linear typing, a feature not present and difficult to emulate in most popular languages. Recently, this has changed with the emergence of Rust, a systems programming language built atop a flexible &amp;ldquo;ownership type system&amp;rdquo; to track reference aliasing. Although Rust enforces in actuality a form of affine typing (weaker than the linear typing most formal session-typed calculi require) it&amp;rsquo;s enough to build a library for session types that statically enforces the slightly-weaker guarantee that a program correctly follows a messaging protocol so long as it is running, but may quit the session early. Of course, this is the best we can hope to get in the real world! Networks go down, computers crash, and hardware just plain breaks. For session types to be broadly adopted, they must survive contact with this real and unpredictable world‚Äîand equally, with the real and unpredictable people who want to use them in their programs.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve just released version 0.2 of &lt;a href=&#34;https://docs.rs/dialectic&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dialectic&lt;/a&gt;: a library for pragmatic, succinct, efficient session types in Rust. Dialectic embraces Rust&amp;rsquo;s burgeoning ecosystem of high-performance async networking by being polymorphic over any backend transport used to convey messages between parties. Unlike many libraries for session types, Dialectic assumes that the other party might break protocol or disconnect at any time, and is designed to gracefully handle such failures without compromising type safety.  Dialectic is designed to be used for writing specifications and programs of every size from small to large, and provides what&amp;rsquo;s needed to write modular specifications and implementations of complex protocols‚Äîand not merely the regular session types expressible in most libraries, but all context-free session types.&lt;/p&gt;

&lt;p&gt;More than merely showing off this cool thing I&amp;rsquo;m working on, I want to talk about the design process that went into making it. Designing a programming paradigm‚Äîwhether you want to call it an embedded domain-specific language or merely a library‚Äîis a multi-faceted puzzle spanning considerations from psychological familiarity to formal computability. My hope is that in walking through this case study in embedded language design, we can spark more thoughts about how we as PL researchers can play in this field together and design beautiful, useful tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kenny Foner (kwf@very.science) is a senior software engineer at Bolt Labs working on privacy-preserving financial technology for everyone. They have a master&amp;rsquo;s degree in programming languages from the University of Pennsylvania, where they worked on a smorgasbord of fun things from laziness to random testing. When they&amp;rsquo;re not writing Rust, they&amp;rsquo;re usually somewhere in the forest.&lt;/p&gt;

&lt;h1 id=&#34;jan-22&#34;&gt;Jan. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Memory consistency models (MCMs) have been formulated as a mechanism for expressing the legal ordering and visibility of shared memory accesses in hardware and software. They are fundamental for ensuring heterogeneous components of a system execute and interact as expected to prevent hardware-induced bugs in real-world programs. However, ISA-level MCMs are limited to defining the behavior of only user-facing assembly instructions and do not account for virtual memory implementations that may result in the execution of 1) hardware-level state updates and 2) system-level interactions. Both are capable of accessing memory and may affect program outcomes, thus making them software-visible. As a result, memory transistency models (MTMs) have been coined as a superset of MCMs to additionally capture and enforce virtual memory-aware ordering rules. However, no prior work enabled the formal specification or analysis of MTMs.&lt;/p&gt;

&lt;p&gt;TransForm fills this gap by introducing an axiomatic vocabulary for formally specifying MTMs that builds on the standard axiomatic vocabulary traditionally used for describing MCMs. It provides new constructs for modeling transistency-specific features such as hardware-level state updates and system-level interactions. Using this new axiomatic vocabulary, MTMs can be formally specified and used with TransForm‚Äôs synthesis engine to synthesize litmus tests enhanced with transistency features, called enhanced litmus tests. This talk will cover TransForm‚Äôs axiomatic vocabulary and synthesis engine, as well as a case study performed with TransForm to formally define an approximate MTM for Intel x86 processors.&lt;/p&gt;

&lt;h1 id=&#34;jan-29&#34;&gt;Jan. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; On the Design, Implementation, and Use of Laziness in R&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I will present the design and implementation of call-by-need in R, and a data-driven study of how generations of programmers have put laziness to use in their code. In our study, we analyze 16,707 R packages and observe the creation of 270.9 B promises. Our data suggest that there is little supporting evidence to assert that programmers use laziness to avoid unnecessary computation or to operate over infinite data structures. For the most part R code appears to have been written without reliance on and in many cases even knowledge of, delayed argument evaluation. The only significant exception is a small number of packages which leverage call-by-need for meta-programming. I will discuss how we intend to leverage these insights to remove laziness from R and enable non-intrusive migration of code from lazy to eager evaluation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aviral Goel is a Computer Science Ph.D. student at Northeastern University, advised by Professor Jan Vitek. He received his Bachelor&amp;rsquo;s degree in Electronics and Communication Engineering from Netaji Subhas Institute of Technology, India.&lt;/p&gt;

&lt;p&gt;He is interested in improving tools and techniques for data science applications. He is enabling R programmers to write faster and bug-free code by migrating the language from lazy-by-default to lazy-on-demand semantics.&lt;/p&gt;

&lt;p&gt;He is also involved in the development of a type system for R.&lt;/p&gt;

&lt;h1 id=&#34;feb-5&#34;&gt;Feb. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Today, most code still runs on expensive, power-hungry processors that prioritize single-thread performance. Speculative parallelization is an enticing approach to accelerate computation while retaining the ease of sequential programming, by launching tasks in parallel before knowing if they are independent. Unfortunately, prior speculative parallelizing compilers and architectures achieved limited speedups due to high costs of recovering from misspeculation and hardware scalability bottlenecks.&lt;/p&gt;

&lt;p&gt;We present T4, a parallelizing compiler that executes sequential programs as trees of tiny timestamped tasks. T4 targets the recent Swarm architecture, which presents new opportunities and challenges for automatic parallelization. T4 introduces novel compiler techniques to expose parallelism aggressively across the entire program, breaking applications into tiny tasks of tens of instructions each. Task trees unfold their branches in parallel to enable high task-spawn throughput while exploiting selective aborts to recover from misspeculation cheaply. T4 exploits parallelism across function calls, loops, and loop nests; performs new transformations to reduce task spawn costs and avoid false sharing; and exploits data locality among fine-grain tasks. As a result, T4 scales several hard-to-parallelize SPEC CPU2006 benchmarks to tens of cores, where prior work attained little or no speedup.&lt;/p&gt;

&lt;p&gt;For more information, please visit &lt;a href=&#34;swarm.csail.mit.edu&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;swarm.csail.mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Victor Ying is a 5th year PhD student at MIT, advised by Daniel Sanchez. He works on parallel architectures, compilers, and programming models. Victor&amp;rsquo;s recent work focuses on redesigning abstractions between hardware and software to make it as easy to exploit multicore parallelism as it is to write ordinary sequential programs. His prior work includes Boolean satisfiability solvers, scheduling machine learning workloads on hardware accelerators, and embedded and distributed systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-12&#34;&gt;Feb. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers use dependently-typed languages like Coq to
machine-verify high-assurance software. However, existing compilers for
these languages provide no guarantees after compiling, nor when linking
after compilation. Type-preserving compilers preserve guarantees encoded
in types, then use type checking to verify compiled code and ensure safe
linking with external code. Unfortunately, dependent type systems are
highly sensitive to syntactic changes, including compilation, so
preserving them through a compiler pass is difficult.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some examples of why dependent typing is
difficult to preserve through simple syntactic changes. I will also
present our solution to preserving dependent types through the ANF
translation, a necessary transformation towards compiling a functional
language down to machine code. Our ANF translation preserves dependent
types, provided that the target type system has a way to encode these
syntactic semantics-preserving changes. We encode these by including
extensional equality in our target type system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Paulette Koronkevich is a second year graduate student (finishing
MSc and starting PhD) at the University of British Columbia, working
with William J. Bowman. She has a undergraduate degree in computer
science from Indiana University. Her interests include compilers, cats,
and cooking.&lt;/p&gt;

&lt;h1 id=&#34;feb-19&#34;&gt;Feb. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kamala Ramasubramanian&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Incidents in production systems are common and downtime is expensive. Applying an appropriate mitigating action quickly, such as changing a specific firewall rule or routing around a broken network link, saves money. Identifying where to mitigate is time-consuming since a single failure can produce widespread effects. Knowing how different system events relate to each other is necessary to quickly identify where to mitigate. Our approach, Aggregate Comparison of Traces (ACT), localizes incidents by comparing sets of traces (which capture events and their relationships for individual requests) sampled from the most recent steady-state operation and during an incident. In our quantitative experiments, we conduct hundreds of simulations and show that ACT is able to identify exactly where to mitigate in all but a few cases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kamala Ramasubramanian is a PhD candidate at University of California, Santa Cruz advised by Peter Alvaro. She works on understanding, implementing and troubleshooting distributed systems by reasoning about observed system executions. She recently became interested in system verification and how it may overlap with her current work. She is a vegetarian foodie, likes to CrossFit and wants to try surfing.&lt;/p&gt;

&lt;h1 id=&#34;feb-26&#34;&gt;Feb. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In recent years, quantum computing (QC) hardware has progressed considerably with small systems being prototyped by industry and academic vendors. However, there is a huge gap between the resource requirements of promising applications and the hardware that is buildable now; qubit counts and operational noise constraints of applications exceed hardware capabilities by 5-6 orders of magnitude. Our work seeks to enable practical QC by bridging this gap: from the top with novel compiler techniques and algorithmic optimizations to reduce application requirements and from the bottom via system architectures efficiently exploiting scarce QC resources.&lt;/p&gt;

&lt;p&gt;In this talk, we present two cross-cutting optimizations that narrow the applications-to-hardware resource gap. First, we present noise-adaptive compilation techniques that optimize applications for the spatio-temporal noise variations seen in real QC systems. Using real executions, we demonstrate average fidelity improvements of 3X using noise-adaptivity, compared to industry compiler tools. Second, on the architecture front, we study instruction set design issues considering application requirements and hardware gate calibration overheads. Current QC systems either use ISAs with a single two-qubit gate type or families of continuous gate sets. Using architectural simulations based on Google and Rigetti hardware, we show that QC instruction sets with 4-8 two-qubit gate types are best suited for expressing application requirements, while incurring tractable calibration overheads. In response to our work, several industry vendors have included noise-adaptivity and its extensions as part of their toolflows and adjusted device architecture to expose more native operations and hardware characterization data.&lt;/p&gt;

&lt;h1 id=&#34;march-5&#34;&gt;March 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vinu Joseph&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programmable Neural Network Compression with Correctness Emphasis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Deep neural networks (DNNs) frequently contain far more weights, represented at higher precision, than are required for the specific task which they are trained to perform.
Consequently, they can often be compressed using techniques such as weight pruning and quantization that reduce both the model size and inference time without appreciable loss in accuracy.
However, finding the best compression strategy and corresponding target sparsity for a given DNN, hardware platform, and optimization objective currently requires expensive, frequently manual, trial-and-error experimentation.
In this talk, we introduce a programmable system for model compression called Condensa. Users programmatically compose simple operators, in Python, to build more complex and practically interesting compression strategies.
Given a strategy and user-provided objective (such as minimization of running time), Condensa uses a novel Bayesian optimization-based algorithm to automatically infer desirable sparsities.
Our experiments real-world DNNs demonstrate memory footprint and hardware runtime throughput improvements of 188x and 2.59x, respectively, using at most ten samples per search.
We have released a reference implementation of &lt;a href=&#34;https://github.com/NVlabs/condensa&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Condensa&lt;/a&gt;. Next, we will talk about our recent correctness extension where we preserve not just the overall accuracy but also metrics relating to model fairness and interpretability.
To achieve this, we augment the compression loss function with terms arising from the teacher-student learning paradigm and show how to automatically tune the associated parameters.
We demonstrate the effectiveness of our approach on multiple compression schemes and accuracy recovery algorithms using several different real-world network architectures.
We obtain a significant reduction of up to 4.1X in the number of mismatches between the compressed and reference models, while also achieving a significant reduction in class-wise disparate impact metrics compared to the reference models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vinu Joseph is a Ph.D. candidate in Computer Science at the School of Computing at the University of Utah, Salt Lake City, working on efficient deep learning computing, robustness, and security of deep learning algorithms, advised by Prof. Ganesh Gopalakrishnan.
He is one of the five recipients of the NVIDIA Graduate fellowship, the recipients were selected based on their academic achievements and area of research.
Prior to graduate studies, Vinu worked at ARM Inc. During his tenure at ARM, he was a recipient of the Bravo award for developing the programmer‚Äôs model for verifying real-time (‚ÄòR‚Äô) profile architecture which provides high-performing processors for safety-critical environments.
Vinu‚Äôs current research focuses on optimizing deep neural network-based systems for performance and scalability. More broadly, His research is at the intersection of systems, programming languages, and machine learning, to create a more efficient, performant, secure, privacy-preserving, and correct software.
His Ph.D. research has been mainly focused on deep neural network compression for resource-efficient inference and robustness. He is generously supported by an NVIDIA Ph.D. fellowship, mentored by Saurav Muralidharan and Michael Garland, he developed Condensa: A Programming System for Model Compression and Optimization.&lt;/p&gt;

&lt;h1 id=&#34;march-12&#34;&gt;March 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Daniel Bittman&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Byte addressable, non-volatile memory (NVM) demands that we rethink the entire system stack. Twizzler is an operating system designed for the near-future of NVM on the memory bus. It removes the kernel from the I/O path, provides programs with direct access to NVM, enabling simpler and more efficient long-term operations on persistent data. Twizzler provides a clean-slate programming model for persistent data, realizing the vision of Unix in a world of NVM. It does this through a pervasive notion of data identity coupled with an efficient design for persistent pointers that allows programmers to construct persistent data structures in a large, persistent, global address space. This talk will present an overview of Twizzler and discuss upcoming directions for Twizzler in security, distribution, and programming languages.Bio&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Daniel is a PhD candidate at UC Santa Cruz, advised by Ethan Miller and Peter Alvaro. His interests are in kernel programming and design, security, non-volatile memory, and concurrent programming. His current project is on developing an operating system for non-volatile memories and developing operating system designs and interfaces for better programming and data models in such an environment.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2020)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2020fa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2020fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT)&lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br/&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For fall 2020, this seminar is completely virtual.  We are excited to welcome a roster of external speakers from around the world!&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-2&#34;&gt;Oct. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Social event and class introduction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-9&#34;&gt;Oct. 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matth√≠as P√°ll Gissurarson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Weakening Type Systems for Faster Prototyping&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-16&#34;&gt;Oct. 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;An introduction to Session Types&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-23&#34;&gt;Oct. 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Correct and Secure Serverless Computing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-30&#34;&gt;Oct. 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Everything Old is New Again: Binary Security of WebAssembly&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-6&#34;&gt;Nov. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mechanising the Linear œÄ-Calculus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-13&#34;&gt;Nov. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Penrose: from mathematical notation to beautiful diagrams&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-20&#34;&gt;Nov. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-4&#34;&gt;Dec. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vectorization for Digital Signal Processors via Equality Saturation&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-11&#34;&gt;Dec. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modular, compositional, and executable semantics for LLVM IR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;oct-2&#34;&gt;Oct. 2&lt;/h1&gt;

&lt;p&gt;Class introduction&lt;/p&gt;

&lt;h1 id=&#34;oct-9&#34;&gt;Oct. 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matth√≠as P√°ll Gissurarson&lt;/a&gt; (&lt;em&gt;Chalmers University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Weakening Type Systems for Faster Prototyping&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Types and type systems are great to provide the compiler with a partial specification of our programs, but it can often be tricky to write code that matches said specification. In this talk, I will demonstrate how we can allow developers to opt-in to a weaker type system &amp;ldquo;just get it to compile&amp;rdquo;, and what we can do to &amp;ldquo;fix&amp;rdquo; the code during compilation so that it matches the specification provided using synthesis and coercions, and hint to the developer what the issue is and how they might fix it.&lt;/p&gt;

&lt;h1 id=&#34;oct-16&#34;&gt;Oct. 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt; (&lt;em&gt;University of Edinburgh&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An introduction to Session Types&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Much like the Œª-calculus is the foundational calculus for functions, the œÄ-calculus is the foundational calculus for message-passing concurrency. Both are terrifyingly powerful, in the sense that if you can compute something, you can do it using these languages. They&amp;rsquo;re also very scary, in the sense that you can easily write functions that &amp;ldquo;go wrong&amp;rdquo;, e.g., by getting different kinds of data mixed up, looping forever, or just getting stuck. In this talk, I&amp;rsquo;ll introduce the fundamentals of the œÄ-calculus, and the continued effort to tame its potential for going wrong, while leaving as much of its power as possible intact. I&amp;rsquo;ll do all of this by analogy to the Œª-calculus, and I&amp;rsquo;ll finish up by talk about concurrent Œª-calculus‚Äîbasically the answer to the question &amp;ldquo;What do I get if I smash my Œªs and œÄs together really hard?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;(The talk starts with a brief recap of the relevant bits of the untyped and simply-typed Œª-calculus, just in case you could use a refresher.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Wen is a programming languages researcher at the University of Edinburgh, where she works on session types. She is also a researcher at Heriot-Watt University, where she works on lightweight verification for neural networks. In her spare time, she enjoys cooking and runs a small art space.&lt;/p&gt;

&lt;h1 id=&#34;oct-23&#34;&gt;Oct. 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt; (&lt;em&gt;Tel Aviv University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Correct and Secure Serverless Computing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Serverless computing is a popular cloud computing paradigm that allows for easy deployment, rapid prototyping,
 and effortless, near-unlimited scalability. However, serverless computing can provide these benefits by introducing several restrictions and limitations on cloud applications, including limiting task execution time, requiring the use of ephemeral execution
 environments, and requiring that programs adopt an event-driven programming model. These limitations make it harder to write correct and secure applications.&lt;/p&gt;

&lt;p&gt;In this talk I will present two projects aimed at bridging these security and correctness gaps. The first‚ÄîTrapeze‚Äîis
 a runtime IFC system that guarantees termination-sensitive non-interference,
 ensuring that sensitive data never leaks from a serverless application. The second‚ÄîWatchtower‚Äîis a runtime monitoring system that checks for violation of arbitrary temporal correctness properties that cross-cut the entire application reporting to the user
 when violations occur. Watchtower also includes a record-and-replay component for locally reproducing and debugging property violations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kalev is a 4th year PhD candidate at Tel Aviv University, under the supervision of Prof. Mooly Sagiv. His
 research interests are in the intersection of serverless computing and PL/formal methods.&lt;/p&gt;

&lt;h1 id=&#34;oct-30&#34;&gt;Oct. 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt; (&lt;em&gt;University of Stuttgart&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Everything Old is New Again: Binary Security of WebAssembly&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; WebAssembly is an increasingly popular, low-level binary format designed
to run code in browsers and on other platforms safely and securely, by
strictly separating code and data, enforcing types, and limiting
indirect control flow. Still, vulnerabilities in memory-unsafe source
languages can translate to vulnerabilities in WebAssembly binaries. We
have analyzed to what extent vulnerabilities are exploitable in
WebAssembly binaries, and how this compares to native code. We find that
many classic vulnerabilities which, due to common mitigations, are no
longer exploitable in native binaries, are completely exposed in
WebAssembly. Moreover, WebAssembly enables unique attacks, such as
overwriting supposedly constant data or manipulating the heap using a
stack overflow. In this talk, we will explain several attack primitives
that allow an attacker (i) to write arbitrary memory, (ii) to overwrite
sensitive data, and (iii) to trigger unexpected behavior by diverting
control flow or manipulating the host environment. This can ultimately
lead to new forms of cross-site scripting in the browser or remote code
execution on Node.js. We will also demonstrate one of our three
end-to-end exploits, which cover three different WebAssembly platforms.
In our quantitative evaluation of real-world WebAssembly binaries, we
also measure how likely our attack primitives are feasible in practice.
Overall, our findings show a perhaps surprising lack of binary security
in WebAssembly. Finally, we will discuss some potential mitigations and
give recommendations on how to harden WebAssembly binaries in the future.&lt;/p&gt;

&lt;h1 id=&#34;nov-6&#34;&gt;Nov. 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt; (&lt;em&gt;University of Glasgow&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Mechanising the Linear œÄ-Calculus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The œÄ-calculus is a computational model for communication and concurrency. The
linear œÄ-calculus restricts the œÄ-calculus by demanding that every communication
channel is used exactly once. This results in more fine grained control over
communication, avoids race conditions, and is in itself enough to serve as a
target language to which the session-typed œÄ-calculus can be compiled to.&lt;/p&gt;

&lt;p&gt;This talk will focus on mechanizing the linear œÄ-calculus. I will first present
a mechanized syntax and an operational semantics for the untyped œÄ-calculus. On
top of that, I will use leftover typing to define a resource-aware type system
that is parametrized by a set of usage coalgebras. I will compare this type
system with its more traditional alternative, and comment on some of its type
safety properties.&lt;/p&gt;

&lt;p&gt;Finally, I will briefly introduce some of our ongoing research, which aims to
mechanize the decidable typechecking of the linear œÄ-calculus. We do so by
borrowing ideas from co-contextual type checking algorithms and applying them to
the linear œÄ-calculus. This results in a constraint satisfaction problem that,
when satisfied, returns type substitutions that can be used to mechanically
build typing derivations for terms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Uma is a 2nd year PhD student at the University of Glasgow, where she works on the machine verification of typed process calculi under the supervision of Dr Ornela Dardha.
On her spare time she enjoys going out along the local riverbank for a run, and she uses every opportunity she has to hike through the Italian Alps and the Basque Pyrenees.&lt;/p&gt;

&lt;h1 id=&#34;nov-13&#34;&gt;Nov. 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt; (&lt;em&gt;Carnegie Mellon University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Penrose: from mathematical notation to beautiful diagrams&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; How do you design a system for automatically visualizing mathematics? In this talk I will discuss the approach taken in our SIGGRAPH 2020 paper to build a tool, called Penrose, for creating mathematical diagrams.&lt;/p&gt;

&lt;p&gt;The basic functionality of Penrose is to translate abstract statements written in familiar math-like notation into one or more possible visual representations. Rather than rely on a fixed library of visualization tools, the visual representation is user-defined in a constraint-based specification language; diagrams are then generated automatically via constrained numerical optimization. The system is user-extensible to many domains of mathematics, and is fast enough for iterative design exploration. In contrast to tools that specify diagrams via direct manipulation or low-level graphics programming, Penrose enables rapid creation and exploration of diagrams that faithfully preserve the underlying mathematical meaning. We demonstrate the effectiveness and generality of the system by showing how it can be used to illustrate a diverse set of concepts from mathematics and computer graphics.&lt;/p&gt;

&lt;p&gt;For more information (and pictures!), please see our paper page:
&lt;a href=&#34;https://penrose.ink/siggraph20&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://penrose.ink/siggraph20&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-20&#34;&gt;Nov. 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt; (&lt;em&gt;Lehigh University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the name suggests, range queries provide the capability to return all values of a set, whose keys are contained in a given range. In a concurrent setting, this particular operation presents challenges since it can be long running. To offer linearizable range queries, we must ensure that the operations observe a consistent snapshot of the data structure even in the midst of ongoing point operations (i.e. get, put and delete). Bundled references are a new building block to provide linearizable range query operations for highly concurrent linked data structures. At its core, a bundled reference maintains the history of a given data structure link to allow range queries to traverse a path through the data structure corresponding to a particular moment in time. By traversing only links that were &amp;ldquo;alive&amp;rdquo; at the range queries outset, a range query observes a view of the data structure that is consistent with the target atomic snapshot and is made of the minimal amount of nodes that should be accessed to preserve linearizability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jacob Nelson is a third-year PhD student at Lehigh University in Bethlehem, PA. His interests encompass a wide range of systems topics including highly concurrent data structures and distribution using remote direct memory access (RDMA). His most recent work is focused on how to leverage high performance one-sided RDMA operations to build a data-movement oriented transactional key-value store. Check out his &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt; for more info!&lt;/p&gt;

&lt;h1 id=&#34;dec-4&#34;&gt;Dec. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt; (&lt;em&gt;Cornell University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Vectorization for Digital Signal Processors via Equality Saturation&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Compute-heavy embedded systems, from augmented reality to 5G networking, rely on specialized hardware in the form of digital signal processors (DSPs). However, DSPs are designed to prioritize energy efficiency and predictability over programmability, with simple in-order architectures that offer little hardware-provided parallelism. Existing auto-vectorizing compilers can struggle to optimize small linear algebra kernels that rely on complex data movements. An expert can reach state-of-the-art performance by hand-writing specialized implementations to use vector instructions, but they must repeat this manual effort for each size instance. In this talk, I will describe Diospyros, a search-based compiler that automates this task of finding efficient vectorizations for smaller linear algebra kernels. Diospyros combines two automated reasoning techniques, symbolic evaluation and equality saturation over rewrite rules, to vectorize computations with irregular structure. We show that Diospyros outperforms DSP libraries by 2.8x on average and demonstrate how search-based techniques can help users reach performance competitive with expert tuning with less manual effort.&lt;/p&gt;

&lt;h1 id=&#34;dec-11&#34;&gt;Dec. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt; (&lt;em&gt;University of Pennsylvania&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular, compositional, and executable semantics for LLVM IR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The LLVM framework has been a long-time favorite for compiler enthusiasts. It is both a widely used industrial-strength compiler (most recognizably, Apple‚Äôs latest macOS and iOS development tools) and a popular research tool (winning the ACM Software Systems Award in 2012).&lt;/p&gt;

&lt;p&gt;How do we best ensure that LLVM-based tools (compilers, optimizers, code instrumentation passes, etc.) do what they‚Äôre supposed to ‚Äî especially for safety- or security-critical applications?&lt;/p&gt;

&lt;p&gt;This talk is an introduction to a novel formal semantics for a large, sequential subset of the LLVM IR, mechanized in the Coq proof assistant. We will see how the use of modern semantic reasoning techniques allow us to write a &lt;em&gt;compositional, modular, and executable&lt;/em&gt; semantics. In particular, I will discuss how the development of an &lt;em&gt;interaction tree&lt;/em&gt;-based semantics gives us (1) expressive combinators for defining compositional semantics, (2) a modular separation of concerns for effects in a language, and (3) a ‚Äúfor-free‚Äù extraction of an executable definitional interpreter.&lt;/p&gt;

&lt;p&gt;No experience with LLVM or formal verification technologies will be assumed.&lt;/p&gt;

&lt;p&gt;Source can be found on our &lt;a href=&#34;https://github.com/vellvm/vellvm&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
