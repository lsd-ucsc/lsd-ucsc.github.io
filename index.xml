<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</title>
    <link>http://lsd.ucsc.edu/</link>
    <description>Recent content in Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Sep 2025 12:00:00 -0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2025)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2025fa/</link>
      <pubDate>Wed, 03 Sep 2025 12:00:00 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2025fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, Reese Levine, and Achilles Benetopoulos &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2025, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-26&#34;&gt;Sept 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-3&#34;&gt;Oct 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jessica Dagostini, Yanwen Xu, and Patrick Redmond&lt;/td&gt;
&lt;td&gt;Conference Practice Talks&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-10&#34;&gt;Oct 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Reese Levine and Nathan Liittschwager&lt;/td&gt;
&lt;td&gt;Conference Practice Talks&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-17&#34;&gt;Oct 17 (Cancelled)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-24&#34;&gt;Oct 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tom Lyon&lt;/td&gt;
&lt;td&gt;NFS Must Die! (and how to get Beyond File Sharing in the Cloud)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-31&#34;&gt;Oct 31&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mingwei Zheng&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-7&#34;&gt;Nov 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-14&#34;&gt;Nov 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-21&#34;&gt;Nov 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-28&#34;&gt;Nov 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-5&#34;&gt;Dec 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;sept-26&#34;&gt;Sept. 26&lt;/h2&gt;

&lt;p&gt;Social Hour!&lt;/p&gt;

&lt;h2 id=&#34;oct-3&#34;&gt;Oct. 3&lt;/h2&gt;

&lt;p&gt;This week we will have practice talks for upcoming conference presentations.&lt;/p&gt;

&lt;p&gt;Jessica Dagostini: &lt;em&gt;miniGiraffe: A Pangenomic Mapping Proxy App&lt;/em&gt;, to appear at &lt;a href=&#34;https://iiswc.org/iiswc2025/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;IISWC 2025&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Yanwen Xu: &lt;em&gt;BetterTogether: A Interference-Aware Framework for Fine-grained Software Pipelining on Heterogeneous SoCs&lt;/em&gt;, to appear at IISWC 2025.&lt;/p&gt;

&lt;p&gt;Patrick Redmond: &lt;em&gt;Exploring the Theory and Practice of Concurrency in the Entity-Component-System Pattern&lt;/em&gt;, to appear at &lt;a href=&#34;https://2025.splashcon.org/track/OOPSLA?&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;OOPSLA 2025&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;oct-10&#34;&gt;Oct. 10&lt;/h2&gt;

&lt;p&gt;This week we will have practice talks for upcoming conference presentations.&lt;/p&gt;

&lt;p&gt;Reese Levine: &lt;em&gt;SafeRace: Assessing and Addressing WebGPU Memory Safety in the Presence of Data Races&lt;/em&gt;, to be presented at OOPSLA&lt;/p&gt;

&lt;p&gt;Nathan Liittschwager: &lt;em&gt;CRDT Emulation, Simulation, and Representation Independence&lt;/em&gt;, to be presented at ICFP.&lt;/p&gt;

&lt;h2 id=&#34;oct-17&#34;&gt;Oct. 17&lt;/h2&gt;

&lt;p&gt;Seminar cancelled because of &lt;a href=&#34;https://icfp25.sigplan.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ICFP&lt;/a&gt;/&lt;a href=&#34;https://2025.splashcon.org/track/OOPSLA?&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;OOPSLA&lt;/a&gt; and &lt;a href=&#34;https://sigops.org/s/conferences/sosp/2025/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;SOSP&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;oct-24&#34;&gt;Oct. 24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tom Lyon&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; NFS Must Die! (and how to get Beyond File Sharing in the Cloud)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; One of the most important lessons learned in distributed computing and concurrency is
that shared mutable data is a bad idea . What is the purpose of a network file system? – to provide
a shared mutable data space . There are many other problems with the NFS model at cloud scale. NFS
remains popular because its killer feature is access to large data sets, by network-unaware
applications, without having to first copy them. Using existing file systems, OverlayFS , and
NVMe-Over-Fabrics , we propose a new approach to achieve blazing-fast, highly scalable, and
consistent access to dynamic data sets. We solicit collaborators.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tom Lyon is a mostly retired computing systems architect, serial entrepreneur and UNIX
Greybeard. His most recent startup was DriveScale, which created a disaggregated server management
system, and was sold to Twitter in 2021. Prior to DriveScale, Tom was founder and Chief Scientist of
Nuova Systems, a start-up that led a new architectural approach to systems and networking. Nuova was
acquired in 2008 by Cisco, whose highly successful UCS servers and Nexus switches are based on
Nuova&amp;rsquo;s technology. He was also founder and CTO of two other technology companies. Netillion, Inc.
was an early promoter of memory-over-network technology. The Netillion team moved to Nuova Systems.
At Ipsilon Networks, Tom invented IP Switching. Ipsilon was acquired by Nokia and provided IP
routing and security technology for many operator and enterprise networks. As employee #8 at Sun
Microsystems he contributed to the UNIX kernel, led many networking and storage projects, and was
one of the NFS and SPARC architects. He started his Silicon Valley career at Amdahl Corp., where he
was a software architect responsible for creating Amdahl&amp;rsquo;s UNIX for mainframes technology. Tom holds
numerous US patents in system interconnects, memory systems, and storage. He received a BS in
Electrical Engineering and Computer Science from Princeton University.&lt;/p&gt;

&lt;h2 id=&#34;oct-31&#34;&gt;Oct. 31&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Mingwei Zheng&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;nov-7&#34;&gt;Nov. 7&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;nov-14&#34;&gt;Nov. 14&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;nov-21&#34;&gt;Nov. 21&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;nov-28&#34;&gt;Nov. 28&lt;/h2&gt;

&lt;p&gt;No seminar (Thanksgiving break)&lt;/p&gt;

&lt;h2 id=&#34;dec-5&#34;&gt;Dec. 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2025)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2025sp/</link>
      <pubDate>Sun, 30 Mar 2025 19:11:27 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2025sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, Reese Levine, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2025, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-4&#34;&gt;April 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Shadaj Laddad&lt;/td&gt;
&lt;td&gt;Hydro: Modular, Correct, and Performant Distributed Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-11&#34;&gt;April 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Eva Graversen&lt;/td&gt;
&lt;td&gt;A Theory of Choreographic Programming&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-18&#34;&gt;April 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Huaifeng Zhang&lt;/td&gt;
&lt;td&gt;The Hidden Bloat in Machine Learning Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-25&#34;&gt;April 25&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Oliver Kennedy&lt;/td&gt;
&lt;td&gt;Draupnir: A toolkit for scalable, easy-to-write declarative compilers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-2&#34;&gt;May 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-9&#34;&gt;May 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Patrick Redmond&lt;/td&gt;
&lt;td&gt;Formally-verified chimeric consensus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-16&#34;&gt;May 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Amanda Xu&lt;/td&gt;
&lt;td&gt;Synthesizing Quantum-Circuit Optimizers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-23&#34;&gt;May 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Abtin Molavi&lt;/td&gt;
&lt;td&gt;Qubit Mapping and Routing for an Evolving Quantum Hardware Landscape&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-30&#34;&gt;May 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;The world changes constantly; so should your systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-6&#34;&gt;June 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;april-4&#34;&gt;April 4&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Shadaj Laddad&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hydro: Modular, Correct, and Performant Distributed Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We’ve been stuck with programming models for distributed systems that force developers to individually program a fleet of sequential programs and manually reason about global correctness, or leverage frameworks that lock the developer into global scaling and fault tolerance decisions. Choreographic programming gives us a step in the right direction, by letting developers write distributed programs while avoiding opaque network boundaries. But it has significant limitations when it comes to reasoning about concurrent executions. In this talk, I’ll present the key ideas behind Hydro, a Rust framework for general-purpose distributed systems. I’ll show how Hydro leverages stream-choreographic programming to offer low-level control with strong correctness guarantees.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Shadaj is a final-year PhD student co-advised by Alvin Cheung and Joe Hellerstein in the Sky Computing Lab at UC Berkeley. He designs programming paradigms that make distributed systems modular, correct, accessible, and performant. His research spans foundational language design, program optimization, and formal methods. Shadaj is a co-organizer of the SF Systems Club, the largest systems-oriented meetup in the Bay Area, and loves to play the sitar in his spare time.&lt;/p&gt;

&lt;h2 id=&#34;april-11&#34;&gt;April 11&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Eva Graversen&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Theory of Choreographic Programming&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming promises a simple approach to the coding of concurrent and distributed systems: write the collective communication behavior of a system of processes as a choreography, and then the programs for these processes are automatically compiled by a provably-correct procedure known as endpoint projection. While this promise prompted substantial research, a theory that can deal with realistic communication failures in a distributed network remains elusive.&lt;/p&gt;

&lt;p&gt;In this talk, I will provide a theory of choreographic programming that addresses realistic communication failures taken from the literature of distributed systems: processes can send or receive fewer messages than they should (send and receive omission), and the network can fail at transporting messages (omission failure). This theory supports the programming of strategies for failure recovery, and a novel static analysis (called robustness) to check for delivery guarantees (at-most-once and exactly-once).&lt;/p&gt;

&lt;p&gt;A key technical innovation is a deconstruction of the usual communication primitive in choreographies to allow for independent implementations of the send and receive actions of a communication, while still retaining the static guarantee that these actions will correlate correctly (the essence of choreographic programming). This has two main benefits. First, each side of a communication can adopt its own failure recovery strategy, as in realistic protocols. Second, initiating new communications does not require any (unrealistic) synchronization over unreliable channels: senders and receivers agree by construction on how each message should be identified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Eva Graversen is a Postdoc at Tallinn University of Technology working on theoretical foundations of choreographic programming. Her PhD was under Iain Phillips and Nobuko Yoshida at Imperial College London, working on concurrent reversible computing.&lt;/p&gt;

&lt;h2 id=&#34;april-18&#34;&gt;April 18&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Huaifeng Zhang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The Hidden Bloat in Machine Learning Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, we explore the problem of bloat in machine learning (ML) systems and present key findings from our study. We begin by analyzing bloat in ML containers, which are widely used in modern cloud computing environments.
Next, we examine code bloat in shared libraries of popular ML frameworks such as TensorFlow and PyTorch. We introduce our approaches for debloating both ML containers and shared libraries. Our study reveals that both ML containers and shared libraries include a substantial amount of unnecessary files and code, which bloat their size and lead to performance degradation, resource waste, and increased security vulnerabilities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Huaifeng Zhang is a Ph.D. student in the Department of Computer Science at Chalmers University of Technology, advised by Prof. Ahmed Ali-Eldin Hassan. His research interests include software engineering, machine learning systems, cloud computing and blockchain. He also held positions at ByteDance and Google.&lt;/p&gt;

&lt;h2 id=&#34;april-25&#34;&gt;April 25&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Oliver Kennedy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Draupnir: A toolkit for scalable, easy-to-write declarative compilers&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Compilers and program analysis tools are defined by sets of rules, or productions, that govern how code is translated, optimized, or analyzed. Production rules are compositional, allowing compiler authors to subdivide a global objective into smaller-scale local logical units that are easier to reason about. For example, a compiler author writing an optimizer might specify a rule that identifies if-then-else statements, where the condition is trivially tautological, and replaces it withthe body of the then clause. When compiling (resp., optimizing, analyzing) a block of code, the compiler (or optimizer, or program analysis tool) iteratively selects an appropriate production rule, applies it, and repeats.&lt;/p&gt;

&lt;p&gt;The simplicity of local reasoning with production rules comes at the cost of redundant computation. To improve compile times, many production compilers adopt non-idiomatic design patterns, such as merging production rules or tracking non-local properties manually. While necessary for performance, such anti-patterns increase code complexity and make the code harder to maintain. In this talk, I will introduce Draupnir, a new compiler implementation framework based around a database engine. Draupnir allows compiler authors to continue expressing compiler logic through normal production rules, but approaches compilation, optimization, and analysis as forms of query processing. This shift in perspective allows Draupnir to leverage techniques from the database community, including Incremental View Maintenance (SIGMOD 2020), multi-query optimization (in-progress), optimization for the memory hierarchy (in-progress), and distribution (in-progress) to achieve orders of magnitude improvement in compile times, while simultaneously simplifying the logic of the compiler.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Oliver Kennedy is an associate professor at the University at Buffalo. He earned his PhD from Cornell University in 2011 and now leads the Online Data Interactions (ODIn) lab, which operates at the intersection of databases and programming languages. Oliver is the recipient of an NSF CAREER award, an IEEE Region 1 Technological Innovation Award, UB’s Exceptional Scholar Award, and several UB SEAS teaching awards. Oliver is also one of the founding board members of Breadcrumb Analytics. Several of Oliver’s papers have been invited to “Best of” compilations from SIGMOD and VLDB. The ODIn lab is currently exploring (i) how we can leverage database techniques like incremental view maintenance to make compilers faster, (ii) how to make it easier for data scientists to track how sources of uncertainty, ambiguity, and/or bias affect analyses, and (iii) how to streamline the interfaces — both human and software — between different tools for data science, like python, sql, and spreadsheets.&lt;/p&gt;

&lt;h2 id=&#34;may-2&#34;&gt;May 2&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;may-9&#34;&gt;May 9&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Patrick Redmond&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Formally-verified chimeric consensus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Distributed Consensus is the problem of reaching agreement among of set of networked nodes. For example, it could be reaching agreement about the next transition, among the many that are pending, to apply in a replicated database. Traditionally this problem was formulated among a fixed set of participants for which a minority may fail by crashing. If we extend the setting to include malicious participants, the problem may be called Byzantine Fault-Tolerant (BFT) Consensus. If we extended yet again to open systems, as opposed to systems with a globally known set of participants, it may now be called Permissionless Consensus. Solutions to consensus problems may be factored into a voting algorithm and a quorum system, i.e. a definition of what constitutes a set of votes sufficient to trigger a consensus decision. By decomposing the problem along these two axes, we are able to obtain a formally verified &amp;ldquo;chimeric&amp;rdquo; consensus implementation that uses the voting algorithm of Paxos with the permissionless quorum system of Stellar Consensus Protocol.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Patrick is a PhD student in the LSD Lab at UCSC advised by Lindsey Kuper. Patrick&amp;rsquo;s research explores the design, implementation, and verification of distributed and concurrent systems, with a PL-angle. Patrick has several years of industry experience, and hopes to help spread the use of software verification techniques there.&lt;/p&gt;

&lt;h2 id=&#34;may-16&#34;&gt;May 16&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Amanda Xu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Synthesizing Quantum-Circuit Optimizers&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Recent breakthroughs in quantum computing hardware have brought us closer to realizing the dream of quantum computers accelerating domains such as materials discovery. However, optimizing the programs we run on these error-prone devices is a critical software obstacle to overcome, which will remain even when we have achieved error correction at scale. As an additional roadblock, quantum hardware is diverse and constantly in flux as scientists run new experiments. To avoid the need for tedious manual updates to the optimizer with every hardware modification, my work aims to automatically synthesize a quantum-circuit optimizer for a given device.&lt;/p&gt;

&lt;p&gt;In this talk, I will first present QUESO, an efficient approach for synthesizing correct rewrite rules given the set of operations supported by a particular platform. QUESO is powered by an algebraic view of circuit semantics. Then I will discuss a follow-up work that introduced a framework to unify these fast rewrite rules with slow unitary synthesis &amp;mdash; two previously disparate ideas for optimizing quantum circuits. This work also presented a radically simple algorithm, GUOQ, for scheduling these optimizations in a way that exploits the synergies of rewriting and resynthesis. I will show how these automated approaches for discovering transformations and a good schedule for applying them outperform state-of-the-art hand-crafted alternatives.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Amanda Xu is a 4th year PhD student at the University of Wisconsin-Madison, advised by Aws Albarghouthi. Her research pushes the boundaries of quantum-circuit optimization using techniques from PL and formal methods. You can learn more and contact her at &lt;a href=&#34;https://amandashoe.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://amandashoe.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;may-23&#34;&gt;May 23&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Abtin Molavi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Qubit Mapping and Routing for an Evolving Quantum Hardware Landscape&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As Amanda discussed last week, quantum computing promises to unlock breakthroughs in important domains like materials science and chemistry. However, to realize this potential in practice, we need optimizing quantum circuit compilers which can adapt to a rapidly evolving landscape of quantum hardware.&lt;/p&gt;

&lt;p&gt;In this talk, I&amp;rsquo;ll elaborate on our efforts towards efficient and flexible quantum compilers by focusing on a compiler stage called qubit mapping and routing (QMR). The goal of QMR is to find a mapping from circuit qubits to physical locations on a target quantum device and plan the routing of multi-qubit gates in a way that is compliant with certain connectivity constraints.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll begin by considering the qubit mapping and routing problem for near-term quantum computers without error correction. Using a reduction to MaxSAT and a “circuit slicing” technique, we find better solutions than existing heuristic-based approaches while scaling further than existing constraint-based approaches. Then, we turn to the qubit mapping and routing problem for fault-tolerant quantum devices. We solve this problem by exploiting the dependency structure of circuit operations to formulate discrete optimization problems that can be solved near-optimally with simulated annealing. Finally, I&amp;rsquo;ll close by discussing our ongoing work towards a unified framework for QMR problems, including these two examples among several. By extracting the common core structure of QMR and isolating the problem-specific constraints, we enable automatic generation of the QMR compiler phase for a particular class of quantum computer from a concise description.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Abtin Molavi is a PhD candidate at the University of Wisconsin-Madison, advised by Aws Albarghouthi. In his research, he tackles problems that emerge in compiling quantum circuits to physical hardware by drawing from tools and techniques in PL and formal methods.&lt;/p&gt;

&lt;h2 id=&#34;may-30&#34;&gt;May 30&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The world changes constantly; so should your systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Programming distributed systems has never been easier, but making them perform well and efficiently exploit available resources remains stubbornly difficult. Programs that are incredibly fast on a single host slow to a crawl when given more resources, while systems designed for scale squander resources on modest problems.
In this talk, I will present magpie, a programming model and framework that builds on a principle of extreme adaptivity of data and compute placement, enabling fast code to remain fast when distributed while providing high-performance, data-intensive applications with richer correctness guarantees than state-of-the-art systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Achilles is a fourth year PhD candidate at UCSC, working at the intersection of distributed systems, databases, and programming languages with Peter Alvaro.&lt;/p&gt;

&lt;h2 id=&#34;june-6&#34;&gt;June 6&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2025)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2025wi/</link>
      <pubDate>Mon, 06 Jan 2025 19:11:27 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2025wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, Reese Levine, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2025, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-10&#34;&gt;Jan. 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Social Hour!&lt;/td&gt;
&lt;td&gt;&lt;em&gt;NA&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-17&#34;&gt;Jan. 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mako Bates&lt;/td&gt;
&lt;td&gt;Choreographic Programming in theory and practice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-24&#34;&gt;Jan. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tim Goodwin&lt;/td&gt;
&lt;td&gt;What if Kubernetes was a compiler target?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-31&#34;&gt;Jan. 31&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yan Tong&lt;/td&gt;
&lt;td&gt;Cykas, a new protocol for sender-side enforcement of causal message delivery&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-7&#34;&gt;Feb. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Roy Shadmon&lt;/td&gt;
&lt;td&gt;From Coordination to Inference: A Probabilistic Approach to Byzantine Agreement&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-14&#34;&gt;Feb. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jubi Taneja&lt;/td&gt;
&lt;td&gt;LLM-Vectorizer: LLM-Based Verified Loop Vectorizer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-21&#34;&gt;Feb. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mahita Nagabhiru&lt;/td&gt;
&lt;td&gt;Hardware support for lock-free programming&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-28&#34;&gt;Feb. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Callista Le&lt;/td&gt;
&lt;td&gt;Concurrent Data Structures Made Easy&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-7&#34;&gt;March 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td&gt;Canceled Due to the &lt;a href=&#34;https://standupforscience2025.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Stand Up For Science Rally&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-14&#34;&gt;March 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Abtin Molavi&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;jan-10&#34;&gt;Jan. 10&lt;/h2&gt;

&lt;p&gt;Social Hour!&lt;/p&gt;

&lt;h2 id=&#34;jan-17&#34;&gt;Jan. 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Mako Bates&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Choreographic Programming in theory and practice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Writing systems of concurrently executing programs is difficult: they can behave (and fail) in unexpected ways because of race conditions and deadlocks. When we talk about what we want these systems to do, we often tell “Alice &amp;amp; Bob” stories to describe the intended protocol. The fundamental idea of choreographic programming is that we can write real software that same way: as a single thread of activity described from a “3rd-party omniscient” perspective. Research on choreographic programming evolved out of formal protocol-specification methods over a decade ago, but systems that can actually be used to write software (e.g. Choral, HasChor, and MultiChor) are only a couple years old. My team and I have developed several such implementations with novel type-directed correctness guarantees. In this talk I will present a summary of our own work as well as a review of other relevant cutting-edge systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Mako Bates is a PhD candidate at the University of Vermont, advised by Joseph Near. He has done research and development of choreographic programming systems, secure multi-party computation, and differential privacy. Prior to starting his PhD, he worked in industry for several years.&lt;/p&gt;

&lt;h2 id=&#34;jan-24&#34;&gt;Jan. 24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tim Goodwin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What if Kubernetes was a compiler target?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Multi-tier programming, a concept from the programming languages community, provides abstractions for building multiple components of a distributed application as parts of a single program. Modern software development, however, often moves in the opposite direction: applications are typically composed of independently developed programs that are later integrated through service APIs. While distributing an application into independent units has its benefits, this approach requires developers to write repetitive plumbing code to connect application components and forces them to navigate an error-prone configuration and deployment process to ultimately get things working. Multi-tier programming offers a solution to these challenges, yet it remains relatively unknown in industry. However, closely related topics—such as “monolith vs. microservice,” “monorepo or separate repos,” and even “common language or polyglot”—receive lots of attention and discussion in the software engineering community. In this talk, I will provide an overview of multi-tier programming and how it might simplify software development on Kubernetes, a popular platform for running containerized applications. I will also demonstrate a prototype “Kubernetes compiler” that can turn a monolithic codebase into a distributed application that runs on Kubernetes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tim Goodwin is a 3rd year PhD student at UC Santa Cruz, advised by Lindsey Kuper and Andrew Quinn. His research focuses on cloud-native programming models and the challenges they present to developers. Prior to grad school, he wrangled with microservice complexity in industry.&lt;/p&gt;

&lt;h2 id=&#34;jan-31&#34;&gt;Jan. 31&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yan Tong&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Cykas, a new protocol for sender-side enforcement of causal message delivery&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Protocols for causal message delivery are widely used in distributed systems. Traditionally, causal delivery can be enforced either on the message sender’s side or on the receiver’s side. The traditional sender-side approach avoids the message metadata overhead of the receiver-side approach, but it is also more conservative than the receiver-side approach, meaning that messages are delivered later than necessary. We present Cykas (“Can you keep a secret?”), a new protocol for sender-side enforcement of causal delivery that sidesteps the conservativeness of the traditional sender-side approach by allowing the eager sending of messages and constraining the behavior of their recipients. Our experiments show that for applications involving long-running jobs, Cykas has a performance advantage: Cykas lets long-running jobs start (and end) earlier, leading to a shorter overall execution time compared to the traditional sender-side approach. We implemented the Cykas protocol using the Stateright implementation-level model checker for Rust and checked the safety and liveness of our implementation using a custom-implemented property checker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yan Tong is a 2nd year PhD student at UC Santa Cruz, advised by Lindsey Kuper. His research focuses on distributed messaging protocol.&lt;/p&gt;

&lt;h2 id=&#34;feb-7&#34;&gt;Feb. 7&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Roy Shadmon&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; From Coordination to Inference: A Probabilistic Approach to Byzantine Agreement&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Multi-agent sensor networks and control systems such as distributed cyber-physical systems, smart power grids, and robot swarms make important control decisions using inputs from networked sensor (or sensor-derived) data streams, some of which may be faulty or compromised. These inputs are used to update models that represent the physical state of the system under control and drive decision procedures that seek to achieve a goal (e.g., drone swarms follow the leader), maintain system properties (e.g., keep temperature near 70F), or enforce safety requirements (e.g., shutdown power if current exceeds 3A). Most real-world examples of these systems are inherently edge-based, thus requiring increased tolerance to signal noise, crash and network faults, as well as malicious components. Current approaches often fall short due to centralized designs with a single point of failure, but applying traditional Byzantine fault-tolerant agreement protocols is challenging due to the noisy nature of the input data streams. Existing approximate agreement protocols overlook latent information present in the proposed values, but extracting that information is complicated by the possibility that some values are malicious.&lt;/p&gt;

&lt;p&gt;In this talk, I will present Proximal Byzantine Agreement (PBA), a novel stochastic agreement protocol. PBA is based on Bayesian statistical inference driven by observations of replicated computation and provides statistically superior accuracy and reliability guarantees compared to current approximate agreement protocols. I will also talk about some of our ongoing work, including Centauri, a framework for organizing Byzantine fault-tolerant edge devices and sensor networks using PBA.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Roy Shadmon is a PhD candidate at UC Santa Cruz, advised by Owen Arden. His research focus comes at the intersection of multi-agent systems, Byzantine agreement, and Bayesian statistics.&lt;/p&gt;

&lt;h2 id=&#34;feb-14&#34;&gt;Feb. 14&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jubi Taneja&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; LLM-Vectorizer: LLM-Based Verified Loop Vectorizer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Compiler auto-vectorization promises performance gains through SIMD execution but often fails due to conservative heuristics and missed opportunities. Manually writing SIMD intrinsics, while effective, remains error-prone and inaccessible to most programmers.
What if Large Language Models (LLMs) could generate optimized SIMD code automatically? And more importantly—how can we trust the correctness of AI-generated transformations?
In this work, we explore the potential of Large Language Models (LLMs) to generate vectorized code from scalar loops and propose a finite-state multi-agent approach that combines LLMs with test-based feedback. Our results show speedups of 1.1x to 9.4x over state-of-the-art compilers (Intel Compiler, GCC, Clang).
To ensure correctness, we integrate Alive2 for formal verification and introduce scalability techniques that improve verification coverage. Our approach successfully verifies 38.2% of vectorizations on the TSVC benchmark.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jubi is a Research Engineer at Microsoft Research, where she explores the intersection of LLMs and compilers (LLMs for Compilers and Compilers for LLMs). Her broader research interests span compiler optimizations, formal verification, and program synthesis.
She earned her Ph.D. from the University of Utah under the guidance of Prof. John Regehr, where her work leveraged formal methods to enhance compiler construction. Her contributions to testing LLVM&amp;rsquo;s static analyses earned her both the Best Paper Award and Best Student Presentation Award at CGO 2020.
Beyond research, Jubi is deeply committed to mentorship. She has been a long-term mentor for SIGPLAN-M for the past five years, helping students navigate graduate school and supporting aspiring researchers in their academic journeys.&lt;/p&gt;

&lt;h2 id=&#34;feb-21&#34;&gt;Feb. 21&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Mahita Nagabhiru&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hardware support for lock-free programming&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Non-blocking algorithms, including lock-free programming, represent advanced concurrency techniques that go beyond traditional lock-based synchronization (e.g., mutexes or semaphores). Instead of relying on locks to protect shared resources, lock-free programs leverage hardware atomic primitives. This allows multiple threads to concurrently access shared data, effectively preventing issues like deadlocks and priority inversion. While powerful, lock-free programming is notoriously difficult to implement and verify. Its complexity demands a deep understanding of memory consistency models, atomic operations, memory ordering, and potential race conditions. However, the performance gains offered by lock-free techniques make them indispensable in high-performance applications such as databases, operating systems, and real-time systems. This work introduces lock-free programming, discusses the inherent challenges and then delves into practical examples of common lock-free data structures. Then explores advanced mechanisms such as multi-word compare-and-swap (MCAS) and lock-free hardware transactional memory (HTM), which simplify lock-free program development and offer stronger progress guarantees.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Mahita Nagabhiru is a CPU architect at Google. She works on Load/Store Unit- design and modelling, exploring performance features currently focused on store-to-load-forwarding. Her PhD was under Prof. Greg Byrd at NC State University, Raleigh in H/W support for lock-free programming. This talk is based on the research at NCSU.&lt;/p&gt;

&lt;h2 id=&#34;feb-28&#34;&gt;Feb. 28&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Callista Le&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Concurrent Data Structures Made Easy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Design of an efficient thread-safe concurrent data structure is a balancing act between its implementation complexity and performance. Lock-based concurrent data structures, which are relatively easy to derive from their sequential counterparts and to prove thread-safe, suffer from poor throughput under even light multi-threaded workload. At the same time, lock-free concurrent structures allow for high throughput, but are notoriously difficult to get right and require careful reasoning to formally establish their correctness. In this work, we explore a solution to this conundrum based on a relatively old idea of batch parallelism&amp;mdash;an approach for designing high-throughput concurrent data structures via a simple insight: efficiently processing a batch of a priori known operations in parallel is easier than optimising performance for a stream of arbitrary asynchronous requests. Alas, batch-parallel structures have not seen wide practical adoption due to (i) the inconvenience of having to structure multi-threaded programs to explicitly group operations and (ii) the lack of a systematic methodology to implement batch-parallel structures as simply as lock-based ones. We present OBatcher, a Multicore OCaml library that streamlines the design, implementation, and usage of batch-parallel structures. OBatcher solves the first challenge (how to use) by suggesting a new lightweight implicit batching design pattern that is built on top of generic asynchronous programming mechanisms. The second challenge (how to implement) is addressed by identifying a family of strategies for converting common sequential structures into the corresponding efficient batch-parallel versions, and by providing a library of functors that embody those strategies. We showcase OBatcher with a diverse set of benchmarks ranging from Red-Black and AVL trees to van Emde Boas trees, skip lists, and a thread-safe implementation of a Datalog solver. Our evaluation of all the implementations on large asynchronous workloads shows that (a) they consistently outperform the corresponding coarse-grained lock-based implementations, the only ones available in OCaml to date, and that (b) their throughput scales reasonably with the number of processors.&lt;/p&gt;

&lt;p&gt;This talk is based on work presented at OOPSLA 2024: &lt;a href=&#34;https://doi.org/10.1145/3689775&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://doi.org/10.1145/3689775&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Callista Le is currently a software engineer at Ahrefs, where she mainly works with OCaml. She graduated from Yale-NUS College in 2024 and wrote her final year thesis, Simple and Efficient Concurrent Data Structures via Batch Parallelism, under the supervision of Professor Ilya Sergey.&lt;/p&gt;

&lt;h2 id=&#34;march-7&#34;&gt;March 7&lt;/h2&gt;

&lt;p&gt;Canceled.&lt;/p&gt;

&lt;h2 id=&#34;march-14&#34;&gt;March 14&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Abtin Molavi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2024)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2024fa/</link>
      <pubDate>Thu, 12 Sep 2024 15:35:32 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2024fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, Gan Shen, and Reese Levine &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2024, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-4&#34;&gt;Oct 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jinsheng Ba&lt;/td&gt;
&lt;td&gt;Testing Database Engines via Query Plans&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-11&#34;&gt;Oct 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jonathan Castello&lt;/td&gt;
&lt;td&gt;Inductive diagrams for causal reasoning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-18&#34;&gt;Oct 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Bastian Köpcke&lt;/td&gt;
&lt;td&gt;Descend: A Safe Imperative GPU Programming Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-25&#34;&gt;Oct 25&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Haofan Zheng&lt;/td&gt;
&lt;td&gt;Decentagram: Highly-Available Decentralized Publish/Subscribe Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-1&#34;&gt;Nov 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Justin Lubin&lt;/td&gt;
&lt;td&gt;Programming By Navigation&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-8&#34;&gt;Nov 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Bhakti Shah&lt;/td&gt;
&lt;td&gt;Proof Visualization for Graphical Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-15&#34;&gt;Nov 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Federico Mora&lt;/td&gt;
&lt;td&gt;Automated Reasoning About Distributed Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-22&#34;&gt;Nov 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Haining Tong&lt;/td&gt;
&lt;td&gt;Towards Unified Analysis of GPU Consistency&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-6&#34;&gt;Dec 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yanan Guo&lt;/td&gt;
&lt;td&gt;Behind the Pixels: Unveiling GPU Hardware and Software Security Flaws&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;oct-4&#34;&gt;Oct 4&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jinsheng Ba&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Testing Database Engines via Query Plans&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Database Management Systems (DBMSs) are fundamental software systems that store, maintain, and retrieve data. They are used in almost every personal computer, mobile device, and server. Therefore, it is important to find bugs before they incur severe consequences. Automatic testing is an efficient and effective technique to find crash bugs, which terminate DBMSs, but is struggling to detect logic bugs and performance issues. Logic bugs refer to incorrect results, while performance issues refer to unexpected slow performance. Unlike crash bugs, both categories of bugs do not terminate DBMSs and are hard to observe by existing automatic testing methods. Triggering them requires valid test cases, which are also challenging to generate automatically. In my PhD thesis, I advance automatic testing to efficiently find logic bugs and performance issues in DBMSs. My approaches are united by the idea of leveraging query plans, which are internal representations of how a DBMS executes a query, for automatically testing DBMSs. I put forward the following thesis statement: Query plans allow efficient and effective testing of DBMSs by providing internal execution information. I propose four research works to utilize query plans for testing. First, to detect performance issues, I propose Cardinality Estimation Restriction Testing (CERT), which inspects estimated cardinalities in query plans without measuring execution time. Second, to identify logic bugs, I propose Differential Query Plans (DQP), which inspects the result consistency of multiple query plans of the same query. Third, to generate diverse test cases for exploring target systems thoroughly, I propose Query Plan Guidance (QPG) for guiding the test case generation process towards diverse query plans. Last, observing that query plans cannot be conveniently used as they are exposed in various DBMS-specific representations, I propose a Unified query plan representation (Uplan) based on an empirical study aiming to reduce the effort of building applications based on query plans. Since most DBMSs&amp;mdash;including commercial ones&amp;mdash;expose query plans to the user, I consider CERT, DQP, QPG, and Uplan generally applicable, black-box approaches for finding logic bugs, performance issues, and building applications on query plans. These methods are effective as they found more than 100 unique and previously unknown bugs in several widely used DBMSs. I view these results as a step towards more reliable DBMSs, and expect this statement of utilizing query plans for testing can be widely adopted to tackle more problems, such as test suite evaluation, debugging deployed DBMSs, and optimization checking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jinsheng Ba is a postdoctoral researcher in the Advanced Software Technologies (AST) Lab at ETH Zurich, mentored by Prof. Zhendong Su. He received his Ph.D. degree in Computer Science from National University of Singapore (NUS) in 2024, advised by Dr. Manuel Rigger. His research interests include software testing, security, and software engineering. His work has been recognized with Distinguished Paper Award twice at ASE 2022 and ICSE 2023. He is also a recipient of NUS Dean’s Graduate Research Excellence Award.&lt;/p&gt;

&lt;h2 id=&#34;oct-11&#34;&gt;Oct 11&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jonathan Castello&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Inductive diagrams for causal reasoning&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Causality diagrams are used throughout academia and industry to informally reason about the possible executions of distributed and concurrent systems. Their formal counterparts, what we&amp;rsquo;ll call Lamport executions, have been used since at least Lamport&amp;rsquo;s 1978 introduction of logical clocks. However, Lamport executions are not quite as visceral a model for humans as causality diagrams. This mismatch is exacerbated in modern proof assistants, which are geared toward &lt;em&gt;compositional reasoning&lt;/em&gt; over inductive data. In this talk, we&amp;rsquo;ll present a new formal representation of executions that is both inductively-structured and more similar to the informal diagrams we started with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jonathan is a third-year Ph.D. student at UC Santa Cruz. His research focuses on treating concurrency as something to be started from, rather than something to be introduced to an existing system. This perspective leads to interests in distributed systems, network protocols, and low-level hardware, among other threads(!). In his spare time, he nurtures a continued fascination with all things space.&lt;/p&gt;

&lt;h2 id=&#34;oct-18&#34;&gt;Oct 18&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Bastian Köpcke&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Descend: A Safe Imperative GPU Programming Language&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Programming massively parallel hardware such as Graphics Processing Units (GPU) is challenging to get right. Programmers must correctly and efficiently coordinate thousands of threads and their accesses to various shared memory spaces. Existing mainstream GPU programming languages, such as CUDA and OpenCL, are based on C/C++ inheriting their fundamentally unsafe ways to access memory via raw pointers. This facilitates easy to make, but hard to detect bugs, such as data races and deadlocks.&lt;/p&gt;

&lt;p&gt;In this talk, I will present Descend, our approach to a safe GPU programming language. In contrast to prior safe high-level GPU programming approaches, Descend is an imperative low-level GPU programming language in the spirit of Rust, enforcing safe CPU and GPU memory management in the type system by tracking Ownership and Lifetimes. Descend introduces a new holistic GPU programming model where computations are hierarchically scheduled over the GPU&amp;rsquo;s execution resources: grid, blocks, warps, and threads. Descend&amp;rsquo;s extended Borrow checking ensures that execution resources safely access memory regions without data races. For this, we introduced views describing safe parallel access patterns of memory regions, as well as atomic variables. For memory accesses that cannot be checked by our type system, users can annotate limited code sections as unsafe.&lt;/p&gt;

&lt;p&gt;I will discuss the memory safety guarantees offered by Descend at the hands of examples, take a brief look at the formal type system, and show an evaluation of the current implementation using multiple benchmarks, demonstrating that the approach that we take with Descend is capable of expressing real-world GPU programs showing competitive performance compared to manually written CUDA programs that are lacking Descend&amp;rsquo;s safety guarantees.&lt;/p&gt;

&lt;p&gt;This talk will be based on work that appeared at PLDI 2024: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3656411&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3656411&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Bastian is a Computer Science PhD student in the Parallel and Distributed Systems research group at the University of Münster, working closely with Michel Steuwer&amp;rsquo;s programming language and compiler group at TU Berlin. He is interested in programming languages, verification and compiler techniques to enable safer and more productive programming of parallel hardware.&lt;/p&gt;

&lt;h2 id=&#34;oct-25&#34;&gt;Oct 25&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Haofan Zheng&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Decentagram: Highly-Available Decentralized Publish/Subscribe Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, we will present Decentagram, a decentralized framework for data dissemination using the publish/subscribe messaging model. Decentagram uses blockchain smart contracts to authenticate events that will be published using digital signatures or self-attestation certificates from code running in trusted execution environments (TEEs), both of which are verified on-chain. This approach permits any host with valid credentials to publish verified updates, increasing decentralization and availability of the system as a whole by simplifying compensation and incentivization, even for untrusted hosts running TEEs. Decentagram also supports on-chain subscribers where third-party contracts receive events immediately: within the same transaction as the published event. The same event will also be delivered to off-chain subscribing applications through an off-chain event broker. We provide an open-source implementation of Decentagram, and evaluate the gas cost of its on-chain components and the end-to-end latency of its off-chain component.&lt;/p&gt;

&lt;p&gt;This presentation is based on the work by Haofan Zheng, Tuan Tran, Roy Shadmon, and Owen Arden, and was published at DSN 2024: &lt;a href=&#34;https://doi.org/10.1109/DSN58291.2024.00037&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://doi.org/10.1109/DSN58291.2024.00037&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Haofan is a Computer Science Ph.D. candidate at UC Santa Cruz, conducting research in the Decent Lab and the Languages, Systems, and Data (LSD) Lab. His work focuses on Trusted Execution Environments (TEEs) and blockchain technologies, exploring the intersection of these areas to enhance security in distributed systems. Haofan&amp;rsquo;s research aims to develop a framework for building secure distributed applications that ensures confidentiality, integrity, and availability by leveraging secure enclaves and blockchain.&lt;/p&gt;

&lt;h2 id=&#34;nov-1&#34;&gt;Nov 1&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Justin Lubin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming By Navigation&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Most commonly, a program synthesizer works by (1) requiring a specification from the user and (2) handing back a program that satisfies the specification, if one exists. Sometimes, this program is the smallest such program. Sometimes, it’s chosen via a user-defined cost function. And, sometimes, it’s just the one that came out of the synthesizer first!&lt;/p&gt;

&lt;p&gt;But what should we do if we want to hand control back to the user and let the user pick from among all the valid solutions—what we call the Particular Program Task? Can we solve it without just returning a stream of all valid programs? Can we solve it even if there are infinitely many programs to consider?&lt;/p&gt;

&lt;p&gt;To do so, we introduce the Programming By Navigation paradigm, which is based on a novel program synthesis problem that roughly states: Given a work-in-progress program, return all (and only) the valid next steps. We solve the Programming By Navigation synthesis problem with a new algorithm that turns information from a type inhabitation oracle (in the style of classical logic) into a concrete program (in the style of constructive logic). By structuring our algorithm as such, we can use an off-the-shelf Datalog engine as our type inhabitation oracle and reap the wealth of research and engineering efforts that have gone into modern Datalog engines for free. In the process, classic program synthesis optimizations such as observational equivalence pruning and memoization fall out naturally from existing Datalog optimizations. Based on preliminary results, our new algorithm solves the Particular Program Task faster than baselines.&lt;/p&gt;

&lt;p&gt;More broadly, I’ll talk about our deep, ongoing collaboration with experimental biologists that led to the design of Programming By Navigation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Justin is a PhD candidate in computer science advised by Sarah E. Chasins at UC Berkeley. His main research interest is co-designing programming systems with domain experts to empower them to write the code they need with autonomy. As part of this process, he collaborates closely with the Nuñez Lab at UC Berkeley, a group of experimental biologists who blend CRISPR-based genome and epigenome editing, functional genomics, cell biology, and biochemistry to understand the regulatory principles of the human genome.&lt;/p&gt;

&lt;h2 id=&#34;nov-8&#34;&gt;Nov 8&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Bhakti Shah&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Proof Visualization for Graphical Structures&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Reasoning about graphical languages in a proof assistant can be hard. Canonical diagrammatic representations are optimized for readability, and may abstract away details irrelevant to a pen-and-paper proof, but these details are often important to a proof assistant. We develop a methodology and library for working with graphical languages associated with classes of categories, and equip it with an automated visualizer integrated with the Coq proof assistant, enabling diagrammatic reasoning. We instantiate this with the ZX-calculus, a language for quantum computation, as an example of specialized diagrammatic reasoning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Bhakti Shah is a PhD student at the University of St. Andrews, advised by Edwin Brady, working on the interoperability of proof systems. She was previously at the University of Chicago, advised by Robert Rand, working on reasoning about diagrammatic languages in proof assistants. Her research interests broadly span the usability of interactive proof assistants.&lt;/p&gt;

&lt;h2 id=&#34;nov-15&#34;&gt;Nov 15&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Federico Mora&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Automated Reasoning About Distributed Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Designing and implementing distributed systems is still an enormous task for software engineers. Much of this challenge stems from the fact that bugs can arise from complex combinations of machine failures and message interleavings that are difficult for humans to reason about manually. As distributed systems become increasingly critical infrastructure, engineers will need more and more computational support to correctly build and deploy them.&lt;/p&gt;

&lt;p&gt;In this talk, I will present three automated reasoning techniques that can help software engineers build and deploy correct distributed systems. First, a domain-specific verification engine for message-passing distributed systems. Second, a decision procedure for a relevant fragment of logic. Third, a new approach for semi-automatically modelling distributed systems in a formal language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Federico Mora is a PhD candidate at the University of California, Berkeley, where he is advised by Sanjit A. Seshia. Federico’s research focuses on designing and implementing languages for automated reasoning. His studies have been supported by a Qualcomm Innovation Fellowship and three internships at Amazon Web Services, where he has applied many of the ideas described in his thesis.&lt;/p&gt;

&lt;h2 id=&#34;nov-22&#34;&gt;Nov 22&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Haining Tong&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Towards Unified Analysis of GPU Consistency&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; After more than 30 years of research, there is a solid understanding of the consistency guarantees given by CPU systems. Unfortunately, the same is not yet true for GPUs. The growing popularity of general purpose GPU programming has been a call for action which industry players like NVIDIA and Khronos have answered by formalizing their PTX and Vulkan consistency models. These models give precise answers to questions about program&amp;rsquo;s correctness. However, interpreting them still requires a level of expertise that escapes most developers, and the current tool support is insufficient. To remedy this, we translated and integrated the PTX and Vulkan models into the Dartagnan verification tool. This makes Dartagnan the first analysis tool for multiple GPU consistency models that can analyze real GPU code. During the validation of the translated models, we discovered two bugs in the original PTX and Vulkan consistency models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Haining is a Computer Science Ph.D. student advised by Keijo Heljanko at the University of Helsinki. His work focuses on using formal verification techniques to analyze GPU memory consistency models.&lt;/p&gt;

&lt;h2 id=&#34;dec-6&#34;&gt;Dec 6&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yanan Guo&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Behind the Pixels: Unveiling GPU Hardware and Software Security Flaws&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Today&amp;rsquo;s computing systems face significant security challenges. While security researchers have extensively studied CPU vulnerabilities, GPUs–an increasingly essential component of modern computing systems–have received much less attention.
In this talk, I will present two of my recent studies that help fill in this blank. In the first part, I will demonstrate how hardware designs in modern GPUs can enable practical and robust cache side channels. In the second part, I will discuss our findings on GPU memory management systems and their implications for GPU memory safety. Finally, I will briefly introduce countermeasures to these vulnerabilities and outline directions for future research in GPU security.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yanan Guo joins us as an Assistant Professor. Her research interests lie in computer architecture and cybersecurity, with a goal of building secure, high-performance computing systems. Specifically, she studies microarchitectural side channels, memory exploitation, machine learning security, as well as GPU systems and architectures. She has multiple CPU/GPU side-channel attacks. Her study on prefetch-based side channels was nominated for the Top Picks in Hardware and Embedded Security 2023.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2024)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2024sp/</link>
      <pubDate>Mon, 22 Jan 2024 15:35:32 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2024sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2024, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-5&#34;&gt;April 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Luke Geeson&lt;/td&gt;
&lt;td&gt;Compiler Testing with Relaxed Memory Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-12&#34;&gt;April 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dan Plyukhin&lt;/td&gt;
&lt;td&gt;Ozone: Fully Out-of-Order Choreographies&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-19&#34;&gt;April 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ismail Kuru&lt;/td&gt;
&lt;td&gt;Modal Abstractions for Virtualizing Memory Addresses&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-26&#34;&gt;April 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jennifer Switzer&lt;/td&gt;
&lt;td&gt;Hardware Repurposing to Reduce the Embodied Carbon of Computing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-3&#34;&gt;May 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Julian Haas&lt;/td&gt;
&lt;td&gt;LoRe: Reasoning about Safety and Consistency in Local-First Software&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-10&#34;&gt;May 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Robin Brown&lt;/td&gt;
&lt;td&gt;WebAssembly Components: The Modular Polyglot Ecosystem We Need&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-17&#34;&gt;May 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zach Sisco&lt;/td&gt;
&lt;td&gt;Hardware Decompilation: Recovering Abstraction in Digital Circuits&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-24&#34;&gt;May 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Guannan Wei&lt;/td&gt;
&lt;td&gt;Types and Metaprogramming for Correct, Safe, and Performant Software Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;May 31&lt;/td&gt;
&lt;td&gt;Canceled&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;June 7&lt;/td&gt;
&lt;td&gt;Canceled&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;april-5&#34;&gt;April 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Luke Geeson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compiler Testing with Relaxed Memory Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Finding bugs is key to the correctness of compilers in wide use today. If the behaviour of a compiled program, as allowed by its architecture memory model, is not a behaviour of the source program under its source model, then there is a bug. This holds for all programs, but we focus on concurrency bugs that occur only with two or more threads of execution. We focus on testing techniques that detect such bugs in C/C++ compilers.&lt;/p&gt;

&lt;p&gt;We seek a testing technique that automatically covers concurrency bugs up to fixed bounds on program sizes and that scales to find bugs in compiled programs with many lines of code. Otherwise, a testing technique can miss bugs. Unfortunately, the state-of-the-art techniques are yet to satisfy all of these properties.&lt;/p&gt;

&lt;p&gt;We present the Téléchat compiler testing tool for concurrent programs. Téléchat compiles a concurrent C/C++ program and compares source and compiled program behaviours using source and architecture memory models. We make three claims: Téléchat improves the state-of-the-art at finding bugs in code generation for multi-threaded execution, it is the first public description of a compiler testing tool for concurrency that is deployed in industry, and it is the first tool that takes a significant step towards the desired properties. We provide experimental evidence suggesting Téléchat finds bugs missed by other state-of-the-art techniques, case studies indicating that Téléchat satisfies the properties, and reports of our experience deploying Téléchat in industry regression testing.&lt;/p&gt;

&lt;p&gt;Based on work to appear in the International Symposium on Code Generation and Optimization (CGO) 2024:
&lt;a href=&#34;https://conf.researchr.org/info/cgo-2024/accepted-papers&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://conf.researchr.org/info/cgo-2024/accepted-papers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And recently presented work at The Future of Weak Memory Workshop (POPL) 2024:
&lt;a href=&#34;https://lukegeeson.com/talks/2024-01-15-POPL24/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://lukegeeson.com/talks/2024-01-15-POPL24/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Luke is a Computer Science PhD student at UCL, supervised by James Brotherston, Earl Barr, and Lee Smith. He is developing techniques to find concurrency bugs in C/C++ compilers using formal models of relaxed memory concurrency.&lt;/p&gt;

&lt;p&gt;He is based in the compiler teams at Arm in Cambridge where he assists engineers with finding bugs and deploying automated concurrency testing as part of an EPSRC grant. Luke&amp;rsquo;s opinions are his own and Arm does not endorse his work.&lt;/p&gt;

&lt;h2 id=&#34;april-12&#34;&gt;April 12&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Dan Plyukhin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Ozone: Fully Out-of-Order Choreographies&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a paradigm for writing distributed applications. It allows programmers to write a single program, called a choreography, that can be compiled to generate correct implementations of each process in the application. Although choreographies provide good static guarantees, they can exhibit high latency when messages or processes are delayed. This is because processes in a choreography typically execute in a fixed, deterministic order, and cannot adapt to the order that messages arrive at runtime. In non-choreographic code, programmers can address this problem by allowing processes to execute out of order &amp;ndash; for instance by using futures or reactive programming. However, in choreographic code, out-of-order process execution can lead to serious and subtle bugs, called communication integrity violations (CIVs).&lt;/p&gt;

&lt;p&gt;In this paper, we develop a model of choreographic programming for out-of-order processes that guarantees absence of CIVs and deadlocks. As an application of our approach, we also introduce an API for safe non-blocking communication via futures in the choreographic programming language Choral. The API allows processes to execute out of order, participate in multiple choreographies concurrently, and to handle unordered or dropped messages as in the UDP transport protocol. We provide an illustrative evaluation of our API, showing that out-of-order execution can reduce latency by overlapping communication with computation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dan works as a postdoc at the University of Southern Denmark and is receiving his PhD from the University of Illinois at Urbana-Champaign (UIUC). He is the author of the UIGC library for Akka, which provides fault-tolerant resource management for distributed actor systems. Dan’s research focuses on making distributed reactive applications easier to write and reason about.&lt;/p&gt;

&lt;h2 id=&#34;april-19&#34;&gt;April 19&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ismail Kuru&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modal Abstractions for Virtualizing Memory Addresses&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Virtual Memory Managers are critical pieces of general-purpose OS kernels. They enable virtualizing the addresses of memory regions by realizing the address translation mechanism using CPU&amp;rsquo;s memory management&amp;rsquo;s (MMU) kernel-controlled page tables. Operating systems manipulate these virtualized memory mappings to isolate untrusted processes, restrict which memory is accessible to different processes, hide memory limits from user programs, etc.&lt;/p&gt;

&lt;p&gt;Unfortunately, verifying them becomes challenging as they are interfaced by the complex hardware: the page tables are updated via writes to those memory locations, using addresses that are themselves virtualized!  Prior work on verification of VMM has either only handled a single address space, trusted significant pieces of assembly code, or resorted to direct reasoning over machine semantics rather than exposing a clean logical interface.&lt;/p&gt;

&lt;p&gt;In this talk, I will be explaining the logical abstractions, some of which are inspired by Hybrid Logic and allow us to mention resources (virtualized memory addresses) belonging to different address spaces within the same specification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am Ismail Kuru, a final year PhD student at Drexel University, and I am advised by Dr. Colin S. Gordon. Right before coming to Drexel, I was a senior software engineer at CRYTEK Gaming Company. Before then, I had finished my computer science masters courses at TU Munich and graduated with an M.S. degree from Koc University as a Microsoft Research EMEA scholar for graduate studies.&lt;/p&gt;

&lt;h2 id=&#34;april-26&#34;&gt;April 26&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jennifer Switzer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hardware Repurposing to Reduce the Embodied Carbon of Computing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Sustainable computing efforts have traditionally focused on runtime efficiency. However, a significant fraction of the carbon emissions associated with computing systems are incurred not during use, but rather manufacture. These embodied emissions are responsible for 40% of the lifetime carbon footprint for server-class hardware, and as much as 80% for consumer electronics like smartphones.
This work presents a new way of thinking about sustainable computing, in terms of both operational and embodied emissions. It explores one consequence of this thinking—that reducing the demand for newly manufactured hardware is an important strategy for emissions reduction. To this end, we propose the repurposing of consumer-class hardware as general purpose computing or sensing hardware. This is explored through several real-world deployments of repurposed smartphones. We find that repurposed devices can provide a computing platform that is several times more carbon-efficient than the alternative of manufacturing new hardware, and explore the applications for which repurposed devices are best suited.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jennifer Switzer is a PhD candidate at UC San Diego. Her research interests lie at the intersection of sustainability and computing systems, and especially efforts to reduce the embodied carbon footprint of computing. She is supported by a Google Fellowship.&lt;/p&gt;

&lt;h2 id=&#34;may-3&#34;&gt;May 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Julian Haas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; LoRe: Reasoning about Safety and Consistency in Local-First Software&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The &amp;ldquo;Local-First Software&amp;rdquo; movement calls for distributed applications that move data processing from the cloud back to local user devices. This allows for applications that work offline and preserve user privacy while still enabling collaboration and data synchronization. Unfortunately, the distributed and asynchronous nature of such applications makes them hard to reason about and existing programming models provide little to no support for verification.&lt;/p&gt;

&lt;p&gt;We propose LoRe, a programming language and compiler that automatically verifies developer-supplied safety properties for local-first applications. LoRe combines the declarative data flow of reactive programming with static analysis and verification techniques to precisely determine concurrent interactions that violate safety invariants and to selectively employ strong consistency through coordination where required. We introduce a formalized proof principle and demonstrate how to automate the process in a prototype implementation that outputs verified executable code.&lt;/p&gt;

&lt;p&gt;The talk will be based on work that appeared in the ACM Transactions on Programming Languages and Systems (TOPLAS) 2024: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3633769&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3633769&lt;/a&gt;
And at ECOOP 2023: &lt;a href=&#34;https://doi.org/10.4230/LIPIcs.ECOOP.2023.12&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://doi.org/10.4230/LIPIcs.ECOOP.2023.12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Julian is a third-year PhD student at TU Darmstadt in Germany, supervised by Mira Mezini and co-supervised by Annette Bieniusa at TU Kaiserslautern. In his research, he is working on programming languages and verification tools for distributed systems, with a focus on privacy-preserving decentralized applications. When not in front of a screen, he enjoys hiking and playing board games.&lt;/p&gt;

&lt;h2 id=&#34;may-10&#34;&gt;May 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Robin Brown&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; WebAssembly Components: The Modular Polyglot Ecosystem We Need&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; With the release of &lt;a href=&#34;https://bytecodealliance.org/articles/WASI-0.2&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WASI 0.2&lt;/a&gt; and the &lt;a href=&#34;https://component-model.bytecodealliance.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Component Model&lt;/a&gt;, WebAssembly (Wasm) has facilities for high-level interop between Wasm guests and hosts, as well as other guests. While some of this was possible with various project-bespoke ABIs, having a shared standards-track canonical ABI and Component Model enables the creation of a broader ecosystem without fragmentation.&lt;/p&gt;

&lt;p&gt;An increasing number of programming languages are able to produce components which implement the standard WASI &amp;ldquo;worlds&amp;rdquo; for &lt;a href=&#34;https://github.com/WebAssembly/wasi-http&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;servers&lt;/a&gt; and &lt;a href=&#34;https://github.com/WebAssembly/wasi-cli&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;CLI&lt;/a&gt; applications as well as an infinite variety of custom interfaces. There&amp;rsquo;s also been innovation in tools like &lt;a href=&#34;https://github.com/bytecodealliance/wac&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WAC&lt;/a&gt; that make it possible to compose arbitrary components statically with strong static type checking. This makes Wasm incredibly powerful as a way to build modular composable polyglot systems.&lt;/p&gt;

&lt;p&gt;The ecosystem being built around Wasm and the Component Model make it a very promising target for new programming languages especially if they build Component-native toolchains and take the most advantage of WASI, the &lt;a href=&#34;https://github.com/bytecodealliance/registry/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Warg&lt;/a&gt; registry protocol, Wasm-to-Wasm optimizers like &lt;a href=&#34;https://github.com/WebAssembly/binaryen&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Binaryen&lt;/a&gt;, and Wasm-based dev tools like &lt;a href=&#34;https://github.com/esoterra/wow&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wow&lt;/a&gt;. I created a new language called &lt;a href=&#34;https://github.com/esoterra/claw-lang&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Claw&lt;/a&gt; recently to demonstrate this and also provide an ideal &amp;ldquo;glue code&amp;rdquo; language for augmenting and testing existing Components.&lt;/p&gt;

&lt;p&gt;In this talk, I will
* explain what Wasm and Components are,
* summarize the state of the Wasm ecosystem,
* argue that language designers and developers should consider targetting Wasm,
* and give a live demo of Claw and Wow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Robin Brown is a co-chair of a Bytecode Alliance group that brings together programming language ecosystems and helps them create Wasm component tooling that feels native to their ecosystem, which is called the Guest Languages SIG. She is also the creator of the compile-to-component programming language Claw and the co-creator of the Warg protocol, which is an open source Wasm registry protocol with a focus on supply chain security, federation, and offline mirroring.&lt;/p&gt;

&lt;h2 id=&#34;may-17&#34;&gt;May 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zach Sisco&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Hardware Decompilation: Recovering Abstraction in Digital Circuits&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; My research introduces the problem of &amp;ldquo;hardware decompilation&amp;rdquo;. Analogous to software decompilation, hardware decompilation is about analyzing a low-level artifact&amp;mdash;in this case a netlist, i.e., a graph of wires and logical gates representing a digital circuit&amp;mdash;in order to recover higher-level programming abstractions, and using those abstractions to generate code written in a hardware description language (HDL). The overall problem of hardware decompilation requires a number of pieces. In my initial paper, published at PLDI 2023, I focus on one specific piece of the puzzle: a technique called &amp;ldquo;hardware loop rerolling&amp;rdquo;. Hardware loop rerolling leverages clone detection and program synthesis techniques to identify repeated logic in netlists (such as would be synthesized from loops in the original HDL code) and reroll them into syntactic loops in the recovered HDL code. In this talk, I will introduce what hardware decompilation is, and why you would want to use a hardware decompiler. Then, I will describe my solution to the hardware loop rerolling problem, and give a preview of in-progress work tackling more aspects of hardware decompilation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zach Sisco is a PhD candidate at UC Santa Barbara. He is advised by Professors Jonathan Balkind and Ben Hardekopf. Zach&amp;rsquo;s research is about applying solver-aided programming techniques to problems in hardware design. His website is: &lt;a href=&#34;https://zsisco.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://zsisco.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;may-24&#34;&gt;May 24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Guannan Wei&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Types and Metaprogramming for Correct, Safe, and Performant Software Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I will present some novel directions to build correct, safe, and performant software systems using programming languages and metaprogramming techniques. In the first part of the talk, I will present reachability type systems, a family of static type systems to track sharing, separation, and side effects in higher-order imperative programs. Reachability types lead to a smooth combination of Rust-style ownership types with higher-level programming abstractions (such as first-class functions). In the second part, I will discuss how metaprogramming techniques can help build correct, flexible, and performant program analyzers. I will present GenSym, a parallel symbolic-execution compiler that is derived from a high-level definitional symbolic interpreter using program generation techniques. GenSym generates code in continuation-passing style to perform parallel symbolic execution of LLVM IR programs, and significantly outperforms similar state-of-the-art tools. The talk also covers my future research plan to apply reachability types in designing languages for quantum computing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Guannan Wei is a postdoctoral researcher at Purdue University. He will join Tufts University as a tenure-track assistant professor in Fall 2025. His research interests lie in programming languages and software engineering. His contributions have been published in flagship programming languages and software engineering venues, such as POPL, OOPSLA, ICFP, ECOOP, ICSE, and ESEC/FSE. Guannan received his PhD degree (2023) in Computer Science from Purdue University, advised by Tiark Rompf. More of Guannan’s work can be found at &lt;a href=&#34;https://continuation.passing.style&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://continuation.passing.style&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2024)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2024wi/</link>
      <pubDate>Thu, 07 Dec 2023 18:02:29 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2024wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper, Tyler Sorensen, and Gan Shen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2024, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-12&#34;&gt;Jan. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Beta Ziliani&lt;/td&gt;
&lt;td&gt;Making monkeys and ducks behave with Crystal Lang&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-19&#34;&gt;Jan. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Talk rescheduled for &lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-26&#34;&gt;Jan. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Devashish Purandare&lt;/td&gt;
&lt;td&gt;Shimmer: Supercharging Adoption of Modern SSD Interfaces&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-2&#34;&gt;Feb. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Joe Cutler&lt;/td&gt;
&lt;td&gt;delta: ordered types for stream processing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Katherine Philip&lt;/td&gt;
&lt;td&gt;Formalizing Type-Directed Specialization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-16&#34;&gt;Feb. 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Laura Israel&lt;/td&gt;
&lt;td&gt;The Persistence of Past: A Demand Semantics for Mechanized Cost Analysis of Lazy Programs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-23&#34;&gt;Feb. 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;Don&amp;rsquo;t Let APIs Constrain Your Distributed Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-1&#34;&gt;March 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Karuna Grewal&lt;/td&gt;
&lt;td&gt;Expressive Policies for Microservice Networks&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-8&#34;&gt;March 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Abhiroop Sarkar&lt;/td&gt;
&lt;td&gt;HasTEE+ - Confidential Computing with Haskell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-15&#34;&gt;March 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Matthew C. Davis&lt;/td&gt;
&lt;td&gt;NaNofuzz to TestLoop: A Journey from Empirical to Theoretical Research (and back again)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;jan-12&#34;&gt;Jan. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Beta Ziliani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Making monkeys and ducks behave with Crystal Lang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In the zoo of programming languages there are two cute yet rather misbehaved animals, typically found in the Dynamic Languages section: the Duck Typing and the Monkey Patching.&lt;/p&gt;

&lt;p&gt;The Duck Typing is hardly seen.  You hear a “quack!“, but you can’t easily tell if it’s coming from an actual duck, a parrot, or a recording.  Monkey Patching, like the name suggests, patches any existing creature to change their behavior.  It can even make a dog quack!&lt;/p&gt;

&lt;p&gt;While these two animals bring lots of joy, they are also quite dangerous when used in the wild, as they can bring unexpected behavior to the rest of the creatures.&lt;/p&gt;

&lt;p&gt;Crystal is a rarity in the Static Languages section that has Duck Typing and Monkey Patching.  Given the strong &amp;ndash; yet barely visible &amp;ndash; fences of types, it manages to properly contain these beasts.  In this talk I will present Crystal and provide a glimpse at how it manages to feel so dynamic while being safe and efficient.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Beta leads the development of the Crystal Programming Language and teaches about programming languages at Universidad Nacional de Córdoba in Argentina.  With a recent past as a researcher in programming languages, he developed tools and theories for two very different languages: Coq and Lua.  He has no ducks nor monkeys, despite them being effective weapons against Córdoba&amp;rsquo;s venomous scorpions.&lt;/p&gt;

&lt;h1 id=&#34;jan-19&#34;&gt;Jan. 19&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Rescheduled for &lt;a href=&#34;#feb-9&#34;&gt;Feb. 9&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;jan-26&#34;&gt;Jan. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Devashish Purandare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Shimmer: Supercharging Adoption of Modern SSD Interfaces&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; While the demand for NAND-flash-based storage keeps growing, capacity increase comes at the cost of degradation in performance and device lifetime. Traditional storage abstractions exacerbate such degradation, increasing garbage collection overhead due to in-place updates. Even flash-optimized append-only systems suffer the overhead of interleaving unrelated data streams. Host-device coordination techniques allow the host to provide the device with hints, which help the SSD to ensure performance isolation across write streams and reduce garbage collection overhead by grouping data related by lifetime. However, such devices have seen limited adoption due to the difficulty of rewriting applications and filesystems and the impact on their stability, security, and portability in the face of changing interfaces.&lt;/p&gt;

&lt;p&gt;We present Shimmer, an all-userspace shim layer that enables host-device coordination with no change to the system or the application. Shimmer utilizes application insights to provide intelligent placement hints to any capable storage backend and can shield applications and filesystems from changing interfaces. We demonstrate Shimmer&amp;rsquo;s ease of adoption by enabling host-device coordination for popular IO intensive applications: RocksDB, WiredTiger and Cachelib. Shimmer improves write throughput by 20-90%, depending on the application over modern filesystems like f2fs and can match application-specific backends like ZenFs, offering up to 14× lower tail latency and reduced write amplification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dev is a PhD candidate researching storage systems, SSDs, and data management at the Center for Research in Storage and Systems, UC Santa Cruz. He works on systems that enable easier host-device coordination for performance and reliability improvements. His latest project, Shimmer, allows easy shim layers to generate and provide lifetime hints that improve the performance of log-structured systems on top of SSDs with no change to applications or operating systems.He will be graduating in March and is actively seeking full time opportunities.&lt;/p&gt;

&lt;h1 id=&#34;feb-2&#34;&gt;Feb. 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Joe Cutler&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; delta: ordered types for stream processing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present delta, a new language for building stream processing programs. Unlike other streaming languages which restrict the programmer to a small set of combinators, programs in delta are written as standard functional list programs, written as if they transform the entire input at once.  However, delta is equipped with a semantics which runs these list programs as stream programs, producing their outputs incrementally as inputs arrive.  To accomplish this, delta uses a novel “ordered” substructural type system to ensure that all well-typed programs can be executed incrementally. The type system also enforces further guarantees, ensuring that the programs are monotone — they never “retract” a previous output — and that they are deterministic, even in the presence of parallel inputs. In the talk, I’ll discuss the design of the delta type system, how it guarantees the above properties, and how it enables a radical new programming model for stream processing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Joe Cutler is a 3rd year PhD Student at The University of Pennsylvania, where he works with Benjamin Pierce on all things type systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-9&#34;&gt;Feb. 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Katherine Philip&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Formalizing Type-Directed Specialization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present a formal study of type-directed specialization, an implementation and optimization technique for implementing parametric polymorphism in programming languages. Type-directed specialization (also known as monomorphization) systematically eliminates polymorphic code by generating monomorphic copies, each specialized for a particular type. We focus on the full specialization of parametric polymorphic expressions in an ML-like language that uses the Hindley-Milner type system. We formalize this with a family of representation transformation functions that translate source language programs into a novel target language that is capable of binding the potentially infinite families of specialized functions generated by full specialization. A key contribution of this paper is to prove that these functions preserve typing for all well-typed source programs. Finally, we lay the groundwork for future study of semantics preservation and for the formalization of other kinds of specialization and representation transformations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Katherine is a PhD student at Portland State University, advised by Mark P. Jones. They are interested in the design and implementation of efficient languages for low-level systems development. Currently, they are working on the Habit programming language (&lt;a href=&#34;https://www.habit-lang.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.habit-lang.org/&lt;/a&gt;).&lt;/p&gt;

&lt;h1 id=&#34;feb-16&#34;&gt;Feb. 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Laura Israel&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The Persistence of Past: A Demand Semantics for Mechanized Cost Analysis of Lazy Programs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Lazy evaluation is a powerful tool that enables better compositionality and potentially better performance in functional programming, but it is challenging to analyze its computation cost. Existing works either require manually annotating sharing, or rely on separation logic to reason about heaps of mutable cells. In this paper, we propose a bidirectional demand semantics that allows for reasoning about the computation cost of lazy programs without relying on special program logics. To show the effectiveness of our approach, we apply the demand semantics to formally prove that Okasaki&amp;rsquo;s banker&amp;rsquo;s queue is both amortized and persistent using the Coq theorem prover. We also propose the reverse physicist&amp;rsquo;s method, a novel variant of the classical physicist&amp;rsquo;s method, which enables mechanized, modular and compositional reasoning about amortization and persistence with the demand semantics.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Laura Israel is a first-year doctoral student at Portland State University studying formal verification with Yao Li. She has a particular interest in complexity theory and its formalization in proof assistants. Laura developed a passing interest in theoretical CS while getting her BA in Psychology at Reed College, resulting in a stint in the tech industry, then culminating in her current research at PSU. When she&amp;rsquo;s not doing math thinly-veiled as computer science, you can find her hanging out with her cat Socks, running Dungeons and Dragons, or writing (and occasionally publishing) short stories.&lt;/p&gt;

&lt;h1 id=&#34;feb-23&#34;&gt;Feb. 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title&lt;/strong&gt;: Don&amp;rsquo;t Let APIs Constrain Your Distributed Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;: Large scale distributed applications frequently consist of compositions of independent systems communicating over RPC-like interfaces. Despite the familiar model they offer, RPCs constitute a low-level programming interface; just like an application programmer needs to be aware of how a computer executes their program when writing in something like C, they need to become distributed systems experts to correctly implement complex distributed application logic. Additionally, the shared-nothing model that underpins these systems as well as the hard boundaries established by the remote service interfaces introduce overheads in the hot path of applications and preclude end-to-end optimizations. As distribution becomes more pervasive, and as our understanding of the limitations of attempting to scale out computation over the network deepens, it is time to reimagine the role of infrastructure in orchestrating distribution and empowering domain experts with big data problems but not necessarily the distributed systems expertise to implement a bespoke system for their needs.&lt;/p&gt;

&lt;p&gt;We introduce Magpie, a distributed single-level store and runtime. Magpie, like Distributed Shared Memory systems before it, organizes application data in a unified global address space. Unlike previous systems, Magpie always co-locates a computation with its set of data dependencies, avoiding the coherence overheads that made DSM untenable. We accomplish this co-location through fine-grained data and code mobility, enabled by a programming model that allows users to write programs as compositions of local, location-independent functions, which the runtime is free to schedule anywhere in the cluster their data dependencies can be met. In this talk I will go over Magpie’s design, its programming model, and our experience using it to build distributed infrastructure and applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio&lt;/strong&gt;: Achilles is a third year PhD candidate at UCSC, working at the intersection of distributed systems, databases, and programming languages with Peter Alvaro. He &lt;a href=&#34;https://lsd.ucsc.edu/lsd-seminar/2021sp/#april-16&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;still cooks&lt;/a&gt; when he gets too frustrated by computers.&lt;/p&gt;

&lt;h1 id=&#34;march-1&#34;&gt;March 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Karuna Grewal&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Expressive Policies for Microservice Networks&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Microservice-based application deployments need to administer safety
properties while serving requests. However, today such properties can
be specified only in limited ways that can lead to overly permissive
policies and the potential for illegitimate flow of information across
microservices, or ad hoc policy implementations.&lt;/p&gt;

&lt;p&gt;We argue that a range of use cases require safety properties for the
flow of requests across the whole microservice network, rather than
only between adjacent hops. To begin specifying such expressive
policies, we propose a system for declaring and deploying service tree
policies. These policies are compiled down into declarative filters
that are inserted into microservice deployment manifests. We use a
light-weight dynamic monitor based enforcement mechanism, using ideas
from automata theory. Experiments with our preliminary prototype show
that we can capture a wide class of policies that we describe as case
studies.&lt;/p&gt;

&lt;p&gt;(This is a joint work with Brighten Godfrey from UIUC and Justin Hsu
from Cornell University that appeared at HotNets&amp;rsquo;23.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Karuna Grewal is a third year Ph.D. student in the Computer Science
department at Cornell University advised by Prof. Justin Hsu. Her
current research focus is to apply techniques from programming
languages and formal methods to distributed and networked systems with
a focus on security properties.&lt;/p&gt;

&lt;h1 id=&#34;march-8&#34;&gt;March 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Abhiroop Sarkar&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HasTEE+ - Confidential Computing with Haskell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This talk presents HasTEE+, a Domain-Specific Language in Haskell designed for seamless programming of Trusted Execution Environments (TEEs). HasTEE+ offers a high-level programming model that uses the Haskell-type system to compartmentalise confidential portions of a program within the TEE unit. It then allows the specification of Information Flow Control (IFC) policies and incorporates a dynamic mechanism for enforcing them. HasTEE+ also includes built-in support for remote attestation using the Intel RA-TLS protocol. The practicality of HasTEE+ was demonstrated through various practical case studies including a Federated Learning system and a Data Clean Room. I will conclude the talk by discussing potential research avenues for enhancing the security guarantees provided by HasTEE+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Abhiroop Sarkar is a final year PhD student at Chalmers University, Sweden. Defending his thesis at the end of March, his research involves improving systems security for both cloud and embedded environments using programming language techniques, particularly functional programming.&lt;/p&gt;

&lt;h1 id=&#34;march-15&#34;&gt;March 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Matthew C. Davis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; NaNofuzz to TestLoop: A Journey from Empirical to Theoretical Research (and back again)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software testing labor cost in the United States exceeded an estimated $47 billion in 2021. For 50 years, Automatic Test sUite Generators (ATUGs) have intended to help developers generate test suites. The vast majority of ATUGs have focused on effectiveness measures such as code coverage, mutants killed, and bugs elicited. But few ATUGs have focused on the developer&amp;rsquo;s experience. In this talk we discuss NaNofuzz, an ATUG that focuses on the developer&amp;rsquo;s experience, as well as TestLoop, a theoretical model of the developer&amp;rsquo;s test suite generation process. We describe ways in which our empirical ATUG research informs and refines our theoretical research &amp;ndash; and vice-versa.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Matthew C. Davis is a Software Engineering PhD student at Carnegie Mellon University’s School of Computer Science and is advised by Dr. Brad A. Myers and Dr. Joshua Sunshine. Matthew&amp;rsquo;s research focuses on interventions that improve the human ability to build and test useful software and is motivated by twenty years of experience as a software engineer and as a global technology director in industry, where he observed first-hand many ways in which developers encounter barriers to efficiently and effectively using various types of common software engineering tools.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023fa/</link>
      <pubDate>Fri, 11 Aug 2023 19:47:53 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-29&#34;&gt;Sept. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vikram Narayanan&lt;/td&gt;
&lt;td&gt;Towards fine-grained compartmentalization of operating system kernels&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-6&#34;&gt;Oct. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Nick Rioux&lt;/td&gt;
&lt;td&gt;Compositional &amp;amp; Scalable Programming in Granite&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-13&#34;&gt;Oct. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Harrison Goldstein&lt;/td&gt;
&lt;td&gt;Advancing Property-Based Testing in Theory and Practice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-20&#34;&gt;Oct. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Adrian Lehmann&lt;/td&gt;
&lt;td&gt;VyZX: Formal Verification of a Graphical Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-27&#34;&gt;Oct. 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Elaine Li&lt;/td&gt;
&lt;td&gt;Multiparty Session Type Projection and Subtyping with Automata&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-3&#34;&gt;Nov. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Karine Even-Mendoza&lt;/td&gt;
&lt;td&gt;GrayC: Greybox Fuzzing of Compilers and Analysers for C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-17&#34;&gt;Nov. 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Suha S. Hussain&lt;/td&gt;
&lt;td&gt;MLFiles: Using Input-Handling Bugs to Inject Backdoors Into Machine Learning Pipelines&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-1&#34;&gt;Dec. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kelly Kaoudis&lt;/td&gt;
&lt;td&gt;Systems security in practice: threat modelling at Trail of Bits&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-8&#34;&gt;Dec. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Susan Tan&lt;/td&gt;
&lt;td&gt;TULIP🌷 : Transcompilation Undergoes LLVM-IR for Interactive Parallelization&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-29&#34;&gt;Sept. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  Vikram Narayanan&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Towards fine-grained compartmentalization of operating system kernels&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Commodity operating systems execute core kernel subsystems in a single
address space along with hundreds of dynamically loaded extensions and
device drivers. Lack of isolation within the kernel implies that a
vulnerability in any of the kernel subsystems or device drivers opens
a way to mount a successful attack on the entire kernel. Historically,
isolation within the kernel remained prohibitive due to the high cost
of hardware isolation primitives. Recent CPUs, however, bring a new
set of mechanisms. Extended page-table (EPT) switching with VM
functions and memory protection keys (MPKs) provide memory isolation
and invocations across boundaries of protection domains with overheads
comparable to system calls.&lt;/p&gt;

&lt;p&gt;I will talk about how we developed a collection of techniques for
lightweight isolation of privileged kernel code(LXDs and LVDs) that
demonstrates near-native performance of two (network, block)
high-performance device drivers. I will present KSplit, a framework
for isolating unmodified device drivers in a modern, full featured
kernel that performs automated analyses on the unmodified source code
of the kernel and the driver to identify shared state and
synchronization requirements for efficient isolation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vikram recently graduated with a PhD from the University of
Utah. His research interests are building secure operating system
kernels, and heterogeneous systems.&lt;/p&gt;

&lt;h1 id=&#34;oct-6&#34;&gt;Oct. 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Nick Rioux&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compositional &amp;amp; Scalable Programming in Granite&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Granite is a strict and untyped programming language under development with the
goal of enhancing functional programming along a number of axes.
It aims to provide a basis for general-purpose programming that is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compositional: It is easy to extend (mutually) recursive functions to
support new cases.&lt;/li&gt;
&lt;li&gt;Expressive: Programmers can work with both the rich data structures common
in functional programming as well as cyclic data more naturally supported by
Datalog.&lt;/li&gt;
&lt;li&gt;Scalable: Programs naturally incorporate parallelism in a manner reminiscent
of LVars. This should also extend to eventually consistent-by-design distributed
computation a la CRDTs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps surprisingly, these three aspects of language design are related:
Granite&amp;rsquo;s design is emerging from the observation that the key to achieving each
of the above-mentioned goals is a join-semilattice. Granite makes semilattice
structure a first-class language feature; we&amp;rsquo;ll see what this means by example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Nick is a PhD student at the University of Pennsylvania. He applies mathematical
concepts from abstract algebra to make it more practical for programmers to
break their code into smaller reusable components while also scaling their
programs across a distributed system.&lt;/p&gt;

&lt;h1 id=&#34;oct-13&#34;&gt;Oct. 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Harrison Goldstein&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Advancing Property-Based Testing in Theory and Practice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Property-based testing (PBT) is a testing methodology that allows users to write executable
specifications of programs and test those specifications with automatically generated program
inputs. PBT is well-documented as a power-tool for bug-finding, with success stories at companies
like DropBox, Volvo, and Amazon, but we think it has still not reached its full potential. Our group
has taken a user-centered approach to advancing PBT, talking to real developers and discovering the
challenges that they face when using it.&lt;/p&gt;

&lt;p&gt;I present two new abstractions for random data generators&amp;mdash;free generators and reflective
generators&amp;mdash;that help address some of these challenges. Free generators re-imagine generators as
&amp;ldquo;parsers of randomness.&amp;rdquo; They show that a generator is really a parser for sequences of random
choices, and this perspective suggests new generation techniques. Reflective generators build on
free generators, adding support for &amp;ldquo;backward&amp;rdquo; execution in which a generated value can be turned
back into the sequence of choices that produced it. Backward generator execution is the foundation
for a wealth of new algorithms, including ones for test-case &amp;ldquo;shrinking,&amp;rdquo; test-case mutation, and
example-based generator tuning.&lt;/p&gt;

&lt;p&gt;Moving forward, we plan to focus on usability: free and reflective generators should be easy for
developers to write, and they should make other parts of the PBT process easier as well. I discuss
future work in this direction.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Harry Goldstein is a Ph.D. candidate at the University of Pennsylvania, advised by professor
Benjamin Pierce. His work leverages techniques from both programming languages and human-computer
interaction to make tools for software testing more powerful and usable. You can find his
publication list, blog, and other information at &lt;a href=&#34;https://harrisongoldste.in&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://harrisongoldste.in&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;oct-20&#34;&gt;Oct. 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Adrian Lehmann&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; VyZX: Formal Verification of a Graphical Language&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Mathematical representations of graphs often resemble adjacency matrices or lists, representations that facilitate whiteboard reasoning and algorithm design. In the realm of proof assistants, inductive representations effectively define semantics for formal reasoning. This highlights a gap where algorithm design and proof assistants require a fundamentally different structure of graphs. To address this gap, we present VyZX, a verified library for reasoning about inductively defined graphical languages. These inductive constructs arise naturally from category theory definitions. A key goal for VyZX is to verify the ZX calculus, a graphical language for reasoning about categorical quantum mechanics. Used as a more general model than the standard quantum circuit model, the ZX calculus equips its construction “ZX-diagrams” with a collection of diagrammatic rewrite rules that preserve the graph&amp;rsquo;s semantic interpretation. The ZX calculus has been shown to be useful for building quantum error correction, quantum compilers, and for general graphical reasoning. In VyZX using an initial set of rules proven through their semantics, we proceed to prove facts about the ZX calculus by only appealing to statements about the ZX calculus using standard proof assistant techniques. VyZX integrates easily with the proof engineer&amp;rsquo;s workflow through visualization, automation and verified conversion of quantum circuits to ZX diagrams.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Adrian Lehmann is a PhD student at the University of Chicago adivsed by John Reppy working with Robert Rand. His interests lie in programming languages: compilation, verification, and using PL for better software engineering. He’s currently exploring applying these techniques to quantum computing.&lt;/p&gt;

&lt;h1 id=&#34;oct-27&#34;&gt;Oct. 27&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Elaine Li&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Multiparty Session Type Projection and Subtyping with Automata&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Multiparty session types (MSTs) are a type-based approach to verifying communication protocols. Central to MSTs is a projection operator: a partial function that maps protocols represented as global types to correct-by-construction implementations for each participant, represented as a communicating state machine (CSM). Existing projection operators are syntactic in nature, and trade efficiency for completeness. In the first part of the talk, I will present the first projection operator that is sound and complete. I will highlight the automata-theoretic nature of our projection operator, which separates synthesis from checking implementability. For synthesis, we use a simple subset construction; for checking implementability, we present succinct conditions that summarize insights into the property of implementability. We use these conditions to show that MST implementability is PSPACE-complete.&lt;/p&gt;

&lt;p&gt;While our projection operator always computes a candidate implementation if one exists, it may not always be the best candidate. In the second part of the talk, I motivate the subtyping problem for MSTs through a series of examples. I then demonstrate how we can use our conditions from before to obtain decidability results for MST subtyping with unrestricted CSMs as implementation model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Elaine Li is a fourth year PhD student at New York University, working with Thomas Wies. She is interested in both the theory and practice of protocol verification, and her PhD research focuses on the theory of multiparty session types.&lt;/p&gt;

&lt;h1 id=&#34;nov-3&#34;&gt;Nov. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Karine Even-Mendoza&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; GrayC: Greybox Fuzzing of Compilers and Analysers for C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Fuzzing of compilers and code analysers has led to a large number of bugs being found and fixed in widely-used frameworks such as LLVM, GCC and Frama-C. Most such fuzzing techniques have taken a blackbox approach, with compilers and code analysers starting to become relatively immune to such fuzzers.&lt;/p&gt;

&lt;p&gt;In this talk, I will introduce a novel coverage-directed, mutation-based approach for fuzzing C compilers and code analysers inspired by the success of greybox fuzzing in other application domains. I will discuss the main challenge of applying mutation-based fuzzing in this context and present our solution: GrayC, a novel Greybox fuzzer for C compilers and analysers.&lt;/p&gt;

&lt;p&gt;Naive mutations often result in non-compilable programs, which hinders their ability to discover critical bugs affecting optimisation, analysis, and code generation routines. To address this, we have designed a novel greybox fuzzer for C compilers and analysers by developing a new set of mutations to target common C constructs, transforming fuzzed programs so that they produce meaningful output, allowing differential testing used as a test oracle, and paving the way for integrating fuzzer-generated programs into compiler and code analyser&amp;rsquo;s regression test suites.&lt;/p&gt;

&lt;p&gt;We have implemented our approach in GrayC, an open-source LibFuzzer-based tool. Our experiments demonstrate its superior coverage, particularly in compilers and analysers&amp;rsquo; middle and back-end stages, outperforming Clang-Fuzzer, PolyGlot, and similar LangFuzz techniques. Through GrayC, we have identified 30 confirmed bugs in compilers and code analysers and enriched the Clang/LLVM test suite with 24 simplified, coverage-enhancing the Clang/LLVM test suite, targeting 78 previously uncovered functions in the LLVM codebase.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Karine Even-Mendoza is a Lecturer in Systems and Programming Languages (CS) at King&amp;rsquo;s College London with a PhD in Computer Science from King&amp;rsquo;s College London. Before joining as a lecturer, she was a Research Associate in the Department of Computing at Imperial College London, where she worked in the Software Reliability Group (SRG) and Multicore Programming Group on compiler testing and software testing in general. Her PhD at King&amp;rsquo;s College London, in the SSY group, focused on model checking, SMT solving, and incremental verification for software. Before her PhD studies, she worked in several local and international software companies.&lt;/p&gt;

&lt;h1 id=&#34;nov-17&#34;&gt;Nov. 17&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Suha S. Hussain&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; MLFiles: Using Input-Handling Bugs to Inject Backdoors Into Machine Learning Pipelines&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The widespread use of machine learning (ML), especially in safety-critical applications,
necessitates robust security measures for ML pipelines. Prior research has demonstrated the
existence of model vulnerabilities, including model backdoors that can compromise the integrity
of ML pipelines. Although many backdoor attacks limit the attack surface to the model, ML
models are not standalone objects. These models are embedded in ML pipelines that involve
multiple interacting components and are built using a wide range of ML tools.
In this talk, I will discuss our investigation of input-handling bugs in ML tools as a vector for
injecting backdoors into ML pipelines. Input-handling bugs are central to the field of
language-theoretic security (LangSec), which advocates for the treatment of inputs as a formal
language in order to develop precise, minimalist input-handling code. Drawing from a LangSec
taxonomy of input-handling bugs, we systematically identified and exploited vulnerabilities with
ML model serialization in popular tools. This process enabled us to construct ML backdoors,
substantiating our claim. In the process, we engineered malicious artifacts, including polyglot
and ambiguous files, using ML model files; contributed to the fickling library; and formulated a
series of guidelines to provide actionable steps to ameliorate this issue. Our investigation brings
to light the risks posed by input-handling bugs in tools to the overall security of ML pipelines,
arguing for an approach that concurrently addresses software security issues in tools and model
vulnerabilities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Suha S. Hussain is a security engineer on the machine learning assurance team at Trail of Bits.
She has worked on projects such as the safetensors security audit and fickling. She received
her BS in Computer Science (with threads in people and theory) from Georgia Tech where she
also conducted research at the Institute for Information Security and Privacy. She previously
worked at the NYU Center for Cybersecurity and Vengo Labs.&lt;/p&gt;

&lt;h1 id=&#34;dec-1&#34;&gt;Dec. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kelly Kaoudis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Systems security in practice: threat modelling at Trail of Bits&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Every system user and engineer has a different threat model, and a different understanding of the systems and applications they use or work on. Failure to unify these bodies of knowledge leads to not sufficiently considering weaknesses of the system and threats to it; this leads to surprise when an attacker exploits these weaknesses, which leads to incident response (and sometimes also sadness). Holistic threat modelling informs and enables making good system-level security decisions to minimize potential attack vectors. During a threat modelling engagement, Trail of Bits aims to methodically enumerate as many in-scope, system-level risks and weaknesses as possible. &amp;ldquo;System-level&amp;rdquo; here means architectural, design-level, or operational gaps in the client&amp;rsquo;s security posture. We use concrete examples in the form of threat scenarios and findings to show the client (rather than tell them) the insufficiently applied security controls we have identified, and to illustrate the risk implications of the lack of those security controls.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some of the interesting findings we&amp;rsquo;ve uncovered during previous (published) threat modelling engagements. Using examples from engagement reports to motivate each step, I will walk through the threat modelling process at Trail of Bits, and also talk about how our process can be useful in academic security work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kelly Kaoudis is a senior security engineer in the Research practice at Trail of Bits. She is a tech lead for threat modelling engagements, and contributes to Trail&amp;rsquo;s academic and industry research projects including open source parser and file formats analysis tooling. Prior to Trail of Bits, Kelly was the tech lead for Twitter&amp;rsquo;s application security team, and a graduate student in the Networking and Security (NSR) group at University of Colorado Boulder with Prof. Eric Keller. She received an MS in computer science from University of Colorado - Boulder in 2015.&lt;/p&gt;

&lt;h1 id=&#34;dec-8&#34;&gt;Dec. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Susan Tan&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TULIP🌷 : Transcompilation Undergoes LLVM-IR for Interactive Parallelization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The exploration of heterogeneous systems has given rise to various parallel programming models (PPMs). However, the preference of hardware vendors for specific PPMs requires developers to manage multiple implementations for the same kernels. This not only consumes additional time but also impedes the seamless integration of new features and algorithm optimizations. This can be mitigated by a transcompiler. As it focuses its optimizations on the Abstract Syntax Tree (AST) level, a traditional transcompile falls short due to the preservation of syntax and semantics, limiting the compiler&amp;rsquo;s ability to reason about dependences. To address this, we introduce TULIP, a framework that transcompiles CUDA programs into OpenMP code—two widely adopted PPMs for prevalent heterogeneous CPU+GPU systems. Operating at the Intermediate Representation (IR) level instead, TULIP opens up opportunities to use state-of-the-art automatic parallelization frameworks for enhanced code performance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a fifth-year Ph.D. student in the Liberty Research Group at Princeton University, working under the supervision of Prof. David I. August. My research focuses on automatic parallelization, with a particular interest in exploring how tools such as decompilers and transcompilers can derive benefits from and contribute to state-of-the-art parallelization frameworks. In my spare time, I engage in reading and photography, capturing moments for friends&amp;rsquo; special occasions.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023sp/</link>
      <pubDate>Tue, 28 Mar 2023 10:41:50 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-7&#34;&gt;April 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tomas Petricek&lt;/td&gt;
&lt;td&gt;Programming Systems Deserve a Theory Too!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-14&#34;&gt;April 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://people.ucsc.edu/~kymiller/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kyle Miller&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Informalizing formalized mathematics using the Lean theorem prover&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-21&#34;&gt;April 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yanwen Xu&lt;/td&gt;
&lt;td&gt;Using all the processors in your heterogeneous system: a case study for tree-based applications&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-28&#34;&gt;April 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tim Goodwin&lt;/td&gt;
&lt;td&gt;What goes wrong in serverless runtimes?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-5&#34;&gt;May 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yuka Ikarashi&lt;/td&gt;
&lt;td&gt;Exocompilation for productive programming of hardware accelerators&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-12&#34;&gt;May 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Graydon Hoare&lt;/td&gt;
&lt;td&gt;Vectorized Interpreters: MRT for PL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-19&#34;&gt;May 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Thomas Dickerson&lt;/td&gt;
&lt;td&gt;Fangorn: Making Immutable Trees Mutable and Wait-Free&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-26&#34;&gt;May 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;cancelled&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-2&#34;&gt;June 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Lovro Lugović&lt;/td&gt;
&lt;td&gt;Real-World Choreographic Programming&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-9&#34;&gt;June 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Priyanka Mondal&lt;/td&gt;
&lt;td&gt;Asynchrony and Choreographies&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;april-7&#34;&gt;April 7&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tomas Petricek&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming Systems Deserve a Theory Too!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What do Commodore 64 BASIC, Jupyter Notebooks and Flash have in common? They all include an uninteresting programming language, but are interesting when we view them as programming systems and think about how programmers interact with them to construct programs. We know very well how to study the theory of programming languages, but what can we say about programming systems?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tomas Petricek is an assistant professor Charles University. He is interested in stateful, interactive and graphical programming systems, new ways of thinking about programming that make it easier and more accessible, as well as history and philosophy of computing. Previously, he developed novel tools for data exploration and visualization, contributed to the F# language and type providers at Microsoft Research and obtained PhD from University of Cambridge for his work on coeffects, a theory of context-aware programming languages.&lt;/p&gt;

&lt;h2 id=&#34;april-14&#34;&gt;April 14&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://people.ucsc.edu/~kymiller/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kyle Miller&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Informalizing formalized mathematics using the Lean theorem prover&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; One of the applications of interactive theorem provers in pure mathematics is being able to produce machine-verified formal proofs. I will talk about a less-obvious application, which is using formalized mathematics to author interactive informal expositions. I will demonstrate a prototype of an &amp;ldquo;auto-informalization&amp;rdquo; system written in Lean that presents the reader with an interface to view proofs at a desired level of detail.  I will also discuss thoughts on the impact of such tools in mathematics. This is joint work with Patrick Massot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kyle Miller is a postdoc in the mathematics department at UCSC. His primary research interests are in knot theory and graph theory, and he is currently on leave to work with Patrick Massot at Université Paris-Saclay in Orsay, France to pursue research in computer-formalized mathematics. Kyle is a contributor and maintainer for mathlib, the mathematical library for the Lean interactive theorem prover. In his spare time, he enjoys dreaming about PL designs and tinkering with compilers.&lt;/p&gt;

&lt;h2 id=&#34;april-21&#34;&gt;April 21&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yanwen Xu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Using all the processors in your heterogeneous system: a case study for tree-based applications&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Specialized processing units such as GPU/FPGA are widely adopted in heterogenous systems, e.g., in data centers and supercomputers.
However, another type of heterogeneous system - shared memory heterogeneous systems - often found in mobile SoCs, has received less attention, despite more and more die area consists of accelerators on these devices. In this talk, I will present a framework for accelerating tree-based applications in shared memory heterogeneous systems, such as those used in computer graphics and statistical learning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yanwen Xu is a third-year Ph.D. student in the computer science &amp;amp; engineering department at UCSC, advised by Professor Tyler Sorensen. His primary research interest is in heterogenous computing in edge devices, particularly developing novel compiler techinques to optimize the use of computing resources in these systems. Yanwen has collaborated with Princeton&amp;rsquo;s team on a DARPA-funded project, where he explored mapping heterogeneous workloads to emerging architectures.&lt;/p&gt;

&lt;h2 id=&#34;april-28&#34;&gt;April 28&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tim Goodwin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What goes wrong in serverless runtimes?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Serverless computing promises to drastically simplify the process of deploying and manging applications in the cloud. The paradigm involves dynamic autoscaling and &amp;ldquo;scale-to-zero&amp;rdquo; functionality, ensuring that applications consume only the compute resources they need to complete their work. Supporting these features reliably, however, requires a high level of complexity at the runtime level. In this talk, I will discuss some of the essential challenges in serverless platform design through a presentation of a recent bug study conducted on Knative, a popular, industrial-strength open-source serverless platform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tim Goodwin is a first-year Ph.D. student in the CSE department at UCSC, advised by Lindsey Kuper and Andrew Quinn. His research interests are in distributed systems and the abstractions used to build them. Recently, he has been exploring the programming challenges associated with emerging cloud-native technologies like serverless programming and Kubernetes.&lt;/p&gt;

&lt;h2 id=&#34;may-5&#34;&gt;May 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yuka Ikarashi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Exocompilation for productive programming of hardware accelerators&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; High-performance kernel libraries are critical to exploiting accelerators and specialized instructions in many applications. Because compilers are difficult to extend to support diverse and rapidly-evolving hardware targets, and automatic optimization is often insufficient to guarantee state-of-the-art performance, these libraries are commonly still coded and optimized by hand, at great expense, in low-level C and assembly. To better support development of high-performance libraries for specialized hardware, we propose a new programming language, Exo, based on the principle of exocompilation: externalizing target-specific code generation support and optimization policies to user-level code. Exo allows custom hardware instructions, specialized memories, and accelerator configuration state to be defined in user libraries. It builds on the idea of user scheduling to externalize hardware mapping and optimization decisions. Schedules are defined as composable rewrites within the language, and we develop a set of effect analyses which guarantee program equivalence and memory safety through these transformations. We show that Exo enables rapid development of state-of-the-art matrix-matrix multiply and convolutional neural network kernels, for both an embedded neural accelerator and x86 with AVX-512 extensions, in a few dozen lines of code each.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yuka Ikarashi is a PhD candidate at MIT CSAIL, advised by Jonathan Ragan-Kelley. She is interested in creating compiler systems and programming languages for real-world applications. She is a co-creator of the Exo programming language and has been a developer for other compiler frameworks such as Clang/LLVM and ROOT. She previously worked at Apple, Amazon, and CERN. She received Masason Foundation Fellowship and Funai Foundation Fellowship awards.&lt;/p&gt;

&lt;h2 id=&#34;may-12&#34;&gt;May 12&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Graydon Hoare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Vectorized Interpreters: MRT for PL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Conventional interpreters and compilers are two different
techniques for implementing programming languages. They each make
specific sets of compromises on various key pragmatic concerns. A
third, often-overlooked implementation technique exists called a
&amp;ldquo;vectorized interpreter&amp;rdquo; with a different and compelling set of
compromises. This talk will examine the technique in some depth,
making an &amp;ldquo;MRT&amp;rdquo; analogy that is hopefully illuminating (or at least an
amusing surprise).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Graydon Hoare is a systems programmer with a focus on programming
language design and implementation. He was the initial developer of
Rust, and has worked on numerous language toolchains, runtimes,
debuggers, profilers and other development tools over 25 years of
industrial work including Red Hat, Mozilla and Apple.&lt;/p&gt;

&lt;h2 id=&#34;may-19&#34;&gt;May 19&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Thomas Dickerson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Fangorn: Making Immutable Trees Mutable and Wait-Free&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We show how to implement a large class of wait-free operations on mutable trees by applying type-level rewrite rules to specifications for immutable versions of the same ADT.
Among the supported operations are efficient, linearizable, copy-on-write snapshots; thereby supporting consistent iteration and speculative updates.&lt;/p&gt;

&lt;p&gt;The transformation is achieved by executing each recursive step using the LLX and SCX primitives of Brown et al. (2013) and suspending each tail call into the structure of the tree itself (rather than relying on the mechanisms of the host programming language).
We bootstrap our operations on the root of the tree using a wait-free universal construction based on LLX/SCX.&lt;/p&gt;

&lt;p&gt;We also show how to extend the LLX/SCX primitives to allow control-flow operations to propagate correctly across thread boundaries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Thomas Dickerson is the Chief Science Officer (and a co-founder) at Geopipe, in Burlington, Vermont. Geopipe is a deep-tech startup using ML to parse the planet&amp;rsquo;s geospatial data and create simulation-ready environments from real-world locations. Previously, he did his PhD at Brown University where he was advised by Maurice Herlihy. His research interests are, broadly, applying a computational lens to interdisciplinary problems.&lt;/p&gt;

&lt;h2 id=&#34;may-26&#34;&gt;May 26&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;cancelled&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;june-2&#34;&gt;June 2&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Lovro Lugović&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Real-World Choreographic Programming&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a recent programming paradigm where the overall behaviour of a distributed system is programmed from a global viewpoint&amp;mdash;as a choreography between different participants (roles).
The choreography can then be automatically compiled (projected) to a correct implementation for each role.
This relieves the programmer from manually writing the separate send and receive actions performed by the roles, which simplifies development and avoids communication mismatches.&lt;/p&gt;

&lt;p&gt;However, the applicability of choreographic programming in the real world is still largely unexplored.
We carry out the first development of a widespread real-world protocol using choreographic programming, the Internet Relay Chat (IRC).
We show how we have dealt with IRC&amp;rsquo;s complex interaction patterns and the issue of interoperability with third-party software.
The development is based on Choral, an object-oriented higher-order choreographic programming language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Lovro Lugović is a computer science PhD student in the IMADA department at the University of Southern Denmark (SDU), advised by Fabrizio Montesi. His research interests are in distributed systems, concurrency theory, choreographic programming and programming languages.&lt;/p&gt;

&lt;h2 id=&#34;june-9&#34;&gt;June 9&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Priyanka Mondal&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Asynchrony and Choreographies&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Choreographic programming is a paradigm for the development of concurrent software, where deadlocks are prevented syntactically. It enables the programmers to write a centralized program (choreography) and compile it via endpoint projection into programs for each participating node in a distributed system. However, choreographic languages are typically synchronous, whereas most real-world systems have asynchronous communications. In this talk we will discuss how we can make a choreographic programming language support asynchronous communication by adding extra semantics to it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Priyanka Mondal is a PhD student in the Department of Computer Science &amp;amp; Engineering at UCSC. She is advised by Owen Arden and Ioannis Demertzis. Her research interests include language-based security, cryptography, and distributed systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2023)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2023wi/</link>
      <pubDate>Tue, 20 Sep 2022 15:10:12 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2023wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2023, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-6&#34;&gt;Jan. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://msurbatovich.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Milijana Surbatovich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Designing Formally Correct Intermittent Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-13&#34;&gt;Jan. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;POPL SRC lightning talks (&lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt;, &lt;a href=&#34;https://nliittsc.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Nathan Liittschwager&lt;/a&gt;, &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-20&#34;&gt;Jan. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;cancelled&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-27&#34;&gt;Jan. 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://ducky64.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Richard Lin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Usable Programming for Building Things (with a focus on electronics)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-3&#34;&gt;Feb. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.nassi.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ike Nassi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The Practical Advantages of Distributed Virtual Machines and How They Work&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-10&#34;&gt;Feb. 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.dustinrichmond.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dustin Richmond&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;bPentimento: Data Remanence in Cloud FPGAs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-17&#34;&gt;Feb. 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://dslab.epfl.ch/people/iyer/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rishabh Iyer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Performance interfaces for Network Functions and beyond&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-24&#34;&gt;Feb. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://wintered.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dominik Winterer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Finding 1,700+ Bugs in the SMT Solvers Z3 and CVC5 in Three Years&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-3&#34;&gt;March 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Andrew Osterhout&lt;/td&gt;
&lt;td&gt;ROMP: A Random-walk Based Parallel Explicit-State Stateless Model Checker&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-10&#34;&gt;March 10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;José Renau&lt;/td&gt;
&lt;td&gt;Live Hardware Development at UCSC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-17&#34;&gt;March 17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://pl.cs.uni-kl.de/homepage/en/staff/AlbertSchimpf/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Albert Schimpf&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Set-Theoretic Types for Erlang&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;jan-6&#34;&gt;Jan. 6&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://msurbatovich.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Milijana Surbatovich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Designing Formally Correct Intermittent Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Batteryless, energy-harvesting devices (EHDs) are an emerging platform that
enables computing in remote, inaccessible environments. Instead of using a
battery, an EHD harvests energy from its environment into a buffer and operates
intermittently, only as energy is available. This operational cycle causes the
device to experience frequent, arbitrary power failures that make correct
programming difficult. To make progress, an intermittent system typically saves
execution state before power failure and restores it after the device reboots.
Incorrectly determining which state must be saved and where a save point should
be made causes software to exhibit memory and timing bugs that would not occur
on continuously powered program executions. As EHDs are envisioned to be
remotely-deployed, low-maintenance devices, programs must execute reliably,
without memory consistency or timing violations. Unfortunately, existing systems
rely on informal, undefined correctness notions, providing few correctness guarantees.&lt;/p&gt;

&lt;p&gt;In this talk, I present my work in designing formally correct intermittent
systems. I show how existing correctness notions are insufficient, leading to
unaddressed bugs. I then define formal correctness conditions for memory
consistency and timing properties on intermittent systems, using these
definitions to design enforcement mechanisms and abstractions programmers
can use to specify their desired properties. This work allows the development
of intermittent systems that meet specified guarantees of time and memory consistency,
improving reliability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Milijana Surbatovich is a final year PhD Candidate in the Electrical and Computer Engineering
Department at Carnegie Mellon University, co-advised by Professors Brandon Lucia and
Limin Jia. Her research interests are in applied formal methods, programming languages,
and systems for intermittent computing.
She is excited by research problems that require reasoning about correctness and
security across the architecture, system, and language stack.
Previously, she received an MS in ECE from CMU in 2020 while doing her PhD
and a BS in Computer Science from University of Rochester in 2017.&lt;/p&gt;

&lt;h2 id=&#34;jan-13&#34;&gt;Jan. 13&lt;/h2&gt;

&lt;p&gt;POPL SRC lightning talks (&lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt;, &lt;a href=&#34;https://nliittsc.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Nathan Liittschwager&lt;/a&gt;, &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;jan-20&#34;&gt;Jan. 20&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;cancelled&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;jan-27&#34;&gt;Jan. 27&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://ducky64.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Richard Lin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Usable Programming for Building Things (with a focus on electronics)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; While modern programming languages and development practices have made programming powerful yet still accessible to novices, the underlying mechanisms - high level of abstraction, encapsulation and re-use of expert knowledge, and automated correctness checks - can also be hugely beneficial to fields beyond software. For example, structuring board-level electronic circuit designs as code enables designers to write and re-use subcircuits that automate common calculations, while the expert knowledge that these encapsulate helps make design accessible to those with less in-depth knowledge.&lt;/p&gt;

&lt;p&gt;Yet, it&amp;rsquo;s not as simple as &amp;ldquo;boards&amp;hellip; but in code&amp;rdquo;: new tools must also be useful to, and usable by, existing designers. In this talk, I present my work on developing a hardware description language (HDL) system for electronics that simultaneously aims to be powerful for experts yet usable by all. I&amp;rsquo;ll go over the entire process, from understanding user needs through initial interview studies, to designing the core language and its abstractions, to building supporting tools that bridge this powerful textual design interface with the familiar graphical tools that are used by today&amp;rsquo;s engineers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I&amp;rsquo;m currently a postdoc at UC Los Angeles, and before that I received my PhD from UC Berkeley. My research interests focus on building open-source tools that bring the power of software engineering to electronics design, ultimately making custom device design possible for more people. In the past, I&amp;rsquo;ve worked on the Chisel HDL project, which brings modern software engineering practices to chip-level digital design and similarly focuses on open-source, usability, and practical adoption.&lt;/p&gt;

&lt;h2 id=&#34;feb-3&#34;&gt;Feb. 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.nassi.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ike Nassi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The Practical Advantages of Distributed Virtual Machines and How They Work&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I&amp;rsquo;ll describe a distributed virtual machine architecture.   The virtual machine aggregates multiple physical servers and runs them as if they were a single physical server running a single unmodified standard operating system which manages all the resources as if it were a single machine.  No changes to applications are required.&lt;/p&gt;

&lt;p&gt;The talk explains why creating this was difficult, but also why it&amp;rsquo;s not as difficult as many might perceive. It explains the concept of non-disruptive automatic dynamic adaptive computing using machine learning and introspection.  Particular emphasis is given to auto-scaling, automatic optimization, simplicity of adoption, and hardware evolution.  Along the way, some elegant solutions to new problems we hadn&amp;rsquo;t anticipated were addressed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Ike was the founder of TidalScale.  The team and the IP is now part of HPE.  Ike Nassi is an Adjunct Professor of Computer Science at UC Santa Cruz, and a Founding Trustee at the Computer History Museum. Previously, he was an Executive Vice President and Chief Scientist at SAP. Before TidalScale, Ike helped start three companies: Encore Computer Corporation building hierarchical strongly coherent shared memory symmetric multiprocessors (1984); InfoGear Technology, which developed both Internet appliances (including the first iPhone) and associated backend services (1996); and Firetide, an early  wireless mesh networking company (2000).&lt;/p&gt;

&lt;p&gt;He worked at Apple Computer where he was SVP for all software and a Corporate Officer, Visual Technology, and Digital Equipment Corporation. Dr. Nassi has been a Visiting Scholar at Stanford University, twice a Research Scientist at MIT, and a Visiting Scholar at University of California, Berkeley. He has served on the board of the Anita Borg Institute for Women and Technology, and the IEEE Computer Society Industry Advisory Board. He holds a PhD in Computer Science from Stony Brook University.&lt;/p&gt;

&lt;p&gt;He was awarded two certificates for Distinguished Service from the Department of Defense, one for his work on the design of the programming language Ada and one for his work on DARPA ISAT.  He is a Life Fellow of IEEE and a Life member of ACM.  He is named on 35 patents.&lt;/p&gt;

&lt;h2 id=&#34;feb-10&#34;&gt;Feb. 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.dustinrichmond.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dustin Richmond&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; bPentimento: Data Remanence in Cloud FPGAs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Cloud FPGAs strike an alluring balance between computational efficiency, energy efficiency, and cost. It is the flexibility of the FPGA architecture that enables these benefits, but that very same flexibility that exposes new security vulnerabilities. We show that a remote attacker can recover “FPGA pentimenti” – long-removed secret data belonging to a prior user of a cloud FPGA. The sensitive data constituting an FPGA pentimento is an analog imprint from bias temperature instability (BTI) effects on the underlying transistors. We demonstrate how this slight degradation can be measured using a time-to-digital (TDC) converter when an adversary programs one into the target cloud FPGA. This technique allows an attacker to ascertain previously safe information on cloud FPGAs, even after it is no longer explicitly present. Notably, it can allow an attacker to (1) extract proprietary details from an encrypted FPGA design image available on the cloud marketplace and (2) recover information from a previous user of a cloud FPGA. We demonstrate the ability to extract design details and recover previous cloud FPGA user information on the cloud platform. Our experiments show that BTI degradation (burn-in) and recovery are measurable and constitute a security threat to commercial cloud FPGAs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dustin Richmond is an Assistant Professor of Computer Science and Engineering in the Baskin School of Engineering at UC Santa Cruz. Dustin completed his postdoc in the Bespoke Silicon Group at the Paul Allen School of Computer Science at the University of Washington, and earned his Ph.D. from the University of California, San Diego. His research interests are in the design of flexible and secure architectures that can generalize across applications, evolve with software, and dynamically adapt to changes in data. His prior work includes HammerBlade, a flexible supercomputer funded by DARPA; RIFFA: A Reconfigurable Interface for FPGA Accelerators, which won a Community Best Paper Award at the 2013 International Conference on Field-Programmable Logic; and contributions to the PYNQ project at Xilinx. He is an NSF Graduate Research Fellow and an ARCS Fellow. He won the Outstanding Community Leader Award from the UC San Diego Graduate Student Association, and the Excellence in Service and Leadership Award from the UC San Diego Computer Science and Engineering Department. Last, but not least, he also won the Best Social Hour Theme Award for teaching other students the basics of lock picking by locking all the Friday afternoon event food in metal boxes.&lt;/p&gt;

&lt;h2 id=&#34;feb-17&#34;&gt;Feb. 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://dslab.epfl.ch/people/iyer/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rishabh Iyer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Performance interfaces for Network Functions and beyond&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Modern programmers routinely use third-party code, and infrastructure operators deploy software they did not write. This would not be possible without semantic interfaces&amp;mdash;documentation, header files, specifications&amp;mdash;that succinctly describe what that third-party code does.&lt;/p&gt;

&lt;p&gt;In this talk, I will propose performance interfaces as a way to describe a system’s performance, akin to how a semantic interface describes its functionality. I will concretize this idea in the domain of network functions (NFs) and describe a tool (PIX) that automatically extracts simple, yet precise performance interfaces from NF implementations. Finally, I will show how developers and operators can use PIX-extracted  interfaces to identify performance regressions, diagnose and fix performance bugs and identify the latency impact of NIC offloads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Rishabh Iyer is a sixth year PhD student at EPFL working with George Candea and Katerina Argyraki. His research interests are centred around computer systems and networking although he can often be found dabbling with formal verification tools. Prior to joining EPFL, he received his bachelor&amp;rsquo;s degree from IIT Bombay in 2017.&lt;/p&gt;

&lt;h2 id=&#34;feb-24&#34;&gt;Feb. 24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://wintered.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dominik Winterer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Finding 1,700+ Bugs in the SMT Solvers Z3 and CVC5 in Three Years&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Satisfiability Modulo Theory (SMT) solvers are important tools for many
advances in programming languages, e.g., symbolic execution engines,
software model checkers, and program verifiers. SMT solvers&amp;rsquo; robustness
is crucial&amp;mdash;Incorrect results from SMT solvers can invalidate client
applications&amp;rsquo; results and lead to disasters in safety-critical domains.
Hence, the SMT community has undertaken great efforts to make SMT
solvers reliable. Despite this, SMT solvers are complex software and
still have latent bugs. Although various fuzzing campaigns have targeted
SMT solvers, most known critical bugs were exposed by client
applications of the solvers and not by fuzzers.&lt;/p&gt;

&lt;p&gt;We devised several general methods for stress-testing SMT solvers [&lt;a href=&#34;http://dl.acm.org/doi/abs/10.1145/3385412.3385985&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3428261&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;]. We
have been &lt;a href=&#34;http://testsmt.github.io&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;extensively stress-testing the two state-of-the-art SMT
solvers Z3 and CVC4&lt;/a&gt;. So far, we have found 1,700+ unique bugs in Z3
and CVC4&amp;mdash;1,200+ have already been fixed by the developers and 500+ are
critical soundness bugs. Our detected bugs are diverse, distributing
over almost every SMT-LIB logic and theory: Perhaps surprisingly, our
tools detected soundness bugs in linear arithmetic, bit vectors, and
uninterpreted functions, decidable logics widely believed to be stable.
The developers appreciated our effort by comments such as &amp;ldquo;great find&amp;rdquo;,
&amp;ldquo;excellent find&amp;rdquo; and &amp;ldquo;nice catch&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dominik Winterer is a fifth-year Ph.D. student advised by Prof.
Zhendong Su at ETH Zurich and a member of the AST lab. He is interested
in formal methods problems in Programming Languages and Software
Engineering. Dominik&amp;rsquo;s vision is to robustify modern formal methods
software through devising novel testing approaches. Dominik has been
awarded the PLDI distinguished paper award.&lt;/p&gt;

&lt;h2 id=&#34;march-3&#34;&gt;March 3&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Andrew Osterhout&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ROMP: A Random-walk Based Parallel Explicit-State Stateless Model Checker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Model checking via parallelized random walks is a way to
  get fast way to find bugs in models with huge statespaces.  This is
  largely due to not having to use a global has to monitor the
  progress of a normal BFS or DFS traversal of a statespace.  There
  however other ways to improve this performance even further with the
  use of heuristics statespace reductions, and figuring out when to
  cut your losses on a poor performing walks.  We take the first few
  steps into refining such methodologies by utilizing the Murphi model
  checking language and a simple multithreaded random walking
  generated model checker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Hello, I am Andrew Osterhout, I am a graduate of the
  University of Utah, currently working as a research assistant /
  research programmer under Ganesh Gopalakrishnan,  where I
  primarily work on verification systems for data race detection in
  GPUs and Model Checking based verification projects.  I currently
  live in Santa Cruz with my partner and work remotely.  I am
  currently working on a LLNL contract via the University of Utah for
  GPU race detection on AMD unified memory architectures, as well as
  shepherding the romp project form the side lines while I juggle grad
  school applications.&lt;/p&gt;

&lt;h2 id=&#34;march-10&#34;&gt;March 10&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; José Renau&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Live Hardware Development at UCSC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Prof. Renau will present the research effort by his team at UCSC. The talk focuses on open-source Live CHIP design flows to improve hardware design productivity. With a focus on 2 main areas: LiveHD and Pyrope.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LiveHD (&lt;a href=&#34;https://github.com/masc-ucsc/livehd&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/masc-ucsc/livehd&lt;/a&gt;) is hardware compiler with Verilog, Chisel, and Pyrope front-ends. The latest effort is compiler speed around fast structures and parallelization.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pyrope (&lt;a href=&#34;https://masc-ucsc.github.io/docs/pyrope/00-hwdesign/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://masc-ucsc.github.io/docs/pyrope/00-hwdesign/&lt;/a&gt;) is a new hardware description language. It has a modern syntax designed to be efficient and more approachable to non-hardware designers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jose Renau (&lt;a href=&#34;http://www.soe.ucsc.edu/~renau&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.soe.ucsc.edu/~renau&lt;/a&gt;) is a CSE department professor at University of California, Santa Cruz. His area of research is computer architecture, focusing on productive hardware design flows (Live Hardware Design Flow or LiveHD, architectural simulators like ESESC, new hardware description language like Pyrope, new design methodologies like Fluid Pipelines), out-of-order cores, and RISC-V verification. Past projects with Thread Level Speculation, infrared thermal measurements, power modeling, and design effort metrics/models. Prof. Renau has a Ph.D. in Computer Science from the University of Illinois at Urbana-Champaign. He is currently the IEEE TCMM Chair.&lt;/p&gt;

&lt;h2 id=&#34;march-17&#34;&gt;March 17&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://pl.cs.uni-kl.de/homepage/en/staff/AlbertSchimpf/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Albert Schimpf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Set-Theoretic Types for Erlang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Erlang is a functional programming language with dynamic typing. The
language offers great flexibility for destructing values through pattern
matching and dynamic type tests. Erlang also comes with a type language
supporting parametric polymorphism, equi-recursive types, as well as
union and a limited form of intersection types. However, type signatures
only serve as documentation, there is no check that a function body
conforms to its signature.&lt;/p&gt;

&lt;p&gt;Set-theoretic types and semantic subtyping fit Erlang&amp;rsquo;s feature set
very well. They allow expressing nearly all constructs of its type
language and provide means for statically checking type signatures.
This talk will give a brief overview of the history and capabilities of
set-theoretic types and how to apply it to an existing dynamically typed
language without or with only minor modifications to the code and the
challenges involved.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’m a PhD student at the Department of Computer Science of the
University of Kaiserslautern, in the AG Softwaretechnik.&lt;/p&gt;

&lt;p&gt;My current research topic is applying Set-Theoretic Type Theory to a
currently dynamically-typed language called Erlang, which includes
defining an operational semantics for that language and designing and
implementing an efficient type checker.&lt;/p&gt;

&lt;p&gt;My previous work includes building efficient tools for verification,
mainly propositional satisfiablility and regular language inclusion
solvers, working on replicated distributed data stores and language
design for workflows.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022fa/</link>
      <pubDate>Fri, 09 Sep 2022 15:47:17 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2022, we will continue to host the LSD Seminar in a hybrid fashion.  Anyone can attend on Zoom, and local folks can gather in person in the lab.  Speakers can join either in person or on Zoom, whichever is convenient.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Sept. 23&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Lab social event and introductions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-30&#34;&gt;Sept. 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://arquinn.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Andrew Quinn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Debugging the OmniTable Way&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-7&#34;&gt;Oct. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://people.cs.vt.edu/~litinghu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Liting Hu&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Stream Processing Systems for Emerging Trends&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-14&#34;&gt;Oct. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modeling and Testing for MicroBus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-21&#34;&gt;Oct. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.linkedin.com/in/tloridobotran/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tania Lorido Botran&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Powering data centers the smart way&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-28&#34;&gt;Oct. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://users.soe.ucsc.edu/~pmondal/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Priyanka Mondal&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Applying consensus and replication securely with FLAQR&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-4&#34;&gt;Nov. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.comp.nus.edu.sg/~yahuis/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Yahui Song&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Automated Temporal Verification with Extended Regular Expressions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nov. 11&lt;/td&gt;
&lt;td&gt;No meeting (Veterans Day)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-18&#34;&gt;Nov. 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://abeln.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Abel Nieto&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modular Verification of Op-Based CRDTs in Separation Logic&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nov. 25&lt;/td&gt;
&lt;td&gt;No meeting (Thanksgiving)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-2&#34;&gt;Dec. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~ishitac/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ishita Chaturvedi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;GhOST: a GPU Out-of-Order Scheduling Technique&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-30&#34;&gt;Sept. 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://arquinn.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Andrew Quinn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Debugging the OmniTable way&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Debugging is time-consuming, accounting for roughly 50% of a developer&amp;rsquo;s time. To identify the cause of a failure, a developer usually tracks the state of their program as it executes on a failing input. Unfortunately, most debugging tools make it difficult for a developer to specify the program state that they wish to observe and computationally expensive to observe execution state. Moreover, existing work to improve our debugging tools often restrict the state that a developer can track by either exposing incomplete execution state or requiring manual instrumentation.&lt;/p&gt;

&lt;p&gt;In this talk, I will describe our new debugging approach based on the OmniTable abstraction, which captures all state reached during an execution as a large queryable data table. Our query model built around the OmniTable abstraction supports SQL to simplify debugging without restricting the state that a developer can observe: I’ll show that OmniTable debugging queries are more succinct than equivalent logic specified using existing tools.&lt;/p&gt;

&lt;p&gt;Then, I’ll describe how our prototype, SteamDrill, accelerates debugging by taking advantage of how an OmniTable decouples debugging logic from the original execution. Namely, the system employs lazy materialization: it uses deterministic record/replay to store the execution associated with each OmniTable and resolves queries by inspecting replay executions. It employs a novel multi-replay strategy that partitions query resolution across multiple replays and a parallel resolution strategy that simultaneously observes state at multiple points-in-time. I’ll show that SteamDrill queries are an order-of-magnitude faster than existing debugging tools.&lt;/p&gt;

&lt;h1 id=&#34;oct-7&#34;&gt;Oct. 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://people.cs.vt.edu/~litinghu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Liting Hu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Stream Processing Systems for Emerging Trends&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Stream processing is proposed and popularized as a “technology like Hadoop but can give you results faster”, which lets users query a continuous data stream and quickly get results within a very short time period from the time of receiving the data. For that reason, stream processing technology has become a critical building block of many applications, such as making business decisions from marketing streams, identifying spam campaigns from social network streams, predicting tornados and storms from radar streams, and analyzing genomes in different labs and countries to track the sources of a potential epidemic. However, state-of-art solutions have dominantly centered around stateless stream processing, leaving another urgent trend—stateful stream processing—much less explored. A driving need is that the future stream applications need to store and update state along with their processing, and process live data streams in a timely fashion from massive and geo-distributed data sets. In this talk, I will present a next-generation geo-distributed scalable stateful stream processing system. (1) At the architecture layer, I will introduce a decentralized “many masters/many workers” architecture that improves the scalability of stream processing systems. (2) At the mechanism layer, I will present a fragment-based parallel recovery mechanism that recovers large distributed states by leveraging erasure codes. Finally, I will outline the emerging trends for developing stream processing systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Liting Hu received her Ph.D. degree in computer science from Georgia Institute of Technology in 2016. She served as assistant professor of computer science at Virginia Tech in the 2021–22 academic year. Before that, she served as assistant professor in the school of computing and information sciences at Florida International University from 2017 to 2021. Liting conducts research on experimental computer systems, including stream processing systems, cloud and edge computing, distributed systems, and operating systems virtualization. Liting has received an NSF CAREER Award, an NSF SPX Award, an NSF OAC Award, a Meta Faculty Research Award, and a Cyber Florida Seed Award.&lt;/p&gt;

&lt;h1 id=&#34;oct-14&#34;&gt;Oct. 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://gshen42.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Gan Shen&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modeling and Testing for MicroBus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; MicroBus is a newly developed replication service at AWS that provides consistency, durability, and fault tolerance guarantees. Both modeling and testing have been employed to ensure its correctness and have shown some success. Nevertheless, they all have shortcomings, with modeling not connected with the implementation and testing only covering limited scenarios. To solve this, we propose model-based testing as a hybrid approach that combines the best of the two worlds.&lt;/p&gt;

&lt;p&gt;In this talk, I will first give a gentle introduction to the MicroBus protocol/implementation and the pros and cons of modeling and testing. Then I will explain the model-based testing approach and the benefits it brings on to the table.&lt;/p&gt;

&lt;p&gt;(This project was done during my internship in the Automated Reasoning Group at AWS summer 2022)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Gan Shen is a 3rd-year PhD student at UC Santa Cruz, working with Prof. Lindsey Kuper in the LSD lab. His research area is programming language theory, in particular, how to design new programming tools/abstractions that facilitate software development.&lt;/p&gt;

&lt;h1 id=&#34;oct-21&#34;&gt;Oct. 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.linkedin.com/in/tloridobotran/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tania Lorido Botran&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Powering data centers the smart way&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Infrastructure powering current workloads is very
  heterogeneous: central data centers with various hardware
  accelerators, edge data centers with constraint resources and a
  variety of client devices with different capabilities. Orchestrating
  all these players can be a challenge and this talk will touch on how
  ML (or DL) can actually help. First, we will deep-dive into two
  projects: we will explore the use of Reinforcement learning for
  optimal container placement in edge data centers, and also visit an
  unsupervised approach for anomaly detection in containers, in
  particular, the noisy neighbor effect. After that, we will briefly
  learn about some on-going projects around autoscaling for ML
  pipelines, performance degradation detection in serverless
  functions, bottleneck detection with GANs and high-level
  sustainability scores for latency sensitive/critical tasks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dr. Tania Lorido-Botran is a Research Scientist at
  Roblox. Prior to that, she worked at Microsoft and the Pacific
  Northwest National Laboratory. During her PhD, she had the
  opportunity to spend one year at Rice University and also did two
  internships at VMware and HP Labs. Dr. Lorido Botran received her
  PhD from the University of Deusto in Spain with a Cum Laude
  distinction, and her master’s degree in Distributed systems from
  University of the Basque Country with a highest marks
  distinction. Her current research interests span across ML for
  systems, data center sustainability and fault-tolerance.&lt;/p&gt;

&lt;h1 id=&#34;oct-28&#34;&gt;Oct. 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://users.soe.ucsc.edu/~pmondal/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Priyanka Mondal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Applying consensus and replication securely with FLAQR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Availability is crucial to the security of distributed systems, but guaranteeing availability is hard, especially when
participants in the system may act maliciously. Quorum replication protocols provide both integrity and availability: data and computation
is replicated at multiple independent hosts, and a quorum of these hosts must agree on the output of all operations applied to the data.
Unfortunately, these protocols have high overhead and can be difficult to calibrate for a specific application’s needs. Ideally, developers could
use highlevel abstractions for consensus and replication to write fault tolerant code that is secure by construction. This paper presents
Flow-Limited Authorization for Quorum Replication (FLAQR), a core calculus for building distributed applications with heterogeneous
quorum replication protocols while enforcing end-to-end information security. Our type system ensures that well-typed FLAQR programs cannot
fail (experience an unrecoverable error) in ways that violate their typelevel specifications. We present noninterference theorems that characterize
FLAQR’s confidentiality, integrity, and availability in the presence of consensus, replication, and failures, as well as a liveness theorem for the class of majority quorum protocols under a bounded number of faults.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Priyanka Mondal is a PhD student at the University of California Santa Cruz, where she is supervised by Professor Owen Arden and Professor Ioannis Demertzis. Her research areas include Applied Cryptography, Programming Languages and Security in Distributed Systems. Prior to joining UCSC she worked as a software engineer at Citrix R&amp;amp;D Bangalore.&lt;/p&gt;

&lt;h1 id=&#34;nov-4&#34;&gt;Nov. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.comp.nus.edu.sg/~yahuis/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Yahui Song&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Automated Temporal Verification with Extended Regular Expressions&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Existing approaches to temporal verification have either sacrificed modularity in favor of achieving automation or vice-versa. To exploit the best of both worlds, we present a new framework to ensure temporal properties via Hoare-style verifiers and term rewriting systems (TRSs).&lt;/p&gt;

&lt;p&gt;The leading technique of temporal verification is automata-based model checking, which has possible insufficiencies: (i) it requires a manual modeling stage and needs to be bounded when encountering non-terminating traces; (ii) to conveniently deploy existing inclusion-checkers for automata, the expressiveness power is limited by the finite-state automata; and (iii) there is always a gap between the verified logic and the actual implementation from the program.&lt;/p&gt;

&lt;p&gt;To tackle these issues, we propose a framework that conducts local temporal verification, which leads to a modular and compositional verification strategy, where temporal reasoning can be combined to reason about the overall program. Meanwhile, we propose various effect logics to be the temporal specification languages, which are essentially extended regular expressions (REs), pushing the expressiveness boundary of the most deployed linear temporal logic (LTL). Furthermore, the proposed framework devises purely algebraic TRS to check the inclusions for the novel logics, avoiding the complex translation into automata.&lt;/p&gt;

&lt;p&gt;We demonstrate the applicability of the proposed framework and various REs-based temporal logics in different domains; presents the corresponding prototype systems, case studies, experimental results, and necessary proofs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yahui Song is a 5th year PhD Student at the National University of Singapore (NUS), supervised by Associate Professor Chin Wei Ngan. Her interests are automated program verification and programming language design. Her current works are dedicated to more expressive and efficient temporal verification.&lt;/p&gt;

&lt;h1 id=&#34;nov-18&#34;&gt;Nov. 18&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://abeln.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Abel Nieto&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular Verification of Op-Based CRDTs in Separation Logic&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Commutative Replicated Data Types (CRDTs) are a family of distributed data structures where all operations are designed to commute, so that replica states eventually converge. Additionally, CRDTs require that operations be propagated between replicas in causal order. This talk presents a framework for verifying safety properties of OCaml CRDT implementations using separation logic. The framework consists of two libraries. One implements a Reliable Causal Broadcast (RCB) protocol so that replicas can exchange messages in causal order. A second OpLib library then uses RCB to export a CRDT builder interface that simplifies the creation (and correctness proofs) of new CRDTs. OpLib allows clients to implement new CRDTs as purely-functional data structures, without having to reason about network operations, concurrency control and mutable state, and without having to re-implement causal broadcast each time. Using OpLib, we have implemented 12 sample CRDTs from the literature, including multiple versions of replicated registers and sets, as well as two CRDT combinators for products and maps. Our proofs are conducted in the Aneris distributed separation logic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I&amp;rsquo;m a 3rd (and final) year PhD student at Aarhus University, working with Lars Birkedal on verification of distributed systems using the Aneris distributed separation logic.  In particular, my work focuses on reasoning about systems that are highly-available but weakly consistent.&lt;/p&gt;

&lt;h1 id=&#34;dec-2&#34;&gt;Dec. 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ishita Chaturvedi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; GhOST: a GPU Out-of-Order Scheduling Technique&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Despite supporting fast context switching among many available threads to hide latency, GPU applications still suffer from stalls. To reduce these stalls, researchers have proposed several out-of-order (OoO) execution methods for GPUs. While these techniques improve performance, they use complex hardware to support register renaming, memory instruction reordering, or make invasive changes to the ISA to enable the compiler to provide hints to the hardware. In this talk, I will present GhOST, the first cost-effective OoO technique for GPUs. In an in-order GPU, a warp scheduler selects a single instruction to issue by considering only the oldest instruction from each context. GhOST introduces OoO execution by having the warp scheduler instead consider the instruction from each context’s instruction buffer deemed most likely to issue, while preserving sequential semantics. The architecture of GhOST allows it to elide register renaming and reordering memory instructions in the instruction buffer, without sacrificing performance. Thus, GhOST executes memory instructions sequentially, removing any need for dependence analysis. Since GhOST is a hardware only technique, which makes no modifications to the ISA, it can run binaries directly compiled using CUDA for all benchmarks. On the Nvidia Titan V (T) and RTX 2060 Super &amp;reg; GPUs, GhOST delivers 20.0% (T) and 21.8% &amp;reg; geomean speedup across 30 benchmarks, with a 0.05% increase in area. As future work, we will look at using the compiler to reorder instructions to further boost the OoO performance of GhOST.~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Ishita Chaturvedi is a third-year Ph.D. student at Princeton University, working with Prof. David August in the Liberty Research group. Her research interests lie in computer architecture and high-performance computing. More specifically, she is working on efficient out-of-order execution on GPUs.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022sp/</link>
      <pubDate>Wed, 23 Mar 2022 10:27:25 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-1&#34;&gt;April 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Olivia Hsu&lt;/td&gt;
&lt;td&gt;Compilation of Sparse Array Programming Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-8&#34;&gt;April 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Suyash Gupta&lt;/td&gt;
&lt;td&gt;Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-15&#34;&gt;April 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Amanda Liu&lt;/td&gt;
&lt;td&gt;Verified Tensor-Program Optimization Via High-Level Scheduling Rewrites&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-22&#34;&gt;April 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Will Crichton&lt;/td&gt;
&lt;td&gt;Modular Information Flow Through Ownership&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-29&#34;&gt;April 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Slim Lim and Geoffrey Litt&lt;/td&gt;
&lt;td&gt;Peritext: A CRDT for Collaborative Rich Text Editing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-6&#34;&gt;May 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Asta Halkjær From&lt;/td&gt;
&lt;td&gt;A Naive Prover for First-Order Logic Formalized in Isabelle/HOL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-13&#34;&gt;May 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Farid Zakaria&lt;/td&gt;
&lt;td&gt;Reproducibility is hard: Insights and improvements at the bottom of the stack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-20&#34;&gt;May 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Michael Coblenz&lt;/td&gt;
&lt;td&gt;Squashing Bugs and Empowering Programmers with User-Centered Programming Language Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-27&#34;&gt;May 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Douglas Creager&lt;/td&gt;
&lt;td&gt;Incremental, zero-config Code Navigation using stack graphs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-3&#34;&gt;June 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yao Li&lt;/td&gt;
&lt;td&gt;Program Adverbs and Tlön Embeddings&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;april-1&#34;&gt;April 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Olivia Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compilation of Sparse Array Programming Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This talk explains how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. This talk describes our compiler strategy, which generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions. We then show how to compile these iteration spaces to efficient code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Olivia is a computer science PhD student at Stanford University advised by Professor Kunle Olukotun and Professor Fredrik Kjolstad. She currently works on mapping sparse applications to domain-specific architectures, reconfigurable dataflow hardware, and accelerators through the TACO compiler. Her research interests broadly include computer architecture, computer and programming systems, compilers, programming models and languages, and digital circuits/VLSI.&lt;/p&gt;

&lt;h1 id=&#34;april-8&#34;&gt;April 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Suyash Gupta&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Since the introduction of Bitcoin—the first widespread application driven by blockchains—the interest in the design of blockchain-based applications has increased tremendously. At the core of these blockchain applications are consensus protocols that aim at securely replicating a client request among all replicas, even if some replicas are Byzantine faulty. Unfortunately, modern consensus protocols either yield low throughput or face design limitations.
In this work, we present the design of three consensus protocols that facilitate efficient consensus among the replicas. Our protocols help to scale consensus through the principles of phase-reduction, parallelization, and geo-scale clustering while ensuring no compromise in fault-tolerance. Further, we believe that the focus on consensus protocols is only one-side of the story. Specifically, we present the design of a well-crafted permissioned blockchain fabric (ResilientDB) that can help even a slow consensus protocol outperform a faster protocol. Our results indicate that it is easy to scale BFT protocols to hundreds of replicas and achieve throughputs of the order 350K txns/s.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Suyash Gupta is a postdoctoral researcher at the RISELab, University of California, Berkeley. He is also the Lead Architect of ResilientDB fabric. Prior to joining RISELab, he received his Ph.D. degree from University of California, Davis. He also holds two Master of Science degrees; one from Purdue University and another from Indian Institute of Technology Madras. His current research focuses on attaining safe and efficient, fault tolerant distributed consensus and communication. He has also co-authored a book on fault-tolerant distributed transaction processing at Morgan &amp;amp; Claypool. In his free time, Suyash likes to code and has won awards at several hackathons.&lt;/p&gt;

&lt;h1 id=&#34;april-15&#34;&gt;April 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Amanda Liu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Verified Tensor-Program Optimization Via High-Level Scheduling Rewrites&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We present a lightweight Coq framework for optimizing tensor kernels written in a pure, functional array language. Optimizations rely on user scheduling using a series of verified, semantics-preserving rewrites. Unusually for compilation targeting imperative code with arrays and nested loops, all rewrites are source-to-source within a purely functional language. Our language comprises a set of core constructs for expressing high-level computation detail and a set of what we call reshape operators, which can be derived from core constructs but trigger low-level decisions about storage patterns and ordering. We demonstrate that not only is this system capable of deriving the optimizations of existing state-of-the-art languages like Halide and generating comparably performant code, it is also able to schedule a family of useful program transformations beyond what is reachable in Halide.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Amanda Liu is a second year PhD student working with Prof. Adam Chlipala and Prof. Jonathan Ragan-Kelley. Her interests are using formal methods and programming languages to develop verified, principled methods for writing high-performance systems.&lt;/p&gt;

&lt;h1 id=&#34;april-22&#34;&gt;April 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Will Crichton&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular Information Flow Through Ownership&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Statically analyzing information flow, or how data influences other data within a program, is a challenging task in imperative languages. Analyzing pointers and mutations requires access to a program&amp;rsquo;s complete source. However, programs often use pre-compiled dependencies where only type signatures are available. We demonstrate that ownership types can be used to soundly and precisely analyze information flow through function calls given only their type signature. From this insight, we built Flowistry, a system for analyzing information flow in Rust, an ownership-based language. In this talk, I will describe how Flowistry works, how we prove its soundness, and how we show that the ownership-based modular approximation does not lose much precision versus a whole-program analysis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Will Crichton is a 6th year PhD student at Stanford University advised by Profs. Pat Hanrahan and Maneesh Agrawala. His research combines cognitive psychology and programming language theory to understand how people program, and to design better tools for programmers.&lt;/p&gt;

&lt;h1 id=&#34;april-29&#34;&gt;April 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speakers:&lt;/strong&gt; Slim Lim and Geoffrey Litt&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Peritext: A CRDT for Collaborative Rich Text Editing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Conflict-Free Replicated Data Types (CRDTs) support decentralized collaborative editing of shared data, enabling peer-to-peer sharing and flexible branching and merging workflows. While there is extensive work on CRDTs for plain text, much less is known about CRDTs for rich text with formatting. No algorithms have been published, and existing open-source implementations do not always preserve user intent. In this talk, we describe a model of intent preservation in rich text editing, developed through a series of concurrent editing scenarios. We then describe Peritext, a CRDT algorithm for rich text that satisfies the criteria of our model. The key idea is to store formatting spans alongside the plaintext character sequence, linked to a stable identifier for the first and last character of each span, and then to derive the final formatted text from these spans in a deterministic way that ensures concurrent operations commute.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bios:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Slim Lim is a first-year PhD student at UC Berkeley studying the intersection of programming languages and human-computer interaction. She is particularly interested in type systems for UI programming and UI programming for type systems. Previously she worked as a software engineer developing collaborative text editing features. Even more previously, she researched semantic tooling for Cascading Style Sheets, culminating in the Inactive CSS inspection feature in Firefox 70.&lt;/p&gt;

&lt;p&gt;Geoffrey Litt is a third-year PhD student at MIT in HCI, researching end-user programming and local-first collaboration. His recent research interests include powering UIs with a malleable client-side database, and managing schema evolution in distributed systems&lt;/p&gt;

&lt;h1 id=&#34;may-6&#34;&gt;May 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Asta Halkjær From&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Naive Prover for First-Order Logic Formalized in Isabelle/HOL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When using sequent calculus to prove a formula in classical first-order logic by hand, we may rely on our
intuition to pick the right sequence of rule applications, choose the most useful instantiations of variables
and so on. In implementing a prover to do so, we must very carefully ensure that the mechanical process
always finds a proof for a provable formula. This can be intricate and proving that the crafted algorithm
lives up to expectations can be even more challenging, especially in a formalized setting. To mitigate all
this, we may instead rely on a fair stream of all possible rule applications to all possible formulas. Such a
stream works as an oracle, telling us exactly which rule to apply to which formula, resulting in a very
simple prover. In this talk, I present a prover based on this technique, with formalized soundness and
completeness proofs in the proof assistant Isabelle/HOL.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Asta is a 3rd and final year PhD student in computer science and logic at the Technical University of Denmark where she is advised by Jørgen Villadsen and Nina Gierasimczuk.  She works on using proof assistants, especially Isabelle/HOL, to develop and formalize results in logic and is also interested in the pedagogical benefits of using interactive theorem provers in teaching.  She is the author of multiple entries in the Archive of Formal Proofs.&lt;/p&gt;

&lt;h1 id=&#34;may-13&#34;&gt;May 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Farid Zakaria&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Reproducibility is hard: Insights and improvements at the bottom of the stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; One of the fundamental data management units within a
Linux system are shared object files with which processes dynamically
link to at startup. The mechanism and approach to dynamic linking is
becoming increasingly inadequate for complex systems because of the
lack of data management principles. Novel software packaging models,
such as Nix, have emerged and are becoming increasingly popular to try
to tame the chaos induced by the Filesystem Hierarchy Standard but
suffer from limitations of a simplistic schema. Restricted to a
minimal schema that only allows modification of a list of directory
paths to modify the search query, the resolution of needed
dependencies can quickly become prohibitively costly. Shrinkwrap is a
tool that when used within hermetic packaging models such as Nix,
embosses the required dependencies to fixed locations avoid repetitive
lookups by storing the absolute paths of the needed dependencies. This
ability to have queries cached is currently missing from these
increasingly popular store-based distributions and has meaningful
improvements on startup times by up to 35x.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Farid Zakaria is a 2nd year PhD student at University of California
Santa Cruz and is advised by Dr. Carlos Maltzhan. He is currently
looking into opportunities to improve reproducibility of software,
especially deeper in the software stack. He is an active member of the
NixOS community and his research areas include linkers, build systems
and operating systems.&lt;/p&gt;

&lt;h1 id=&#34;may-20&#34;&gt;May 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Michael Coblenz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Squashing Bugs and Empowering Programmers with User-Centered Programming Language Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Programming languages are simultaneously formal systems and user interfaces with which programmers work. Unfortunately, programmers have a hard time writing safe software: serious bugs and security vulnerabilities are common. In many cases, however, languages with strong safety guarantees have been hard to use. In this talk, I’ll discuss user-centered design methods I developed to help language designers create languages that are easier to use. I’ll show how I created and evaluated Obsidian, a new smart contract language that uses a linear type system, and Bronze, a new garbage collector for Rust. I found that programmers are more effective when using the resulting languages than when using prior languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Michael Coblenz is a Basili Postdoctoral Fellow at the University of Maryland. Michael developed the PLIERS method, which integrates user-centered methods into the design process for safe programming languages. He created Glacier, an immutability system for Java; Obsidian, a strongly-typed language for smart contracts; and Bronze, a garbage collector that improves usability of Rust. He holds a Ph.D. in computer science from Carnegie Mellon University. Previously, he was a Senior Software Engineer at Apple. His work, which is at the intersection of programming languages, software engineering, and human-computer interaction research, has been published at OOPSLA, TOPLAS, ICSE, and TOCHI.&lt;/p&gt;

&lt;h1 id=&#34;may-27&#34;&gt;May 27&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Douglas Creager&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Incremental, zero-config Code Navigation using stack graphs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Exploring a large or unfamiliar codebase can be tricky. Code Navigation features like “jump to definition” and “find all references” let you discover how different pieces of code relate to each other. To power these features, we need to extract lists of symbols from the code, and describe the language-specific rules for how those symbols relate to each other.&lt;/p&gt;

&lt;p&gt;It’s difficult to add Code Nav to a large hosted service like GitHub, where we must support hundreds of programming languages, hundreds of millions of repositories, and petabytes of history. At this scale, we have a different set of design constraints than a local IDE. We need our data extraction to be incremental, so that we can reuse previous results for files that haven’t changed in a newly pushed commit, saving both compute and storage costs. And to support cross-repo lookups, it should require zero configuration — repo owners should not have to set up anything manually to activate the feature.&lt;/p&gt;

&lt;p&gt;In this talk I’ll describe stack graphs, which use a graphical notation to define the name binding rules for a programming language. They work equally well for dynamic languages like Python and JavaScript, and for static languages like Go and Java. Our solution is fast — processing most commits within seconds of us receiving your push. It does not require setting up a CI job, or tapping into a project-specific build process. And it is open-source, building on the tree-sitter project’s existing ecosystem of language tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Douglas Creager manages the Semantic Code team at GitHub. We apply academic programming language research to build productivity tools that can operate on &lt;em&gt;all&lt;/em&gt; of the code hosted on GitHub. Our goal is to make it easier for developers and maintainers to understand what their code does, and how other developers use it.&lt;/p&gt;

&lt;h1 id=&#34;june-3&#34;&gt;June 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yao Li&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Program Adverbs and Tlön Embeddings&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This will be a two-part talk. In the first part, I&amp;rsquo;d like to present you the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward “one client at a time” style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.
In the second part, I&amp;rsquo;ll dive into a question to the first part: &amp;ldquo;why interaction trees&amp;rdquo;? I&amp;rsquo;d like to show you that, inspired by applicative functors, selective functors, and other structures, we can define a collection of data structures and theories, which we call program adverbs, that capture a variety of computational patterns. Program adverbs are themselves composable, allowing them to be used to specify the semantics of languages with multiple computation patterns. We use program adverbs as the basis for a new class of semantic embeddings called Tlön embeddings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Yao Li is a Ph.D. candidate at the University of Pennsylvania (advised by Stephanie Weirich) and an incoming assistant professor at Portland State University (Fall 2022). His main research interests are programming languages and formal verification. His research aims to (1) advance the state of the art of verification on real-world software and (2) make verification easier to use from a programming languages perspective. Previously, Yao Li obtained his bachelor’s and master’s degrees in Software Engineering from Shanghai Jiao Tong University. He was a research intern at Microsoft Research in 2018 and a visiting researcher at Università della Svizzera italiana in 2015. He also served as a mentor in Research Experience for Undergraduates at the University of Pennsylvania in 2021 and in Google Summer of Code for Scala in 2016.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022wi/</link>
      <pubDate>Mon, 03 Jan 2022 14:46:51 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-7&#34;&gt;Jan. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dev Purandare&lt;/td&gt;
&lt;td&gt;Append is Near: Log-based Data Management on ZNS SSDs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-14&#34;&gt;Jan. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Max Willsey&lt;/td&gt;
&lt;td&gt;What&amp;rsquo;s up with E-Graphs?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-21&#34;&gt;Jan. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jonathan Castello&lt;/td&gt;
&lt;td&gt;Simulating spacecraft: Not exactly rocket science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-28&#34;&gt;Jan. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Reese Levine&lt;/td&gt;
&lt;td&gt;A Strong Approach to Testing Weak Memory Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-4&#34;&gt;Feb. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kostis Kaffes&lt;/td&gt;
&lt;td&gt;Syrup: User-Defined Scheduling across the Stack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-11&#34;&gt;Feb. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tzu-Han Hsu&lt;/td&gt;
&lt;td&gt;Bounded Model Checking for Hyperproperties&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-18&#34;&gt;Feb. 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Matthew Weidner&lt;/td&gt;
&lt;td&gt;Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-25&#34;&gt;Feb. 25&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jocelyn Chen&lt;/td&gt;
&lt;td&gt;Web question answering with neurosymbolic program synthesis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-4&#34;&gt;March 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jie Zhou&lt;/td&gt;
&lt;td&gt;Fat Pointers for Temporal Memory Safety of C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-11&#34;&gt;March 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sorawee Porncharoenwase&lt;/td&gt;
&lt;td&gt;An Expressive and Optimal Pretty Printer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-7&#34;&gt;Jan. 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Dev Purandare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Append is Near: Log-based Data Management on ZNS SSDs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Log-based data management systems use storage as if it was an append-only medium in order to transform random writes into sequential writes, delivering a major advantage when logs were persisted on hard disks. Although solid-state drives (SSDs) offer improved random write capabilities, sequential writes continue to be advantageous due to locality and space efficiency. However, the inherent properties of flash-based SSDs induce significant disadvantages when utilizing a random write block interface, causing write amplification, uneven wear, log stacking, and garbage collection overheads. To eliminate these disadvantages, Zoned Namespace (ZNS) SSDs have recently been introduced. They offer increased capacity, reduced write amplification, and higher performance but require the host to participate in data placement through zones, which have sequential-write semantics and must be explicitly reset. In ZNS, the Zone Append primitive allows the host to push down fine-grained data placement onto the device, supporting appends to a zone without knowing the location of the tail. Full zones become immutable, greatly simplifying disaggregated storage and operations like replication.&lt;/p&gt;

&lt;p&gt;We propose another pushdown technique, Group Append, which allows appends of data that is smaller (or possibly larger) than a block, offloading data buffering to the controller. We explore how ZNS SSDs with Zone Append, Group Append, and computational storage can benefit four log-based data management areas: (i) log-based file systems, (ii) LSM trees such as RocksDB, (iii) database systems, and (iv) event logs/shared logs. We also propose research directions for all four log-based data management using ZNS SSDs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dev is a PhD candidate in the Computer Science department at University of California Santa Cruz. His research interests lie in storage systems, operating systems and distributed systems, and programming languages. Dev completed his Bachelor&amp;rsquo;s in Computer Engineering at Savitribai Phule Pune University (SPPU) in India. At UCSC he has been working on improving the lifetime of low cost, low reliability SSDs and evolving systems for Zoned Namespace SSDs. Dev has been an Engineering Intern at Riverbed Networks (2017), and an Architecture Enabling Intern at SK Hynix America Ltd. (2019). He can be found on twitter (@dev14e), LinkedIn (devashishp), and email (devashish@ucsc.edu).&lt;/p&gt;

&lt;h1 id=&#34;jan-14&#34;&gt;Jan. 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Max Willsey&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What&amp;rsquo;s up with E-Graphs?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; E-graphs are an important data structure inside SMT solvers, but recently they have been used for a whole lot more, including optimization, program synthesis, and verification!&lt;/p&gt;

&lt;p&gt;This talk will give a whirlwind introduction to e-graphs and equality saturation, as well as some new algorithms that make them faster. I&amp;rsquo;ll also introduce &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, a toolchain that packages all this up into a generic, reusable library. Then, we&amp;rsquo;ll move on to some applications of these new techniques, including floating point accuracy, 3D CAD, deep learning, and more. Finally, I&amp;rsquo;ll talk about some of the current work folks are using egg for, including a teaser for our &lt;a href=&#34;https://arxiv.org/abs/2108.02290&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;upcoming POPL paper&lt;/a&gt; that connects e-graphs to databases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.mwillsey.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Max&lt;/a&gt; is a postdoc at the University of Washington in the &lt;a href=&#34;http://uwplse.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;PLSE&lt;/a&gt; group, where he also did his PhD. His main line of work is on &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, an e-graph and equality saturation toolkit.&lt;/p&gt;

&lt;h1 id=&#34;jan-21&#34;&gt;Jan. 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jonathan Castello&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Simulating spacecraft: Not exactly rocket science&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Caltech&amp;rsquo;s Jet Propulsion Laboratory (JPL) operates a fleet of autonomous spacecraft across our solar system. For more than thirty years, operators have validated planned activities against a simulated model of their spacecraft in order to preserve these valuable resources. These models are typically implemented in a domain-specific language (a DSL), which is then interpreted for an execution plan by reusable simulation systems.&lt;/p&gt;

&lt;p&gt;As we make our spacecraft even more intelligent, our spacecraft models become correspondingly more complex. Existing simulation systems were designed with a minimal DSL and limited scope, and have been significantly expanded under a constant flow of feature requests. Unfortunately, this has led to simulation systems and models that are difficult to understand and maintain without relying on global reasoning and deep expertise.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NASA-AMMOS/aerie/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Merlin&lt;/a&gt; is a newly open-sourced simulation system under development at JPL. Merlin models are written in plain Java, which we try to make as &amp;ldquo;uninteresting&amp;rdquo; as possible for modelers. Instead, we spend our &amp;ldquo;novelty budget&amp;rdquo; mostly under the hood. This talk will showcase the concurrency semantics supporting local reasoning in Merlin, and some of the techniques we take to keep Merlin out of the way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt; is a software engineer most recently with Caltech&amp;rsquo;s Jet Propulsion Laboratory, where he worked on both modern and legacy ground software for spacecraft operations. His research interests sit at the nexus of modular design, concurrency, and monotonic state.&lt;/p&gt;

&lt;h1 id=&#34;jan-28&#34;&gt;Jan. 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Reese Levine&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Strong Approach to Testing Weak Memory Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; GPUs are increasingly being used for compute workloads that require interactions between threads using shared memory. Like many CPUs, GPUs expose weak memory models that allow for more aggressive compiler and hardware optimizations at the expense of a more complex programming model. Testing these memory models is an ongoing line of research.&lt;/p&gt;

&lt;p&gt;This talk will detail our ongoing project on testing GPU memory models. First, we will show a motivating example from an optimized renderer and illustrate how we can reason about the synchronization in the renderer using classic weak memory model litmus tests. Next, we will overview recent work on testing GPU memory models, including complex heuristics necessary to reveal weak behaviors in testing. Our new work builds on this existing work in several ways: (1) we provide a simple DSL and a compiler for expressing litmus tests and testing heuristics; we currently have backends for Vulkan and WebGPU. (2) A new parallel execution model for litmus tests, which allows tests to be executed an order of magnitude faster than in prior works. (3) A web application interface for running litmus tests through WebGPU. We will conclude with a discussion on how these contributions might lead to more robust testing methodologies and hope to facilitate discussions on how they relate to conformance testing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Reese Levine is a second year PhD student at UC Santa Cruz advised by Tyler Sorensen. He is interested in research in parallel, concurrent, and distributed systems, and his work currently focuses on testing weak memory models in GPUs.&lt;/p&gt;

&lt;h1 id=&#34;feb-4&#34;&gt;Feb. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kostis Kaffes&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Syrup: User-Defined Scheduling across the Stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Suboptimal scheduling decisions in operating systems, networking stacks, and application runtimes are often responsible for poor application performance, including higher latency and lower throughput. These poor decisions stem from a lack of insight into the applications and requests the scheduler is handling and a lack of coherence and coordination between the various layers of the stack, including NICs, kernels, and applications. We propose Syrup, a framework for user-defined scheduling. Syrup enables untrusted application developers to express application-specific scheduling policies across these system layers without being burdened with the low-level system mechanisms that implement them. Application developers write a scheduling policy with Syrup as a set of matching functions between inputs (threads, network packets, network connections) and executors (cores, network sockets, NIC queues) and then deploy it across system layers without modifying their code. Syrup supports multi-tenancy as multiple co-located applications can each safely and securely specify a custom policy. We present several examples of uses of Syrup to define application and workload-specific scheduling policies in a few lines of code, deploy them across the stack, and improve performance up to 8x compared with default policies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kostis Kaffes is a final-year Ph.D. candidate in Electrical Engineering at Stanford University, advised by Christos Kozyrakis. He is broadly interested in computer systems, cloud computing, and scheduling. His thesis focuses on end-host, rack-scale, and cluster-scale scheduling for microsecond-scale tail latency. Recently, he has been looking for ways to make it easier to implement and deploy custom scheduling policies across different layers of the stack. Kostis&amp;rsquo;s research has been supported by a Facebook Research Award and various scholarships and fellowships from Stanford, A.G. Leventis Foundation, and Gerondelis Foundation. Prior to Stanford, he received his undergraduate degree in Electrical and Computer Engineering from the National Technical University of Athens in Greece.&lt;/p&gt;

&lt;h1 id=&#34;feb-11&#34;&gt;Feb. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tzu-Han Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bounded Model Checking for Hyperproperties&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Hyperproperties is a powerful framework for specifying and reasoning about important classes of requirements that were not possible with trace-based languages such as the classic temporal logics. This talk will introduce a novel bounded model checking (BMC) algorithm for hyperproperties expressed in HyperLTL. Just as the classic BMC technique for LTL primarily aims at finding bugs, our approach also targets identifying counterexamples. Followed by the reduction of BMC for LTL to SAT solving, our BMC approach naturally reduces to QBF solving, as HyperLTL allows explicit and simultaneous quantification over multiple traces. Our algorithm is sound based on our theory of bounded semantics, which guarantees correct BMC results under finite exploration. We will also present our implemented tool HyperQube, a push-button QBF-based bounded model checker for hyperproperties, and demonstrate the effectiveness and efficiency of our approach via a rich set of practical applications, including security, concurrent data structures, path planning for multi-agent systems, and secrecy-preserving refinement mapping synthesis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tzu-Han Hsu is a second-year Ph.D. student in Computer Science and Engineering department at Michigan State University, advised by Dr. Borzoo Bonakdarpour. Her research areas include formal methods, model checking, verification, and synthesis for security/privacy policies. She is recently working on the topic of hyperproperties, a framework that can reason about multiple traces simultaneously, which has rich applications in formal analysis especially for multi-threaded and concurrent programs.&lt;/p&gt;

&lt;p&gt;Before MSU, Tzu-Han received her bachelor’s degrees in Computer Science and Music-Piano Performance from Iowa State University in 2020. Tzu-Han can be reached on Twitter (@TzuHanH), LinkedIn (tzuhanhsu), email (tzuhan@msu.edu), and her personal website (&lt;a href=&#34;https://tzuhancs.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://tzuhancs.github.io/&lt;/a&gt;).&lt;/p&gt;

&lt;h1 id=&#34;feb-18&#34;&gt;Feb. 18&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Matthew Weidner&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many distributed systems allow a group of devices to edit some shared state. Examples include collaborative apps, such as Google Docs and Figma, and distributed key-value stores. Often, these systems are highly available: each device can edit its own replica of the state immediately, then sync up with other devices in the background. Eventual consistency requires that once this syncing completes, all devices agree on the new state.&lt;/p&gt;

&lt;p&gt;Eventual consistency is challenging because devices might make conflicting concurrent edits. For example, two users might type at the same time in a Google Doc, or one user might add entries to a spreadsheet while another alters the layout and formatting. Somehow, we must combine all these edits in a way that is consistent across devices and hopefully also makes sense to users. Conflict-free Replicated Data Types (CRDTs) provide one solution to this challenge, by giving programmers data structures with built-in replication and eventual consistency. However, they tend to be hard to understand or customize.&lt;/p&gt;

&lt;p&gt;In this talk, I will propose a way of creating CRDTs by composing simple, easy-to-understand pieces. Ideally, this could let programmers design eventually consistent systems while maintaining complete control over the system&amp;rsquo;s behavior. A &lt;a href=&#34;https://mattweidner.com/2022/02/10/collaborative-data-design.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt; describes the proposal in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://mattweidner.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthew&lt;/a&gt; is a third year PhD student at Carnegie Mellon University, advised by Heather Miller. His research focuses on tools for decentralized systems, with a particular interest in enabling open-source, local-first collaborative apps. Previously, he completed an MPhil at Cambridge University as a Churchill Scholar, where he studied decentralized secure group messaging protocols for the &lt;a href=&#34;https://www.cl.cam.ac.uk/research/dtg/trve/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;TRVE Data&lt;/a&gt; project.&lt;/p&gt;

&lt;h1 id=&#34;feb-25&#34;&gt;Feb. 25&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jocelyn Chen&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Web question answering with neurosymbolic program synthesis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the amount of information available on the web proliferates, there is a growing need for tools that can extract relevant information from the website. Due to the importance of the problem, there has been a flurry of research activity on information extraction and wrapper induction by using powerful neural models and program synthesis. While wrapper induction tools based on program synthesis work well when the target webpages have a shared global schemes, they are not as effective on structurally heterogeneous websites such as faculty webpages. On the other hand, ML-based techniques from the NLP community are, in principal, applicable to heterogeneous websites; however, by treating the entire webpage as unstructured texts, they fail to take advantage of the inherent tree structure of the HTML documents.&lt;/p&gt;

&lt;p&gt;In this talk, we propose a new information extraction approach based on neurosymbolic program synthesis that combines the relative strengths of wrapper induction techniques for webpages with the flexibility of neural models for unstructured documents. Our approach targets structurally heterogeneous websites with no shared global schema and can be used to automate many different types of information extraction tasks. The key idea of our approach is to employ a neurosymbolic DSL that incorporates both neural NLP models as well as standard language constructs for tree navigation and string manipulation. We also propose an optimal synthesis algorithm that generates all DSL programs that achieve optimal F1 score on the training examples. We have implemented these ideas in a new tool called WebQA and evaluate it on 25 different tasks across multiple domains. Our experiments show that WebQA significantly outperforms existing tools such as state-of-the-art question answering models and wrapper induction systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jocelyn Chen is a fourth-year graduate student at the University of Texas at Austin working with Isil Dillig. She is mainly interested in research at the intersection of program synthesis and natural language processing.&lt;/p&gt;

&lt;h1 id=&#34;march-4&#34;&gt;March 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jie Zhou&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Fat Pointers for Temporal Memory Safety of C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The past decade has seen an increasing trend of real-world exploits against temporal memory safety bugs in C/C++ programs, i.e., use-after-free (UAF), double free, and invalid free. These bugs are profoundly dangerous in that they can lead to data corruption, information leaking, or even arbitrary code execution.  Many solutions were proposed, but they suffer one or more severe limitations such as high performance/memory overhead and missing bugs.&lt;/p&gt;

&lt;p&gt;In this talk, I will describe how we solve this problem for C efficiently and comprehensively. We combine two existing techniques: fat pointers (in-place metadata) and ID-based dynamic pointer validation. We build our solution based on Checked C–a promising safe dialect of C which provides spatial memory safety but currently lacks temporal memory safety. We show that our solution significantly improves the performance and memory consumption compared to using disjoint metadata for pointer validation. Additionally, we also show that our solution is practical in terms of backward compatibility–one of the major concerns about fat pointers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/jzhou41/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jie Zhou&lt;/a&gt; is a fifth-year PhD student at the University of Rochester. Jie works on systems and software security, with a focus on memory safety. He is most interested in improving systems programming languages and their toolchains for security as he believes that language-based techniques can solve problems in a more fundamental way. He is also interested in developing program analysis and transformation techniques to enforce security policies on low-level software.&lt;/p&gt;

&lt;h1 id=&#34;march-11&#34;&gt;March 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Sorawee Porncharoenwase&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An Expressive and Optimal Pretty Printer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Pretty printers transform structured data into &amp;ldquo;pretty&amp;rdquo; text. In this talk, I will present a pretty printing algorithm that (1) is strictly more expressive than current state-of-the-art algorithms; (2) guarantees optimality; and (3) has better time complexity than many state-of-the-art pretty printers. To distinguish our pretty printer from others, I will also give a brief survey of the existing pretty printing algorithms and dispel various myths about traditional pretty printers that turn out to be inaccurate. This is a joint work with Justin Pombrio and Emina Torlak.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sorawee (Oak) is a fourth year PhD student at the University of Washington, advised by Emina Torlak. His research interest is improving usability of symbolic evaluation.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021fa/</link>
      <pubDate>Tue, 31 Aug 2021 19:47:53 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2021, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-24&#34;&gt;Sept. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Welcome!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-1&#34;&gt;Oct. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-8&#34;&gt;Oct. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Rescuing Data Center Processors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-15&#34;&gt;Oct. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Data Driven Program Merge&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-22&#34;&gt;Oct. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-29&#34;&gt;Oct. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Gradual Verification of Recursive Heap Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-5&#34;&gt;Nov. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-12&#34;&gt;Nov. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sparse Matrices and High-Performance Computing Meet Biology&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-19&#34;&gt;Nov. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-3&#34;&gt;Dec. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-24&#34;&gt;Sept. 24&lt;/h1&gt;

&lt;p&gt;Welcome!&lt;/p&gt;

&lt;h1 id=&#34;oct-1&#34;&gt;Oct. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We will explore how we can make it cheaper to run blockchain protocols and programs&amp;mdash;while guaranteeing correctness!&lt;/p&gt;

&lt;p&gt;For cheaper protocols, we move from a block&lt;em&gt;chain&lt;/em&gt; to a block&lt;em&gt;graph&lt;/em&gt;. Such a blockgraph, which we show to be a reliable point-to-point link, is built together by a set of servers. Thereby, the servers embed many parallel runs of a deterministic protocol into it. And because the protocol is deterministic, every server can locally replay the protocol&amp;mdash;and no more messages need to be sent [1]!&lt;/p&gt;

&lt;p&gt;For cheaper programs, we super-optimize bytecode of the Ethereum Virtual Machine, which runs on many servers to execute programs on the blockchain. Now, to avoid the halting problem, every executed bytecode costs money. So we have a clear optimization target&amp;mdash;money&amp;mdash;and we use an automated theorem prover to synthesize cheaper, observationally equivalent, programs [2].&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria A Schett&lt;/a&gt; is currently finishing her PhD on &amp;ldquo;Cost Reduction With Guarantees: Formal Reasoning Applied To Blockchain Technologies&amp;rdquo; at University College London. She loves living in London and talking about blockchains, distributed systems, and compilers. She is conversational in term rewriting and qualitative research (from a previous life) and in Esperanto.&lt;/p&gt;

&lt;p&gt;[1] &amp;ldquo;Embedding a Deterministic BFT Protocol in a Block DAG&amp;rdquo;, Maria A Schett and George Danezis, Proc. of the 2021 ACM Symposium on Principles of Distributed Computing (PODC) 2021&lt;/p&gt;

&lt;p&gt;[2] &amp;ldquo;Synthesis of Super-Optimized Smart Contracts using Max-SMT&amp;rdquo;, Elvira Albert, Pablo Gordillo, Albert Rubio and Maria A Schett, Proc. of 32nd International Conference on Computer-Aided Verification (CAV) 2020&lt;/p&gt;

&lt;h1 id=&#34;oct-8&#34;&gt;Oct. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Rescuing Data Center Processors&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; To serve billions of users around the world, modern web applications that run across data centers access huge datasets and perform complex application logic. As a result, data center applications face two major challenges: (1) poor data access behavior and (2) poor instruction access behavior. In my research, I demonstrate that novel hardware-software codesign effectively solves both challenges. Specifically, I observe that both data and instruction accesses in data center applications follow a deeply repetitive pattern that can be efficiently optimized by profiling the application’s program flow behavior. In this talk, I will first present an overview of my techniques to improve data and instruction accesses. I will then describe two of my techniques in detail, showing how these techniques outperform prior proposals from Google.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tanvir Ahmed Khan is a fifth-year Ph.D. candidate at the University of Michigan. His research interests lie at the intersection of computer architecture, compilers, and operating systems. He is interested in designing techniques at the boundary of hardware and software that enable software to better leverage hardware resources. He was a Facebook Fellowship (2020) finalist. His research on data center applications’ performance optimizations has appeared in top computer architecture and systems venues like ISCA, MICRO, PLDI, and OSDI. His work is being used by Intel and ARM to design the next-generation CPU architectures. Tanvir expects to graduate soon and after graduation, he is interested in tenure-track faculty positions.&lt;/p&gt;

&lt;h1 id=&#34;oct-15&#34;&gt;Oct. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Data Driven Program Merge&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In collaborative software development, &lt;em&gt;program merging&lt;/em&gt; is the mechanism to integrate changes from multiple programmers. The most widespread merge algorithm, employed in modern version control systems, is an &lt;em&gt;unstructured&lt;/em&gt; merge. Unstructured merge treats input programs as a sequence of characters and reports a conflict when changes interfere textually. On the other hand, &lt;em&gt;structured&lt;/em&gt; approaches leverage knowledge of the underlying language to perform “intelligent” merges over the program’s AST. These approaches have shown significant advancements in automatic merging for Java. However, these methods have not found their way into modern version control systems as they are typically language dependent and do not generalize to dynamic languages such as JavaScript.&lt;/p&gt;

&lt;p&gt;In a 1991 seminal paper on program merge [1], Westfechtel voiced: “A tool is &lt;em&gt;urgently&lt;/em&gt; needed which automates the process of merging as much as possible.”  Thirty years later, and there have not been significant advances in the prevailing merge algorithm - unstructured merge.&lt;/p&gt;

&lt;p&gt;In this work, we take a &lt;em&gt;fresh data-driven&lt;/em&gt; look at the problem of merge resolution. Guided by a multilingual dataset of over 200,000 merges, we explore deep learning techniques to resolve unstructured merge conflicts. Our key innovation is an edit-aware embedding of merge inputs.&lt;/p&gt;

&lt;p&gt;Our resulting model achieves 63&amp;ndash;68% accuracy of merge resolution synthesis, yielding nearly a 3x performance improvement over existing structured merge tools. Finally, we demonstrate that our approach is sufficiently flexible to work with source code files in Java, JavaScript, TypeScript, and C# programming languages, and can generalize zero-shot to unseen languages.&lt;/p&gt;

&lt;p&gt;[1] Bernhard Westfechtel. 1991. Structure-oriented merging of revisions of software documents. In &lt;em&gt;Proceedings of the 3rd international workshop on Software configuration management&lt;/em&gt; (SCM &amp;lsquo;91).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Elizabeth Dinella is a fourth-year PhD student at the University of Pennsylvania. Her research interests can be broadly described as “data-driven program reasoning.” Most recently, Elizabeth has worked on data-driven bug finding (&lt;a href=&#34;https://openreview.net/pdf?id=SJeqs6EFvB&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hoppity&lt;/a&gt;), program merge, and test oracle inference. She is an admirer of coffee and her chow chow puppy Cinnabon.&lt;/p&gt;

&lt;h1 id=&#34;oct-22&#34;&gt;Oct. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; A large part of our lives is spent online, creating, sharing, and consuming data in various forms. We use a profusion of security protocols to handle this more-often-than-not sensitive data, and connect to the internet and to the world at large. How secure are these communications? How private? These are fundamental questions to which we demand definitive answers. Even with highly sophisticated methods of testing, one cannot get unconditional answers, and this is where formal verification steps in. One can use logic or automata or similar formal methods to conclusively tell us if there are security flaws in these protocols. In this talk, we will provide a quick and dirty introduction to the world of symbolic verification, with a focus on security protocols. We will then look at a few ways in which the protocols of today’s day and age are modelled and verified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vaishnavi Sundararajan is a postdoc at UCSC. She completed her PhD at Chennai Mathematical Institute, with a thesis on formal aspects of certification in security protocols. She is interested in the areas of logic, security, proof theory and verification. Before UCSC, she was a postdoc at IRISA, Rennes, and a Research Associate at Ericsson Research, Bengaluru.&lt;/p&gt;

&lt;h1 id=&#34;oct-29&#34;&gt;Oct. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Gradual Verification of Recursive Heap Data Structures&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. Our OOPSLA’20 paper [1] extended gradual verification to programs that manipulate recursive, mutable data structures on the heap. This talk outlines our extension and discusses technical challenges addressed during its development, such as ensuring consistency between static and dynamic checking. I also present the design of a gradual verifier that we built as follow-up work to our OOPSLA paper. It is implemented on top of the Viper static verifier and supports the C0 programming language. The C0 language is a safer, smaller subset of C taught in introductory CS courses at CMU. Finally, I conclude the talk with my short-term plans to evaluate our tool&amp;mdash;which includes a case study on web browser JIT code&amp;mdash;and my long-term vision for the field of gradual verification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a fifth year PhD student in the Institute for Software Research at Carnegie Mellon University, and I am co-advised by Jonathan Aldrich and Joshua Sunshine. My research interests lie at the intersection of programming languages, software verification, and software engineering. In general, I intend to make verification technology, like formal verification and program analysis, more usable in practice. Towards this end, my thesis is dedicated to work in gradual verification, which supports incremental formal verification through the use of both static and dynamic techniques. I have also used ideas from gradual verification to produce a gradual null pointer analysis [2] that reduces false positives compared to state-of-the-art tools. It systematically deploys run-time checks wherever the underlying static analysis is imprecise. Further, I previously contributed to the language design of Penrose &amp;mdash; which generates diagrams from mathematical prose &amp;mdash; and Obsidian &amp;mdash; a programming language that facilitates the development of secure blockchain applications. Outside of work, I enjoy playing video games, such as League of Legends and Final Fantasy XIV Online. I also enjoy bowling and often average more than 170 points per game!&lt;/p&gt;

&lt;p&gt;[1] Wise, J., Bader, J., Wong, C., Aldrich, J., Tanter, É., Sunshine, J., &amp;ldquo;Gradual Verification of Recursive Heap Data Structures&amp;rdquo;, The ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH20), OOPSLA, November 15-20, 2020, Online&lt;/p&gt;

&lt;p&gt;[2] Estep, S., Wise, J., Aldrich, J., Tanter, É., Bader, J., and Sunshine, J., &amp;ldquo;Gradual Program Analysis for Null Pointers&amp;rdquo;, The 35th European Conference on Object-Oriented Programming (ECOOP21), July 11-17, 2021, Online&lt;/p&gt;

&lt;h1 id=&#34;nov-5&#34;&gt;Nov. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Domain-specific optimizing compilers such as Halide
enable programs to be expressed at a convenient high-level, while
generating high-performance code for parallel architectures. As
domains of interest expand towards deep learning, probabilistic
programming and beyond, it becomes increasingly clear that it is
unsustainable to redesign domain specific compilers for each new
domain. In addition, the rapid growth of hardware architectures to
optimize for poses great challenges for designing these compilers.&lt;/p&gt;

&lt;p&gt;In this talk, I will show how to extend a unifying domain-extensible
compiler with domain-specific as well as hardware-specific
optimizations.  Optimizations are not hard-coded into the compiler but
are expressed as user-defined rewrite rules that are composed into
strategies controlling the optimization process. On four mobile ARM
multi-core CPUs, the code generated for the Harris image processing
pipeline outperforms the image processing library OpenCV by up to 16x
and achieves performance close to - or even up to 1.4x better than -
the state-of-the-art image processing compiler Halide.&lt;/p&gt;

&lt;p&gt;However, optimization strategies are difficult to write because they
need to decide how to apply rewrite rules.  I will finish this talk by
presenting a technique we call &amp;ldquo;guided equality saturation via
sketching&amp;rdquo; to abstract over individual rewrites.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a PhD student in computer science at the University of Glasgow in
Scotland, where I work closely with my supervisor Michel Steuwer. I am
the lead developer of the &lt;a href=&#34;https://rise-lang.org&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rise project&lt;/a&gt;, which
combines a high-level functional language with a system of rewrite rules
to encode optimization choices. It provides a domain-extensible way to
generate high performance code for diverse hardware architectures.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Personal website&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-12&#34;&gt;Nov. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Sparse Matrices and High-Performance Computing Meet Biology&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In computational and data sciences, the need for scalable computing and data systems has recently increased due to the flood of data in areas such as genomics. Yet, scalable parallel programming in distributed memory is difficult, and high-performance computing (HPC) systems are typically allocated to specific research communities and have long user wait times, limiting access to resources and scientific discoveries.&lt;/p&gt;

&lt;p&gt;In this context, we have developed a novel set of genomics algorithms for de novo genome assembly (i.e., reconstruction of an unknown genome from redundant, erroneous genomic sequences) that are integrated into the diBELLA 2D software package and are based on sparse matrix multiplication supporting general semiring abstraction. This enables the creation and easy modification of powerful genomics pipelines that take advantage of massively parallel hardware without exposing low-level architecture. diBELLA 2D is up to 2x faster on 100s nodes than a 1D algorithm based on distributed hash tables, which are more difficult to parallelize. diBELLA 2D integrates GPU support in the most compute-intensive stages of the pipeline to take advantage of today&amp;rsquo;s heterogeneous HPC hardware.&lt;/p&gt;

&lt;p&gt;To ensure that the genomics research community and others in general, can benefit from HPC, the development of distributed algorithms such as diBELLA 2D must be coupled with efforts to make distributed computing more accessible. To this end, we have shown that we are on the cusp of a paradigm shift in high-performance computing (HPC) away from purely institutional or agency-wide HPC systems to cloud computing, as the latter has made significant advances in networking technology and HPC system software.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Giulia is a Ph.D. candidate in Computer Science at UC Berkeley and a graduate research assistant at the Computational Research Division of Lawrence Berkeley National Laboratory advised by Aydın Buluç and Kathy Yelick. Giulia is a 2020 SIGHPC Computational &amp;amp; Data Science Fellow and received her M.Sc. and B.Sc. in Biomedical Engineering from Politecnico di Milano. Her work is in the area of computer systems research, including cloud and parallel computing, and she is interested in building a collaborative interdisciplinary research program. Giulia is currently working on the challenges of large-scale computational biology, as well as the algorithms and software infrastructures that meet the usability and performance demand of this community. Currently, she is developing a novel algorithm for de novo assembly of genomes in distributed memory using long-read sequencing data and sparse matrix abstraction as part of the ExaBiome project. Giulia is also working on how to make cloud computing more accessible for high-performance scientific computing.&lt;/p&gt;

&lt;h1 id=&#34;nov-19&#34;&gt;Nov. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Persistent memory (PM) is a new storage technology that combines the speed and byte-addressability of DRAM with the durability of hard disks and solid state drives. Recent research has explored using PM in a number of different applications like databases and file systems. However, programming PM applications correctly is difficult; in order for data to be guaranteed durable on PM, developers must understand and use a set of assembly instructions to manage persistence. In particular, PM applications are prone to crash consistency bugs, where buggy data management leads to incorrect behavior after a crash.&lt;/p&gt;

&lt;p&gt;PM file systems are a growing subset of PM applications, but there are currently no testing tools that target crash consistency bugs in these file systems. In this talk, I will describe my work on building a crash consistency testing framework designed specifically for PM file systems. I will present an overview of our testing approach and the bugs that the tool has found, and discuss the implications of these bugs on the development of PM file systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Hayley LeBlanc is a second year PhD student at the University of Texas at Austin. She is interested in developing techniques and tools to make sure that storage systems are reliable and correct. She also enjoys fencing and volunteering at her local animal shelter.&lt;/p&gt;

&lt;h1 id=&#34;dec-3&#34;&gt;Dec. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Formal proofs are often employed to show correctness of cryptographic routines at the assembly level, especially in instances where architecture-optimized performance is desirable or where compilers do not exist for the target ISA. While common cryptographic routines are often implemented in many different ISAs, the current cost of verification scales poorly with the number of architectures. In this talk, we explore solutions for writing correctness proofs for cryptographic routines which are generic across different architectures.&lt;/p&gt;

&lt;p&gt;Specifically, we will look at assembly implementations of an RSA signature verification routine in RISC-V and in the OpenTitan BigNumber Accelerator (OTBN) ISA. Despite dramatic differences in these two ISAs, we find that the high-level control flow structure of the RSA routine is quite similar across implementations. We use this observation to construct a framework for writing partial architecture-generic assembly-level proofs which are abstracted over hardware details (e.g., register width). We will discuss how this framework can be used to reduce the overhead of proving the correctness of common cryptographic routines on different architectures, and look to future possibilities for further reducing this overhead.~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sydney is a second-year Ph.D. student in the Computer Science Department of Carnegie Mellon, advised by Bryan Parno. She is interested in formal techniques for verifying safety and security properties of low-level, high-performance systems at scale. Sydney received her B.S. and M.Eng. from MIT, where she worked on verification techniques for concurrent, crash-safe systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021sp/</link>
      <pubDate>Sun, 21 Feb 2021 12:27:37 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For spring 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-2&#34;&gt;April 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Running the Trails of Data Management&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-9&#34;&gt;April 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PL design and programming by voice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-16&#34;&gt;April 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-23&#34;&gt;April 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Konstantinos Kallas&lt;/td&gt;
&lt;td&gt;PaSh: A parallelizing shell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-30&#34;&gt;April 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Eric Atkinson&lt;/td&gt;
&lt;td&gt;Programming and Reasoning with Partial Observability&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-7&#34;&gt;May 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vadim Zaliva&lt;/td&gt;
&lt;td&gt;HELIX: From Math to Verified Code&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-14&#34;&gt;May 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-21&#34;&gt;May 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zeeshan Lakhani&lt;/td&gt;
&lt;td&gt;Polarized Functional Programming v0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-28&#34;&gt;May 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Philippa Cowderoy&lt;/td&gt;
&lt;td&gt;Information Aware Type Systems and Telescopic Constraint Trees&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-4&#34;&gt;June 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ranysha Ware&lt;/td&gt;
&lt;td&gt;Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;april-2&#34;&gt;April 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Running the Trails of Data Management&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The demise of Moore&amp;rsquo;s law and Dennard scaling have swung a pendulum back towards computational storage&amp;ndash;disk drives equipped with modest processors and working memory. As was the case when the earliest ``active drives&amp;rdquo; were developed over three decades ago, moving computational kernels closer to where the data is stored presents an opportunity to improve data processing and retrieval performance by alleviating bottlenecks at CPUs that can no longer promise exponential increases in performance over time. We explore this opportunity in a 3-way collaboration between industry and academia with the goal of showing the benefits provided by computational storage devices for scientific analysis workloads. The analysis workloads are based on use cases for the Human Cell Atlas (HCA) and the UCSC Genomics Institute, the computational storage devices are architected and designed by Seagate, and the system that brings these together is architected by our declarative programmable storage research group at UCSC. This talk uses trail running as a fun metaphor to detail the context and directions of our collaboration that spans data management, single-cell RNA sequencing, and a storage system that leverages computational storage devices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aldrin is a 3rd year PhD student at UC Santa Cruz advised by Peter Alvaro, but works extensively with Carlos Maltzahn (UCSC), Jeff LeFevre (UCSC), and Philip Kufeldt (Seagate). Aldrin received his B.S. and M.S. in computer science from Cal Poly, San Luis Obispo working with Alex Dekhtyar on a collaborative, microbial source tracking project with professors and students in the biology and biochemistry departments. Before joining UCSC’s PhD program, Aldrin has worked on data management of genomic variants at a biotech company, Personalis, Inc. His research interests are primarily in data management systems and bioinformatics, but also span programming languages, storage systems, and software engineering.&lt;/p&gt;

&lt;h1 id=&#34;april-9&#34;&gt;April 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PL design and programming by voice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers and other computer users suffer from repetitive strain injuries (RSI) of the hand that make using a keyboard for extended periods painful. For some kinds of RSI, therapy or surgery may resolve the problem, but in recalcitrant cases sometimes the only option is to reduce or cease typing. So what does a programmer do if they can&amp;rsquo;t type?One option is to use your voice. Speech recognition technology has advanced by leaps and bounds over the past decade, but most people&amp;rsquo;s ideas about voice-driven UI are based on convenient but limited voice assistants like Siri or Alexa, or at best dictation or prose-writing tools. What does a voice interface for expert users look like? A small but growing community of programmers, many affected by RSI, have been developing and using tools that explore this question.I suffer from RSI and use a voice control tool called Talon to program, control my computer, and write my thesis; but I&amp;rsquo;m also a programming languages researcher, and so I find it natural to wonder: how might PL research intersect with voice control? In this talk, I&amp;rsquo;ll try my best to answer that question, as well as a few others:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is voice coding like?  What unique challenges does it present compared with keyboard coding?&lt;/li&gt;
&lt;li&gt;What can we learn from this about designing voice interfaces for expert users?  Specifically, how can programming languages better support voice coding?&lt;/li&gt;
&lt;li&gt;How does a voice control system work?  What does it have in common with PL implementation?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Depending on how you count, Michael Arntzenius is somewhere between a 4th- and a 9th-year PhD student. He works with Neel Krishnaswami on Datafun, an attempt to combine the bottom-up deductive query language Datalog with higher-order typed functional programming. He is interested in monotonicity as a unifying and simplifying theme in incremental, concurrent, and distributed computation; and generally in the theory, design, and implementation of programming systems.&lt;/p&gt;

&lt;h1 id=&#34;april-16&#34;&gt;April 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software supply-chain attacks are becoming an important security concern. These attacks focus on a dependency of the target rather than the target itself and often affect the target as well as other consumers of that dependency. We propose active library learning and regeneration (ALR) techniques for inferring and reconstructing the core functionality of a black-box software dependency. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the dependency, and observes the dependency’s outputs and interactions to infer a model of the dependency’s behavior captured in a domain-specific language. We present HARP, an ALR system for string processing dependencies. We apply HARP to successfully regenerate string-processing libraries in JavaScript, Python, and C/C++. In the majority of cases, HARP completes the regeneration in less than a minute, remains fully compatible with the original library, and achieves performance indistinguishable from the original library. We also demonstrate that HARP can eliminate vulnerabilities associated with libraries targeted in a number of highly visible security incidents of the JavaScript ecosystem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Achilles Benetopoulos is a backend software engineer at Plum Fintech. He received a Masters degree in Engineering from the National Technical University of Athens. He is interested in exploring better ways of building robust and performant distributed systems. Starting in the fall, he will be joining UC Santa Cruz as a graduate student advised by Peter Alvaro, to work towards this goal. When he gets too frustrated by computers, he cooks.&lt;/p&gt;

&lt;h1 id=&#34;april-23&#34;&gt;April 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Konstantinos Kallas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PaSh: A parallelizing shell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk I will present PaSh, a new shell that exposes data parallelism in POSIX shell scripts. To achieve that, PaSh proposes: (i) an order-aware dataflow model that captures a fragment of the shell, (ii) a set of dataflow transformations that extract parallelism and have been proven to be correct, (iii) a lightweight framework that captures the correspondence of shell commands and order-aware dataflow nodes, and (iv) a just-in-time compilation framework that allows for effective compilation despite the dynamic nature of the shell. PaSh is open-source and you can try it out today here: &lt;a href=&#34;https://github.com/andromeda/pash&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/andromeda/pash&lt;/a&gt;. If you want to learn more about it you can read our paper that will appear in EuroSys 2021 (next week) here: &lt;a href=&#34;https://arxiv.org/abs/2007.09436&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2007.09436&lt;/a&gt; and if you want to learn more about the dataflow model you can read the paper that introduces it and proves the correctness of the transformations here: &lt;a href=&#34;https://arxiv.org/abs/2012.15422&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2012.15422&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Konstantinos Kallas is a 3rd year PhD student at the University of Pennsylvania working with Rajeev Alur. They are broadly interested in all things PL, distributed systems, and greek folk mountain music. Recently, together with Nikos Vasilakis and several other amazing people they have been working on invigorating the research on the shell. They are also working on partial order semantics for distributed stream processing and programming models for serverless. You can find more information about them here: &lt;a href=&#34;https://angelhof.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://angelhof.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;april-30&#34;&gt;April 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Eric Atkinson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming and Reasoning with Partial Observability&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Computer programs are increasingly being deployed in partially-observable environments. A partially-observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a &lt;em&gt;state estimator&lt;/em&gt; that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an &lt;em&gt;environment model&lt;/em&gt;. The model captures the relationship between observations and hidden states and is used to prove the software correct.&lt;/p&gt;

&lt;p&gt;In my talk, I will present a new methodology for writing and verifying programs in partially observable environments. I will present &lt;em&gt;belief programming&lt;/em&gt;, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, I will present &lt;em&gt;Epistemic Hoare Logic&lt;/em&gt;, which reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. I will develop these concepts by explaining a semantics and a program logic for a simple core language called BLIMP. I will also discuss a case study in which we used BLIMP to implement a verified controller for the Mars Polar Lander, and I will evaluate the performance of a C implementation of BLIMP.&lt;/p&gt;

&lt;p&gt;Paper link: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3428268&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3428268&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Eric Atkinson is a 6th year PhD student at MIT advised by Michael Carbin. His primary research interests involve using programming language tools to help developers manage both probabilistic and nondeterministic uncertainty.&lt;/p&gt;

&lt;h1 id=&#34;may-7&#34;&gt;May 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vadim Zaliva&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HELIX: From Math to Verified Code&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk we will presents HELIX, a code generation and formal
verification system with a focus on the intersection of
high-performance and high-assurance numerical computing. This allowed
us to build a system that could be fine-tuned to generate efficient
code for a broad set of computer architectures while providing formal
guarantees of such generated code&amp;rsquo;s correctness.&lt;/p&gt;

&lt;p&gt;The method we used for high-performance code synthesis is the
algebraic transformation of vector and matrix computations into a
dataflow optimized for parallel or vectorized processing on target
hardware. The abstraction used to formalize and verify this technique
is an operator language used with semantics-preserving
term-rewriting. We use sparse vector abstraction to represent partial
computations, enabling us to use algebraic reasoning to prove parallel
decomposition properties.&lt;/p&gt;

&lt;p&gt;HELIX provides a formal verification foundation for rewriting-based
algebraic code synthesis optimizations, driven by an external
oracle. Presently HELIX uses SPIRAL as an oracle deriving the rule
application order. The SPIRAL system was developed over the years and
successfully applied to generate code for various numeric
algorithms. Building on its sound algebraic foundation, we generalize
and extend it in the direction of non-linear operators, towards a new
theory of partial computations, applying formal language theory and
formal verification techniques.&lt;/p&gt;

&lt;p&gt;HELIX is developed and proven in Coq proof assistant and demonstrated
on a real-life example of verified high-performance code generation of
the dynamic window safety monitor for a cyber-physical robot system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vadim Zaliva works on formal verifications of computer programs,
presently as a Senior Research Associate at Cambridge University and
previously as part of his Ph.D. at Carnegie Mellon University. His
diverse academic interests in addition to formal methods range from
computer security to machine learning and gesture recognition. With
20+ years of experience in the design and implementation of commercial
software, he has worked through the ranks of the software industry
from software engineer to CTO, CEO, and company founder.&lt;/p&gt;

&lt;h1 id=&#34;may-14&#34;&gt;May 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this work, we specify a formal semantics of NVIDIA&amp;rsquo;s SASS instruction set, the ISA that is actually executed by NVIDIA GPUs.  We introduce the ROCetta approach for discovering the semantics of a target language that requires the semantics a source language, and the ability to obtain a translation from the source to the target language.   Using this approach, we have discovered and verified the semantics of 421 SASS instructions.  In addition, our verification effort was able to uncover 18 bugs in the CUDA compiler&amp;rsquo;s translation of single-instruction PTX programs.  In some cases, bugs were only caught during verification and were missed by the testing framework, which lacked a test for inputs that trigger the bug. Furthermore, verification of 3,581 programs took 14 minutes when run in parallel, while running the full test suite against hardware took upwards of 30 minutes.  The low cost of verification, along with its superior ability to detect bugs, makes it an invaluable tool to detect bugs that occur in the translation of small programs.&lt;/p&gt;

&lt;h1 id=&#34;may-21&#34;&gt;May 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zeeshan Lakhani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Polarized Functional Programming v0.1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When designing a new, real-world type system, where would you start? Looking for
examples, you may notice that a language like Typescript has a myriad of
advanced typing features, though they&amp;rsquo;re oriented toward trying to
capture JavaScript&amp;rsquo;s many dynamic idioms and (now) lengthy history of existing
programs. Furthermore, even with these advanced features, the language is not
sound, i.e. certain operations cannot be known to be type-safe at compile-time.
Looking elsewhere, like in the ML family of languages, you&amp;rsquo;ll see a powerful
type inference mechanism helping to free programmers from the burden of
numerous, explicit type annotations. Yet, as new research-driven type extensions
have been incorporated, the need for explicit annotations or pre-processing
steps has increased in certain situations. As the complexity of our programs and
the properties about them that we&amp;rsquo;d like to statically guarantee grow, how far
can just typechecking take us while remaining sound and without us having to
associate proofs with our programs?&lt;/p&gt;

&lt;p&gt;The answer is pretty far. Lightweight verification through refinement types is
catching on. Most &lt;em&gt;modern&lt;/em&gt; languages, e.g. Rust, OCaml, Dotty/Scala, come out of
the box with sum types or enumerated variants and integrations for extended
static code analysis. Our answer to these questions lies in the powerful
relationship between static analysis and type theory and how to treat evaluation
(essentially, eager versus lazy) as first-class.&lt;/p&gt;

&lt;p&gt;In this talk, I will present our work-in-progress research on a polarized
functional programming language based on the call-by-push-value (CBPV)
λ-calculus, which allows for the mixing of both call-by-name and call-by-value
evaluation inside of a single program via a kind-like operator, shifting between
positive and negative types. We extend this polarized calculus further with a
transparent and equirecursive interpretation of mixed-inductive-and-coinductive datatypes,
allowing us to leverage strong structural subtyping and datasort refinements over sums and
intersections. Additionally, typechecking works bidirectionally in our system,
meaning that terms can be checked to a certain type or synthesized as a
certain type, which scales well for adding various expressive type features to
our language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zeeshan is the founder of Papers We Love and PWLConf, as well as an organizer. He&amp;rsquo;s also
the Director of Research and Development at BlockFi working on various data and program
analysis projects. And, he&amp;rsquo;s a PhD student at Carnegie Mellon University&amp;rsquo;s School of
Computer Science, studying Programming Languages under Frank Pfenning.&lt;/p&gt;

&lt;h1 id=&#34;may-28&#34;&gt;May 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Philippa Cowderoy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Information Aware Type Systems and Telescopic Constraint Trees&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What does conservation of information have to do with type systems? Are type checkers specialised operating systems? Can we understand dataflow in type systems or are we doomed to drown in it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll present a highly familiar type system in pursuit of an `Information Aware&amp;rsquo; style, using information effects to reveal data flow and help in implementing a checker. I also calculate a general, scoped, constraint-based representation of typechecking problems from the typing rules.&lt;/p&gt;

&lt;p&gt;And then, because why not? Let&amp;rsquo;s toy with substructural systems and maybe even incremental checking!&lt;/p&gt;

&lt;p&gt;Warning: talk may contain willfully creative use of long-standing concepts&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Philippa Cowderoy is a professional procrastinator and amateur computer scientist, having dropped out of the University of Nottingham as an undergraduate in 2007.&lt;/p&gt;

&lt;p&gt;Somehow this still hasn&amp;rsquo;t put her off being frustrated with her tools on a increasingly deeper level. When she is bored enough, she is now mining particularly meta veins of frustration shared by others in the PL community.&lt;/p&gt;

&lt;p&gt;In her copious free (if not high-quality) time she plays too many games and spends too little time around cats.&lt;/p&gt;

&lt;h1 id=&#34;june-4&#34;&gt;June 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ranysha Ware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The stability of the Internet relies on congestion control algorithms (CCAs) to efficiently and fairly share limited network resources. Dozens of congestion control algorithms have been proposed in the past 30 years, however, we still lack a good way to decide whether a new algorithm is reasonable to deploy on the Internet. As we will show in this talk, new algorithms can be dramatically unfair to widely-deployed legacy algorithms. For example, we prove that Google&amp;rsquo;s new CCA, BBR, will always consume a fixed fraction of the link when competing with any number of Cubic flows.&lt;/p&gt;

&lt;p&gt;Given the threat of poor performance due to competing heterogeneous CCAs, in this talk we discuss considerations for deploying new CCAs on the Internet. While past efforts have focused on achieving fairness or friendliness between new algorithms and legacy algorithms, we instead advocate for an approach centered on quantifying and limiting harm caused by the new algorithm on the status quo. We argue that a harm-based approach is more practical, more future proof, and handles a wider range of quality metrics than traditional notions of fairness and friendliness.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;  Ranysha Ware is a PhD student in Carnegie Mellon University’s Computer Science Department, co-advised by Professor Justine Sherry and Professor Srinivasan Seshan. Her bailiwick is computer networking. Her current research focuses on challenges arising from the deployment of new transport protocols and congestion control algorithms in the Internet. Ranysha earned her M.S. (2015) from UMass Amherst and B.S (2013) from SUNY New Paltz. She is a recipient of the IRTF Applied Networking Research Prize, Facebook Emerging Scholar Award, and National GEM Consortium Fellowship.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021wi/</link>
      <pubDate>Sat, 02 Jan 2021 21:45:29 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For winter 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/about&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-8&#34;&gt;Jan. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Introductions and social time&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-15&#34;&gt;Jan. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-22&#34;&gt;Jan. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-29&#34;&gt;Jan. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;On the Design, Implementation, and Use of Laziness in R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-5&#34;&gt;Feb. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-12&#34;&gt;Feb. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-19&#34;&gt;Feb. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kamala Ramasubramanian&lt;/td&gt;
&lt;td&gt;ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-26&#34;&gt;Feb. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-5&#34;&gt;March 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vinujoseph.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vinu Joseph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Programmable Neural Network Compression with Correctness Emphasis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-12&#34;&gt;March 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Daniel Bittman&lt;/td&gt;
&lt;td&gt;Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-8&#34;&gt;Jan. 8&lt;/h1&gt;

&lt;p&gt;Introductions and social time&lt;/p&gt;

&lt;h1 id=&#34;jan-15&#34;&gt;Jan. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Session types have long promised the ability to enforce complex temporal invariants about message ordering in distributed systems, guaranteeing that a well-session-typed program always correctly follows a messaging protocol to its end. Despite their potential, these type systems have seen relatively little adoption in the mainstream. In part, this is due to their inherent reliance on linear typing, a feature not present and difficult to emulate in most popular languages. Recently, this has changed with the emergence of Rust, a systems programming language built atop a flexible &amp;ldquo;ownership type system&amp;rdquo; to track reference aliasing. Although Rust enforces in actuality a form of affine typing (weaker than the linear typing most formal session-typed calculi require) it&amp;rsquo;s enough to build a library for session types that statically enforces the slightly-weaker guarantee that a program correctly follows a messaging protocol so long as it is running, but may quit the session early. Of course, this is the best we can hope to get in the real world! Networks go down, computers crash, and hardware just plain breaks. For session types to be broadly adopted, they must survive contact with this real and unpredictable world—and equally, with the real and unpredictable people who want to use them in their programs.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve just released version 0.2 of &lt;a href=&#34;https://docs.rs/dialectic&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dialectic&lt;/a&gt;: a library for pragmatic, succinct, efficient session types in Rust. Dialectic embraces Rust&amp;rsquo;s burgeoning ecosystem of high-performance async networking by being polymorphic over any backend transport used to convey messages between parties. Unlike many libraries for session types, Dialectic assumes that the other party might break protocol or disconnect at any time, and is designed to gracefully handle such failures without compromising type safety.  Dialectic is designed to be used for writing specifications and programs of every size from small to large, and provides what&amp;rsquo;s needed to write modular specifications and implementations of complex protocols—and not merely the regular session types expressible in most libraries, but all context-free session types.&lt;/p&gt;

&lt;p&gt;More than merely showing off this cool thing I&amp;rsquo;m working on, I want to talk about the design process that went into making it. Designing a programming paradigm—whether you want to call it an embedded domain-specific language or merely a library—is a multi-faceted puzzle spanning considerations from psychological familiarity to formal computability. My hope is that in walking through this case study in embedded language design, we can spark more thoughts about how we as PL researchers can play in this field together and design beautiful, useful tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kenny Foner (kwf@very.science) is a senior software engineer at Bolt Labs working on privacy-preserving financial technology for everyone. They have a master&amp;rsquo;s degree in programming languages from the University of Pennsylvania, where they worked on a smorgasbord of fun things from laziness to random testing. When they&amp;rsquo;re not writing Rust, they&amp;rsquo;re usually somewhere in the forest.&lt;/p&gt;

&lt;h1 id=&#34;jan-22&#34;&gt;Jan. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Memory consistency models (MCMs) have been formulated as a mechanism for expressing the legal ordering and visibility of shared memory accesses in hardware and software. They are fundamental for ensuring heterogeneous components of a system execute and interact as expected to prevent hardware-induced bugs in real-world programs. However, ISA-level MCMs are limited to defining the behavior of only user-facing assembly instructions and do not account for virtual memory implementations that may result in the execution of 1) hardware-level state updates and 2) system-level interactions. Both are capable of accessing memory and may affect program outcomes, thus making them software-visible. As a result, memory transistency models (MTMs) have been coined as a superset of MCMs to additionally capture and enforce virtual memory-aware ordering rules. However, no prior work enabled the formal specification or analysis of MTMs.&lt;/p&gt;

&lt;p&gt;TransForm fills this gap by introducing an axiomatic vocabulary for formally specifying MTMs that builds on the standard axiomatic vocabulary traditionally used for describing MCMs. It provides new constructs for modeling transistency-specific features such as hardware-level state updates and system-level interactions. Using this new axiomatic vocabulary, MTMs can be formally specified and used with TransForm’s synthesis engine to synthesize litmus tests enhanced with transistency features, called enhanced litmus tests. This talk will cover TransForm’s axiomatic vocabulary and synthesis engine, as well as a case study performed with TransForm to formally define an approximate MTM for Intel x86 processors.&lt;/p&gt;

&lt;h1 id=&#34;jan-29&#34;&gt;Jan. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; On the Design, Implementation, and Use of Laziness in R&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I will present the design and implementation of call-by-need in R, and a data-driven study of how generations of programmers have put laziness to use in their code. In our study, we analyze 16,707 R packages and observe the creation of 270.9 B promises. Our data suggest that there is little supporting evidence to assert that programmers use laziness to avoid unnecessary computation or to operate over infinite data structures. For the most part R code appears to have been written without reliance on and in many cases even knowledge of, delayed argument evaluation. The only significant exception is a small number of packages which leverage call-by-need for meta-programming. I will discuss how we intend to leverage these insights to remove laziness from R and enable non-intrusive migration of code from lazy to eager evaluation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aviral Goel is a Computer Science Ph.D. student at Northeastern University, advised by Professor Jan Vitek. He received his Bachelor&amp;rsquo;s degree in Electronics and Communication Engineering from Netaji Subhas Institute of Technology, India.&lt;/p&gt;

&lt;p&gt;He is interested in improving tools and techniques for data science applications. He is enabling R programmers to write faster and bug-free code by migrating the language from lazy-by-default to lazy-on-demand semantics.&lt;/p&gt;

&lt;p&gt;He is also involved in the development of a type system for R.&lt;/p&gt;

&lt;h1 id=&#34;feb-5&#34;&gt;Feb. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Today, most code still runs on expensive, power-hungry processors that prioritize single-thread performance. Speculative parallelization is an enticing approach to accelerate computation while retaining the ease of sequential programming, by launching tasks in parallel before knowing if they are independent. Unfortunately, prior speculative parallelizing compilers and architectures achieved limited speedups due to high costs of recovering from misspeculation and hardware scalability bottlenecks.&lt;/p&gt;

&lt;p&gt;We present T4, a parallelizing compiler that executes sequential programs as trees of tiny timestamped tasks. T4 targets the recent Swarm architecture, which presents new opportunities and challenges for automatic parallelization. T4 introduces novel compiler techniques to expose parallelism aggressively across the entire program, breaking applications into tiny tasks of tens of instructions each. Task trees unfold their branches in parallel to enable high task-spawn throughput while exploiting selective aborts to recover from misspeculation cheaply. T4 exploits parallelism across function calls, loops, and loop nests; performs new transformations to reduce task spawn costs and avoid false sharing; and exploits data locality among fine-grain tasks. As a result, T4 scales several hard-to-parallelize SPEC CPU2006 benchmarks to tens of cores, where prior work attained little or no speedup.&lt;/p&gt;

&lt;p&gt;For more information, please visit &lt;a href=&#34;swarm.csail.mit.edu&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;swarm.csail.mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Victor Ying is a 5th year PhD student at MIT, advised by Daniel Sanchez. He works on parallel architectures, compilers, and programming models. Victor&amp;rsquo;s recent work focuses on redesigning abstractions between hardware and software to make it as easy to exploit multicore parallelism as it is to write ordinary sequential programs. His prior work includes Boolean satisfiability solvers, scheduling machine learning workloads on hardware accelerators, and embedded and distributed systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-12&#34;&gt;Feb. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers use dependently-typed languages like Coq to
machine-verify high-assurance software. However, existing compilers for
these languages provide no guarantees after compiling, nor when linking
after compilation. Type-preserving compilers preserve guarantees encoded
in types, then use type checking to verify compiled code and ensure safe
linking with external code. Unfortunately, dependent type systems are
highly sensitive to syntactic changes, including compilation, so
preserving them through a compiler pass is difficult.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some examples of why dependent typing is
difficult to preserve through simple syntactic changes. I will also
present our solution to preserving dependent types through the ANF
translation, a necessary transformation towards compiling a functional
language down to machine code. Our ANF translation preserves dependent
types, provided that the target type system has a way to encode these
syntactic semantics-preserving changes. We encode these by including
extensional equality in our target type system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Paulette Koronkevich is a second year graduate student (finishing
MSc and starting PhD) at the University of British Columbia, working
with William J. Bowman. She has a undergraduate degree in computer
science from Indiana University. Her interests include compilers, cats,
and cooking.&lt;/p&gt;

&lt;h1 id=&#34;feb-19&#34;&gt;Feb. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kamala Ramasubramanian&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Incidents in production systems are common and downtime is expensive. Applying an appropriate mitigating action quickly, such as changing a specific firewall rule or routing around a broken network link, saves money. Identifying where to mitigate is time-consuming since a single failure can produce widespread effects. Knowing how different system events relate to each other is necessary to quickly identify where to mitigate. Our approach, Aggregate Comparison of Traces (ACT), localizes incidents by comparing sets of traces (which capture events and their relationships for individual requests) sampled from the most recent steady-state operation and during an incident. In our quantitative experiments, we conduct hundreds of simulations and show that ACT is able to identify exactly where to mitigate in all but a few cases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kamala Ramasubramanian is a PhD candidate at University of California, Santa Cruz advised by Peter Alvaro. She works on understanding, implementing and troubleshooting distributed systems by reasoning about observed system executions. She recently became interested in system verification and how it may overlap with her current work. She is a vegetarian foodie, likes to CrossFit and wants to try surfing.&lt;/p&gt;

&lt;h1 id=&#34;feb-26&#34;&gt;Feb. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In recent years, quantum computing (QC) hardware has progressed considerably with small systems being prototyped by industry and academic vendors. However, there is a huge gap between the resource requirements of promising applications and the hardware that is buildable now; qubit counts and operational noise constraints of applications exceed hardware capabilities by 5-6 orders of magnitude. Our work seeks to enable practical QC by bridging this gap: from the top with novel compiler techniques and algorithmic optimizations to reduce application requirements and from the bottom via system architectures efficiently exploiting scarce QC resources.&lt;/p&gt;

&lt;p&gt;In this talk, we present two cross-cutting optimizations that narrow the applications-to-hardware resource gap. First, we present noise-adaptive compilation techniques that optimize applications for the spatio-temporal noise variations seen in real QC systems. Using real executions, we demonstrate average fidelity improvements of 3X using noise-adaptivity, compared to industry compiler tools. Second, on the architecture front, we study instruction set design issues considering application requirements and hardware gate calibration overheads. Current QC systems either use ISAs with a single two-qubit gate type or families of continuous gate sets. Using architectural simulations based on Google and Rigetti hardware, we show that QC instruction sets with 4-8 two-qubit gate types are best suited for expressing application requirements, while incurring tractable calibration overheads. In response to our work, several industry vendors have included noise-adaptivity and its extensions as part of their toolflows and adjusted device architecture to expose more native operations and hardware characterization data.&lt;/p&gt;

&lt;h1 id=&#34;march-5&#34;&gt;March 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vinu Joseph&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programmable Neural Network Compression with Correctness Emphasis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Deep neural networks (DNNs) frequently contain far more weights, represented at higher precision, than are required for the specific task which they are trained to perform.
Consequently, they can often be compressed using techniques such as weight pruning and quantization that reduce both the model size and inference time without appreciable loss in accuracy.
However, finding the best compression strategy and corresponding target sparsity for a given DNN, hardware platform, and optimization objective currently requires expensive, frequently manual, trial-and-error experimentation.
In this talk, we introduce a programmable system for model compression called Condensa. Users programmatically compose simple operators, in Python, to build more complex and practically interesting compression strategies.
Given a strategy and user-provided objective (such as minimization of running time), Condensa uses a novel Bayesian optimization-based algorithm to automatically infer desirable sparsities.
Our experiments real-world DNNs demonstrate memory footprint and hardware runtime throughput improvements of 188x and 2.59x, respectively, using at most ten samples per search.
We have released a reference implementation of &lt;a href=&#34;https://github.com/NVlabs/condensa&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Condensa&lt;/a&gt;. Next, we will talk about our recent correctness extension where we preserve not just the overall accuracy but also metrics relating to model fairness and interpretability.
To achieve this, we augment the compression loss function with terms arising from the teacher-student learning paradigm and show how to automatically tune the associated parameters.
We demonstrate the effectiveness of our approach on multiple compression schemes and accuracy recovery algorithms using several different real-world network architectures.
We obtain a significant reduction of up to 4.1X in the number of mismatches between the compressed and reference models, while also achieving a significant reduction in class-wise disparate impact metrics compared to the reference models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vinu Joseph is a Ph.D. candidate in Computer Science at the School of Computing at the University of Utah, Salt Lake City, working on efficient deep learning computing, robustness, and security of deep learning algorithms, advised by Prof. Ganesh Gopalakrishnan.
He is one of the five recipients of the NVIDIA Graduate fellowship, the recipients were selected based on their academic achievements and area of research.
Prior to graduate studies, Vinu worked at ARM Inc. During his tenure at ARM, he was a recipient of the Bravo award for developing the programmer’s model for verifying real-time (‘R’) profile architecture which provides high-performing processors for safety-critical environments.
Vinu’s current research focuses on optimizing deep neural network-based systems for performance and scalability. More broadly, His research is at the intersection of systems, programming languages, and machine learning, to create a more efficient, performant, secure, privacy-preserving, and correct software.
His Ph.D. research has been mainly focused on deep neural network compression for resource-efficient inference and robustness. He is generously supported by an NVIDIA Ph.D. fellowship, mentored by Saurav Muralidharan and Michael Garland, he developed Condensa: A Programming System for Model Compression and Optimization.&lt;/p&gt;

&lt;h1 id=&#34;march-12&#34;&gt;March 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Daniel Bittman&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Byte addressable, non-volatile memory (NVM) demands that we rethink the entire system stack. Twizzler is an operating system designed for the near-future of NVM on the memory bus. It removes the kernel from the I/O path, provides programs with direct access to NVM, enabling simpler and more efficient long-term operations on persistent data. Twizzler provides a clean-slate programming model for persistent data, realizing the vision of Unix in a world of NVM. It does this through a pervasive notion of data identity coupled with an efficient design for persistent pointers that allows programmers to construct persistent data structures in a large, persistent, global address space. This talk will present an overview of Twizzler and discuss upcoming directions for Twizzler in security, distribution, and programming languages.Bio&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Daniel is a PhD candidate at UC Santa Cruz, advised by Ethan Miller and Peter Alvaro. His interests are in kernel programming and design, security, non-volatile memory, and concurrent programming. His current project is on developing an operating system for non-volatile memories and developing operating system designs and interfaces for better programming and data models in such an environment.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
